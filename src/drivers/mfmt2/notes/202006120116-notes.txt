{390}  -*- text -*-
[0:

Fri Jun 12 01:17:00 2020 Well we finally moved the ulam5 branch, and
the mfmt2 branch, onto develop.  And that's now seeming to settle
down, although I expect a few lingering explosions or overlooked bits
will turn up occasionally.

In any case, for ages we have been doing notes for itcSpike12 in the
T2-12 tree, which really does seem just wrong for all this MFM tree
development, so I'm starting up this notes file here in honor of
merging to develop.

:0]
[1:

Fri Jun 12 01:19:47 2020 To get us started, some quick

TODO:

 - Rework the Tile menu to pull in the old CPU freq changing stuff[2:
   Fri Jun 12 03:06:32 2020 Which turned out to be nothing more than a
   system() call.. :2]

[5: Fri Jun 12 03:59:13 2020
DONE :5] - Pull in the CPU freq changing stuff sufficient to start slowing the
   clock when the core temperature goes high.[3: Making another
   TimeoutAble to watch the core temp and control the CPU..  :3]

   = core temp ACCEPTABLE -> 1000MHz
   = core temp HIGH -> 720MHz
   = core temp
[4: Fri Jun 12 03:07:27 2020

 - Consider ditching the circuit abstraction.  With each ITC having a
   rack of passive EWs, aren't 16 active EWs really enough?  We could
   ensure we reserve one for hidden events if we wanted, right?  So if
   there's only one active EW left, we reject any centers that would
   require locks?

[6: Fri Jun 12 04:25:09 2020

 - Rough out a plan for ditching the circuit abstraction and
   simplifying the EW lifecycle as much as possible.  Key stages:
   = Allocate
   = Hog Sites          Note that site lifetimes
   = Acquire locks      and lock lifetimes are
   = Unhog sites        overlapping, not nested.
   = Release locks
   = Free

 :6]


:4]
:1]
[7:

Fri Jun 12 04:38:03 2020 So, active side EW story:



                +------------------+                                    +------------------+
                |Allocate active EW|                                    |+----------------+|
                |init center+radius|     /----------------------------->||Free active EW  ||
                +------------------+     |                              |+----------------+|
                        |                |                              +------------------+
                        v                |                                     ^
                      /    \             |                                     |
                     /      \   Fail     |                               +--------------+
                    Try to hog ----------/                               |Send HANGUPs  |
                    \ sites /                                            |for any ACKed |
                     \     /                                             |locks         |
                      \   /                                              +--------------+
                        v                                                      ^
                        | Succeed                                              |
                        v                                                +---------------+
                  +-------------+                                        |  Unhog sites  |
                  |  Send lock  |                                        |               |
                  |  requests   |                                        +---------------+
                  +-------------+
                        |
                        v
                       / \
                      /   \
                     / need\         +------------+
                    / more  \   No   |Perform     |
             ------>\  ACKs?/------->|transition  |
             |       \     /         +------------+
             |        \   /
             |         \ /
             |          v
             |          | Yes
             |          |
             |          v
             |    +------------+
             |    |Wait & check|  Timeout
             |    |for replies |------>
             |    +------------+
 -           |          |
             |          V           ^
             |         / \         / \
      +---------+     /   \       /   \
      |Record   | Yes/ Got \ No  / Got \
      |ACK      |<---\ ACK?/-----\ NAK?/
      +---------+     \   /       \   /
                       \ /         \ /
                        v           v




:7]
[8:

Fri Jun 12 05:22:15 2020 Well have been working on the retro flowchart
in :7: but realizing that we can't entirely ditch the 'circuit'
concept because, at the very least, each active EW needs to track what
locks it's got and how far it's gotten sending cache updates -- and
both of those items are currently stored in the CircuitInfos.

Now, we have CircuitInfo structs inside the EWs, but we ALSO have
Circuit structs inside the ITCs:

    in T2EventWindow                       in T2ITC

  struct CircuitInfo {                  struct Circuit {
    T2ITC * mITC;                         CircuitNum mNumber; // 0..CIRCUIT_COUNT-1
    CircuitNum mCircuitNum;     vs        u8 mEW;             // 1..MAX_EWSLOTS
    bool mLockAcquired;                   s8 mYoinkVal;       // -1,0,1
    s8 mMaxUnshippedSN;                 };
  };

Which looks a pretty damn ridiculous juxtaposition, just sitting
there, doesn't it?

Shouldn't we:

 - Move the yoinkVal into CircuitInfo,

 - Change CircuitNum mCircuitNum to T2EventWindow & mEW, always
   referring to the containing EW as a convenience,

 - Reduce MAX_EWSLOT from 32 to 16,

 - Use the EW slotNum wherever we used to use the CircuitNum, and

 - Terminate struct Circuit with prejudice

?

[9:

Fri Jun 12 05:45:16 2020 But do we also need a bit more CircuitInfo
state to make this go smoothly?[10:

Fri Jun 12 09:19:44 2020 Had a nice chat with Jeff.  Nap time.

:10]

:9]
:8]
[11:

Fri Jun 12 13:57:05 2020 Well do we execute here?  Sure.  struct
Circuit DIE DIE DIE
[12:

Fri Jun 12 13:58:26 2020 Do we maybe want an explicit state variable
in CircuitInfo?  Rather than, say, just the three-way s32 yoinkVal?
What would its states be?  Something like

  UNUSED    - Rest of CircuitInfo fields are invalid
  RUNG      - RING sent (active), recvd (passive)
  ANSWERED  - ANSWER recvd (active), sent (passive)

  DROPPED   - DROP recvd (active), sent (passive)
  TALKED    - CUPS sent/in progress
  HUNGUP    - Active side, done, free -> UNUSED



:12]
:11]
[13:

Sat Jun 13 11:21:58 2020 OK, in the middle of tearing out
T2ITC::Circuit and shifting to just an expanded T2EW::CircuitInfo.
Still tons of broken stuff on both sides.  Wondering about trying to
make the active vs passive EW distinction clearer somehow.  Right now
there's fundamentally different routes to looking them up -- active
EWs are owned by T2Tile, and are now accessed via

  T2EventWindow & getActiveEW(u32 idx)

, while passive EWs are stored in a T2ITC data member

  T2EventWindow * mPassiveEWs[CIRCUIT_COUNT];

and are apparently directly accessed via that member.

I'm also wondering about declaring a single extra one, like

  T2EventWindow T2Tile::mHiddenEW;

to use solely for lock-free 'hidden' events, so that (1) all 16
'active' EWs can be used for intertile events, and (2) hidden events
can still be run when all 16 active EWs are busy.

I wonder if EWInitiator should be designed to always check if any
active EWs are available first.. and do what with that information?
Try preferentially to pick a random spot that needs locks?  Nah.  Note
whether any active EWs are available, but then pick uniformly as
always.  If the chosen center requires no locks, use the hiddenEW,
otherwise allocate an active one.

Now that requires doing a bunch of stuff, without a chosen EW, that an
EW itself is currently doing.

It's also a throw-back to the 'as fast as possible' design approach
vs the 'stay in tempo' style that we dawningly realize is the
fundamental systemic approach.
[14:

Sat Jun 13 12:14:01 2020 But!  I'm looking at T2-PHF-18 and really
longing for one more bit for 'circuit number' so we could get back to
32.  And we note that both the Urgent bit (byte 0 bit 5) used to
identify Bulk traffic, and the MFM bit (byte 1 bit 7) used to identify
Flash traffic, are both associated with either slow or rare purposes.
We could merge them together and break them apart later.

Swap URG and MFM.  Then Flash and Bulk both have MFM (byte.bit 0.5)
set to 0, flash has URG (1.7) set to 0, and bulk has 1.7 set to 1.

Except I guess we have to rename URG to BLK or something.  Flash has
BLK set to 0 and Bulk has BLK set to 1.

Then, when MFM is 1, we have all of byte[1] available, and we could
have five bits of CN.

So this approach would take one bit of byte 1 away from Bulk -- which
can surely afford to lose it -- and give it to MFM, which could surely
use it.

It would mean doubling the space used for passive EWs, which was
already kind of non-trivial.[15:

Sat Jun 13 12:43:12 2020 Recall from
T2-12/pru/itcio/notes/202002010352-notes.txt :698:


        (gdb) p 6*16*sizeof(mSites)
        $210 = 346368

    Or about 350KB for all the passive EWs on a tile.

So that would go up to ~700KB?  It's still under 1MB.  And mfmt2 is
currently taking under 10% of memory.  We could spring for another
400KB.

But jeez, it means tearing up a lot of stuff:

 - LKM itc_pkt would have to be reworked and restabilized (AGAIN GAH)

 - app/cdm.pl would have to be reworked

 - (The current native engine code has to be reworked, but that's true
   no matter what.)

 - T2-PHF-18 would have to be reworked.

Yikes.  I can feel me: We're going to do this, aren't we?
[16:

Sat Jun 13 12:52:59 2020 Gah, We Are.

Starting with T2-PHF-19![17:

Sat Jun 13 13:05:57 2020 OK T2-PHF-19 exists, with first round
modifications for MFM<->URG + URG->BLK.

Question: Do we want to ditch/rename-away the 'telco lingo' -- RING,
TALK, etc?  It's cute but we've already had one confusion between BUSY
(passive side tells active side that active lost a race, so no) and
DROP (active side tells passive side the event passive agreed to has
been aborted without commit).

[18:

Sat Jun 13 13:23:59 2020 Not sure.  But let's keep it for now, with
the hope for once-burned-twice-shy on BUSY/DROP.

So.  Let's take a quick look at itc_pkt and see how horrible doing
this change might be.[19:

Sat Jun 13 13:26:29 2020 I guess we'd:

[22: Sat Jun 13 14:46:50 2020
DONE :22] - Rename PKT_HDR_BITMASK_URGENT -> PKT_HDR_BITMASK_MFM in itcpkt.h

[23: Mostly
DONE :23] - In general rename 'urgent' stuff to 'mfm' stuff

[24: Somewhat
DONE :24] - (Rename 'bulk' stuff to 'service' stuff?)

[25: First attempt anyway
DONE :25] - Rework the destination selection logic at itc_pkt_cb:2209+

[26:
DONE :26] - Rework the XITC values at itcpkt.h:90+ to shift by 5

[27:
DONE :27] - Rename PKT_HDR_BYTE1_BITMASK_MFM -> PKT_HDR_BYTE1_BITMASK_BULK at
   itcpkt.h:89

[28:
DONE :28] - Redefine PKT_HDR_BYTE1_BITMASK_XITC from 0x70 -> 0xe0

[29: Fixed, for the moment anyway, so
DONE :29] - Note the userspace XITC defs (itcpkt.h:95+) are also broken -- fix
   or ditch.

 - Rename mPriorityOB to mMFMOB?  itcpkt.h:241

 - Rename mBulkOB to mServiceOB? itcpkt.h:242

[20:

Sat Jun 13 13:44:25 2020 UGH: AND DO we ALSO want to take this
opportunity to give up on /dev/itc/mfm/ET..WT and go back to just
/dev/itc/mfm?

 - Currently, outbound mfm packets get routed to the appropriate PRU
   kfifo based on their packet header, regardless of which device was
   used to write them.  So having six devices does NOTHING for us
   there -- no extra speed or buffering or ordering or ANYTHING.

 - It does affect reading inbound mfm packets, where we get to
   decide which ITC packets to consider in our own randomized order,
   rather than necessarily dealing with them in the order that itc_pkt
   saw them arrive from the PRUs.  It does mean the different dirs
   aren't competing for inbound kfifo buffer space, which is probably
   a good thing on isotropy grounds but unlikely to matter except in
   highly stressed circumstances anyway.  And sharing a single kfifo
   is probably better on cache behavior grounds.

Let's leave it be for now.  At least, let's do and stabilize the PHF
changes before reconsidering this.[21:

Sat Jun 13 14:11:48 2020 Well, tearing into LKM.  Got at least two or
three hours here.  GO GO GO

:21]



:20]


:19]

:18]

:17]

:16]
:15]

:14]

:13]
[30:

Sat Jun 13 14:49:02 2020 So, that can't be it, can it?  Let's just
eyeball the inbound and outbound logic again before trying to build..

INBOUND
 - packet arrives at itc_pkt_cb
 - Say it's a standard packet
 - Say it's not a local packet, and it doesn't signal overrun or error
 - We set bool mfm = byte0&PKT_HDR_BITMASK_MFM, which is bit 2
 - We choose stats buffer TRAFFIC_MFM or TRAFFIC_SERVICE based on that
 - If !mfm, we check byte1&PKT_HDR_BYTE1_BITMASK_BULK for
   /dev/itc/bulk, else /dev/itc/flash.  (Management acknowledges its
   regret that so-called 'flash' traffic now actually travels at bulk
   rate, by solemnly dedicating this memorial parenthetical note.)
 - If mfm and XITC (byte1 mask 0xe0) !=
   PKT_HDR_BYTE1_XITC_VALUE_KITC(0x0<<5), that means userspace, so we
   deliver if we have MFZID compatibility established.

 - Otherwise it's KITC traffic, which goes to recvKITCPacket, which
   seems kind of updated okay.[31:

Sat Jun 13 15:17:37 2020 The packet tracing stuff 'seems' not to care
specifically about the pkthdr bits, leaving that up to the packet
trace system user.  I think, anyway..

[32:

Sat Jun 13 15:19:00 2020

OUTBOUND:

 - All outbound-from-userspace packets go to writePacketHelper

 - Which is still saying 'bool bulkRate' for something that should now
   be called 'bool serviceRate' or something.

 - The check of minors (/dev/itc/{bulk|flash|ET..WT}) for routing is
   still right.

 - We now clear bulkRate on PKT_MINOR_FLASH (moment of silence) where
   we didn't before.

 - We go to routeOutboundStandardPacket.  We got rid of some constants
   for some names, but everything works the same there.  We map dirs
   to pru minors.[38: Sat Jun 13 15:54:55 2020

 - We then select mBulkOB or mPriorityOB based on bulkRate.  We either
   block or error out if there's no room, depending on how userspace
   opened whatever minor we came in on.  (It will be error out for all
   mfmt2 stuff.)

 - Otherwise we kfifo_from_user to the appropriate OB, and we're done.

:38]

 - Then we stick the packet in the mPriorityOB kfifo no matter
  what???[37:  Sat Jun 13 15:53:30 2020 Yes, when the packet arrives
  from the KITC system, which is the only user of
  trySendMFMRoutedKernelPacket.

:37]
   What the heck is this about:

itcpkt.c:1601:   ipb = &prudevstate->mPriorityOB;  /*priority dispatch only at present*/

  ??

[33:

Sat Jun 13 15:40:05 2020 Well so we're in (the newly-renamed)
trySendMFMRoutedKernelPacket, so isn't that the answer?  All MFM is
priority?  How did I miss/forget that in the walkthrough?[34:

Sat Jun 13 15:42:39 2020 Well, trySendMFMRoutedKernelPacket is called
from sendPacketHandler.. but that's static in itcmfm.c so we suspect
only mfm packets can get to it..[35:

Sat Jun 13 15:43:59 2020 ..And trySendMFMRoutedKernelPacket is called
from nowhere else.. so okay.  Maybe we could assert our new MFM bit,
just to be sure?[36:

Sat Jun 13 15:51:58 2020 OK, didn't assert, but added:

  /*only mfm packets allowed via this route*/
  if (!(pkt[0] & PKT_HDR_BITMASK_MFM)) return -ENXIO; /*never the error code you want*/

and changed to this:

  ipb = &prudevstate->mPriorityOB;  /*MFM packets are always priority dispatch*/

So.  Where were we?

:36]

:35]

:34]

:33]

:32]

:31]

:30]
[39:

Sat Jun 13 15:59:04 2020 Well the eyeball walkthrough looks plausible
enough.  Let's build.

[40:

Sat Jun 13 16:00:28 2020 Urgh, just one typoe:

  return ph->pktbuf[1] & 0xPKT_HDR_BYTE1_BITMASK_XITC_SN;

otherwise it builds.

Now.  We also need to change mfmt2 and cdm.pl.  But we have less than
an hour here before it's time for the evening.

Let's look at cdm.pl now and save mfmt2 for the overnight run.
[41:

Sat Jun 13 16:32:48 2020 cdm.pl seems to be fixed up.  Let's try
installing the LKM..

:41]
:40]

:39]
[42:

Sun Jun 14 03:17:39 2020 OK where are we?  Updating mfmt2 for the
packet format changes.[43:

Sun Jun 14 03:34:21 2020 Converting in T2PacketBuffer.h.  What say we
also take this opportunity to move the yoink bit from 4.7 to 4.3, so
there's four contiguous reserved bits in byte[4]?  And let's sneak
that into to T2-PHF-19, even though it's already pushed?  Vs going to
T2-PHF-210?

Fog it let's make T2-PHF-210.[44:

Sun Jun 14 03:51:16 2020 Made T2-PHF-210.  Put yoink bit at 4.7 and
radius at 4.6 - 4.4, leaving 4.3 - 4.0 undefined.  Noting that if we
had shipped RADIUS-1 instead of RADIUS, we could have fit it in two
bits instead of three.  Did we think that was too tricky?  Or did we
imagine there might be a radius 0 event going intertile??  Or did we
want to 'save room for the future'???

OK well of course now that I'm thinking about it I guess I have to go
check the old monster notes file see what I can find..
In T2-12/pru/itcio/notes/202002010352-notes.txt..

[45:

Sun Jun 14 03:56:51 2020 Well right there at :272: from this past
March I was thinking of a two bit radius-1:

       MFM ITC SYN
      +---+---+---+---+---+---+---+---+
      | 1 | 0 | 0 |EC1|EC0|RV1|RD1|RD0|
      +---+---+---+---+---+---+---+---+

    EC 0..3  RD 0..3
    EC == 0 Non-EventWindow command (RV1,RD1,RD0 unused)
    EC == 1 EventWindow lock req + RD radius-1 + u8:YLSeqno + u8:myewslotno + s8:atx + s8:aty
    EC == 2 EventWindow lock ack + RD radius-1 + u8:YLSeqno + u8:yourewslotno
    EC == 3 EventWindow lock rej + RD radius-1 + u8:YLSeqno + u8:yourewslotno

[46:

Sun Jun 14 04:00:13 2020 (And noting in passing that :487: of that
file is where per-ITC origins for RING coords comes up -- which is one
thing we think needs to be rechecked once the current clean-up
settles.)

:46]

:45]
:44]

:43]

:42]
[47:

Sun Jun 14 04:08:55 2020 Well, by :713: in that file we're just
blithely saying 'radius:u3'[48:

Sun Jun 14 04:10:46 2020 And :808: sticks mRadius in the packet
directly:

          u8 yoinkRad = ((yoinkVal&0x1)<<7)|mRadius;
          pb.Printf("%c",yoinkRad);

and that's the last hit for 'radius' in that file.[49:

Sun Jun 14 04:12:39 2020 Let's go with (radius-1):u2.  What you cannot
say, you cannot command.

"What good is a phone call if you are unable to speak?"

[50:

Sun Jun 14 04:37:28 2020 And in this context note we're also exposed
on s8:ctrx and ctry: Recheck their inbound handling.

:50]
:49]

:48]

:47]
[51:

Sun Jun 14 04:39:54 2020 OK done with T2PacketBuffer.h.  Where are the
outbound packets developed?
[52:

Sun Jun 14 04:41:01 2020 Some of it at least is in T2ITC.cpp.  We
should really rewrite all these hex constants though -- if not to
avoid version skew bugs, then just to improve greppability.[53:

Sun Jun 14 04:50:04 2020 Well, it appears I can move the LKM PKT_HDR
enum values from itcpkt.h -- which is not set up for userspace use --
to itcpktevent.h -- which is already #included from userspace --
without ill effect on the LKM side..  Let's try switching to those
names.

[54:

Sun Jun 14 06:04:05 2020 OK, well that took over an hour but I did
kill a tremendous number of '0x' instances in the mfmt2 code.  Started
making use of __builtin_ctz to derive shift distance _POS constants
from the associated _BITMASK constants -- I think nice.

I did *not* go so far as to define _POS constants for masks that are
currently right-justified in their byte, though.

:54]

:53]

:52]
:51]
[55:

Sun Jun 14 06:15:09 2020 Well, fading here a bit -- after only three
hours, say, hmm -- but we've had a pretty good cleaning up run.  Still
much much broken stuff in mfmt2 but the 0x-elimination damage seems to
be mostly handled.

:55]
[56:

Sun Jun 14 06:22:26 2020 Taking a break with mfmt2 still not
building.  When we pick up, walk through scenarios involving
CircuitInfos and just start cleaning them the fog up.
[57:

Sun Jun 14 15:56:34 2020 Well the business of the day ate up a pretty
big chunk.  But we've got a couple hours here; let's start eyeballing
anyway.

For starters, let's walk the active side event window process again.

 - EWInitiator onTimeout goes to tile.maybeInitiateEW

 - which picks a non-cache ctr and goes to considerSiteForEW(ctr)

   = which returns 0 (meaning don't use this ctr) if (1) the site is
     already hogged by some EW, or (2) the radius of the center atom
     is 0, meaning it's Empty.

 - Once considerSiteForEW(ctr) returns a non-zero radius,
   maybeInitiateEW ends by calling tryAcquireEW(ctr, radius, true)

 - T2Tile::tryAcquireEW attempts to allocate an EW, and the event
   attempt fails if it cannot.  If it CAN, we then have a 'live'
   allocated EW whose lifetime has to be tracked and managed.

 - With the ew, T2Tile::tryAcquireEW goes to
   ew->tryInitiateActiveEvent(ctr, radius).  If that returns true, the
   ew remains in use and T2Tile::tryAcquireEW returns true, otherwise
   the ew is immediately deallocated.

[58:

Sun Jun 14 16:15:06 2020 Now T2EventWindow::tryInitiateActiveEvent
returns false in these cases:

 - checkSiteAvailability returns false

 - checkCircuitAvailability returns false

 - needsAnyLocks() returns true but trySendLockRequests returns false

   And there's an ugliness in that -- if trySendLockRequests returns
   false, we return false without unhogging the sites, so some
   mSiteOwners will still be pointing at this EW.

[59:

Sun Jun 14 16:18:55 2020 So that seems like a bug -- at least if
trySendLockRequests might actually return false.  Which happens if and
only if T2ITC::trySendPacket returns false.  Which we hope will be
rare but fear it won't be.

So, I think, although it's risky to go down this road, that:

 - We should add 'bool mHasHoggedSites' to every ew, and have
   'finalizeEW' automatically unhog sites if need be.  (Actually, doh,
   it appears we already have 'bool mIsHoggingSites;' but finalizeEW
   is not examining it.)

 - Similarly, we should add 'bool mIsAllocated' and have finalizeEW
   check (and reset) that also.  Right now we're apparently using
   'mRadius != 0' to mean something like 'isAllocated' but I think
   that's asking for trouble.

Now, what _can't_ finalizeEW do?  Well, how does the allocation
process work?  And isn't the allocation process different for active
vs passive EWs, and isn't that bad?

Active EWs: Raw allocation is via T2Tile::allocEW, final free by
T2Tile::freeEW.  allocEW modifies the EWSet T2Tile::mFree, but doesn't
touch the EW.  freeEW modifies whatever set the EW is currently in, if
any, and also modifies T2Tile::mFree.

Now, at the moment T2ITC is doing a whole different thing, using an
array of ptrs:

    T2EventWindow * mPassiveEWs[CIRCUIT_COUNT];

allocated in the ctor and freed in the dtor.

It would be nicer if we could consolidate ownership-of-set-of-EWs
under a common framework; the current challenge is that EWSet
currently provides random allocation but not targeted allocation.

How about we extend EWSet to support both mechanisms?  And then have
it trace both allocated and free EWs, not just free ones?[60:

Sun Jun 14 16:41:47 2020 Now, one issue with that is:

    ~EWSet() ;  // EWSet DOES NOT own its EWs

but given that both T2Tile and the T2ITCs now allocate the EWs on the
heap, I'm not sure why we don't let the EWSet own the EWs.[61:

Sun Jun 14 16:44:03 2020 So the idea would be:

 - Say EWSet does own its EWLinks

 - Add 'std::vector<EWLinks*> mMembersByIdx;' as the canonical
   ownership pointer

 - Change 'std::vector<EWLinks*> mMembers;' to like

   'std::vector<u32> mFreeIndices;'

 - Add a EWSet::takeOwnershipOf(EWLinks*) to add EWLinks to
   mMembersByIdx, setting the ewlinks idx in the process.  Newly owned
   EWLinks* are always free

 - Have the dtor destroy the contents of mMembersByIdx


:61]

:60]

:59]

:58]

:57]

:56]
[62:

Sun Jun 14 23:28:19 2020 OK, after the evening.[63:

Sun Jun 14 23:56:57 2020 Grr, OK, after the late evening Twitter+ time
sink.

As I wanted to start to say: I've been reorganizing the ownership of
2EventWindows.  What really are the needs/wants for that container?

 - Track free vs in-use EWs

 - For active side, O(1) allocation of arbitrary free EWs

 - For passive side, O(1) allocation of a specific EW identified by cn

 - For both sides, O(1) deallocation of in-use EWs

Is there any reason for more than that?  In particular, do we really
care what order we allocate active EWs?  Right now the EWSet does
extra work to allocate EWs randomly, but what does that really
accomplish?  Wouldn't it be at least as good to allocate them in a
FIFO order.
[65:

Mon Jun 15 00:05:26 2020 Which leads to a related question: Are we
worried at all about aliasing between multiple uses of the same EW?
We really can't be worried about that, can we?  Because we're saying
'it can't happen' as long as the T2ITC connection remains open,
because the far side will see everything we send them, in the order we
send it, with the only proviso being they will see all that at some
variably later time than we sent it.

I keep wanting to worry about things like aliasing CNs across uses,
and keep wanting to add generation numbers or random tags to help
detect them, but once I actually push through and implement stuff I
never actually use them.

We're empowered to _not_ add robustness at this level as long as we're
ready to reliably die-and-renew the channel when any inconsistency is
detected.  Rather than, say, failing out of top level and restarting
the whole engine -- as we are currently doing..

But we do have to have some chance of discovering we are in an
inconsistent state, and that means we do need some degree of
redundancy somewhere.

I guess one point is we already do have that just with the existing
CNs, when considered in combination with the XITC circuit signals.  At
any given moment, for a given CN, only a subset of circuit signals
actually make sense.  And we _are_ already detecting inconsistencies
of that kind -- we're just failing right out of the engine when we do.

So this is 'quacks-like-a-duck' consistency, and when we discover it's
violated, we should

 - Assume it's due to packet loss(es) somewhere in the network

 - Abort all EWs implicated in the detected failure

 - As part of aborting those EWs, any involved ITCs should be aborted
   or closed as well, being free to reopen, but only after they have
   synced up from lower level.

:65]
[64:

Sun Jun 14 23:59:01 2020 Note there's current four bits left at the
end of the RING packet.  What if we used them for an 'allocation
counter'

:64]


:63]

:62]
[66:

Mon Jun 15 00:20:40 2020 And if we're actually serious getting this
stuff to actually work, which we REALLY OUGHT TO FOGGEN FINALLY BE
READY TO BE BY NOW, we should START by writing and testing the
failure/abort/cleanup logic FIRST, before focusing on the failure-free
'default' case like we have been doing.

:66]
[67:

Mon Jun 15 00:22:21 2020 So.

Goal: Arbitrarily abortable event windows.

Properties:

 - Have (mainly) a single ditching point / abort sequence that anybody
   can call at any stage of an EW lifecycle, and it will 'Do The Right
   Thing' as far as cleanly blowing up whatever needs to be blown up
   as depends on the circumstances at hand.

 - To do that, EWs will maintain enough state that that single
   ditching point will be able to tell what it needs to do.

 - How about 'void T2EventWindow::fail(const char * file, int line)'
   as the ditching point?  But what happens to flow of control then?
   Do we actually FAIL() as well?  (Note we have to be careful about
   FAIL-ing in guts of stuff now, because we've written a few
   non-trivial dtors, grr.  That's a bomb just waiting to explode.)

[68:

Mon Jun 15 00:31:21 2020 I wonder, could we write a new platform, like
'platform-tile-cpp' or something, that would implement FAIL and
unwind_protect via actual C++ exceptions, and defuse that bomb before
it gets a chance to explode?

This is a pretty important design issue, really.  And it's only Monday
on a non-update week.

Just think about that for a few minutes.

:68]

:67]
[69:

Mon Jun 15 01:41:38 2020 Well, more non-mission work just ate almost
an hour.  Grr.  But platform-tile-cpp?[70:

Mon Jun 15 01:48:56 2020 Well, looked at it briefly, and looked at
stack overflow briefly, and quickly became convinced that
'platform-tile-throw' or 'platform-tile-exception' is a project for
another day: As things are currently set up, FailPlatformSpecific.h
exports a lot of very specific stuff that, at the very least, would
all have to be reconsidered.

It might really be possible to do, but it would be a big new start on
design and we Do Not Have the time for that now.

Instead of trying to be able to throw more readily, we should be
thinking of how to keep our stack shallower -- doing less per state
machine transition -- so that the route to bailing out after aborting
an EW is short.

:70]

:69]
[71:

Mon Jun 15 08:37:40 2020 OK, got it building last night, now working
forward from the front.

:71]
[72:

Mon Jun 15 10:27:36 2020 Worked through some stuff, now trying to
clean up the relationship between T2ITC and Circuit.  Was trying to
have Circuit::setITC(T2ITC&) and Circuit::clearITC() take
responsibility for linking and unlinking the circuit and the T2ITC,
but that runs into trouble distinguishing active from passive ITCs,
which can both be associated with a T2ITC but must not be confused
with each other.

Which circles us back around to the EWManager idea.. does it?  What
about having T2EventWindow be able to say whether it's active or
passive, and just having T2ITC treat (un)registering the circuit
differently depending on that.  Is that so bad?  The active status of
an EW will never change, right?  We could/should pass it as a ctor
arg, no?  If we're still staying away from T2EW subclasses, which I
think we are.[73:

Mon Jun 15 10:40:24 2020 Well thinking about T2EW subclasses again.  I
don't see the real argument against them, and I do see a lot of
clutter in T2EW that is only relevant to one or the other:

 - bool executeEvent() : only active side relevant

 - bool isInActiveState() : poor and misleading design, since any
   given EW should always return the same value.

 - getPassiveCircuitIfAny() : only passive side, and also stupid since
   passive EWs should always have one (and only one) Circuit, to their
   particular T2ITC.

and there's more like that..  While on the other hand, we've
apparently accepted that we're allocating all the T2EWs on the heap,
so having them be different sizes isn't a problem.  (We could even
allocate them in data member arrays, even with subclasses -- except
for ctor argument setup problems.)

Well, this period is all about clean up, so let's take a look at
T2ActiveEventWindow and T2PassiveEventWindow..

:73]

:72]
[74:

Mon Jun 15 14:07:56 2020 Well, getting closer to having
T2ActiveEventWindow/T2PassiveEventWindow actually build.  It really
does split up a lot of the complexity.  One remaining ugliness is that
I was trying to get away with one T2EventWindow-level state machine,
but that means all the state machine callbacks pass a T2EventWindow&
which has to be downcast and asserted non-null before detailed use,
which is, like I said, ugly.

:74]
[75:

Mon Jun 15 14:16:44 2020 Well, I'm going cross-eyed here so I'm going
to stop for a bit, probably through the evening.  Current status is
we're close to building successfully, but with tons of battle damage
all over the place.. and I probably want to go back and split up or
template-out the state machine so that the T2EWOps will know which
subclass of T2EW they are dispatching to.
[76:

Mon Jun 15 16:29:28 2020 Well, took a little nap and now thinking I
could probably just jigger the existing macros to slam an ##Active or
##Passive into the arg names depending on the ACT arg to the XX macro.

[77:

Mon Jun 15 17:00:58 2020 Breaking for some evening.  The
revised-but-still-merged EW state tables are getting close to
building, but

 - Custom handler declarations have to be revisited

 - Probably other stuff TBD.

:77]

:76]

:75]
[78:

Mon Jun 15 19:35:01 2020 Back for a bit.

:78]
[79:

Mon Jun 15 20:18:52 2020 OK, so now we're down to T2ITC circuit and ew
functions that we have to ditch, modify, or figure out how to
implement as is.

Specifically, right now, I want to know who needs
T2ITC::allocateActiveCircuitIfNeeded ?[80:

Mon Jun 15 20:20:14 2020 It's (no longer being) called from
T2EventWindow::checkCircuitAvailability to see if circuits are
available for an active EW that's being set up.

And that answers the question at least in part: We no longer need to
checkCitcuitAvailability because we have the capacity to use any
active EW on any ITC.  We still need to register with the T2ITC
somehow (yet to be re-figured-out), but we don't have to worry about
failing.

So we should ditch T2EventWindow::checkCircuitAvailability, and its
support routines, and finally feel like we're getting a little payoff
for this giant upheaval.
[81:

Mon Jun 15 20:32:46 2020 OK, now we're running again, and are back to
here:

    (gdb) bt
    #0  MFMLongJmpHere (buffer=0xbefff6e0, toThrow=1)
        at src/FailPlatformSpecific.cpp:48
    #1  0x004708fa in MFM::T2ActiveEventWindow::needsAnyLocks (this=0x5d28e8)
        at src/T2EventWindow.cpp:197
    #2  0x00472a30 in MFM::T2ActiveEventWindow::tryInitiateActiveEvent (
        this=0x5d28e8, center=..., radius=4) at src/T2EventWindow.cpp:667
    #3  0x00467766 in MFM::T2Tile::tryAcquireEW (
 ..

Pick up there in the overnight.[82:

Mon Jun 15 23:23:05 2020 Reimplementing T2aEW::needsAnyLocks, which
counts on checkSiteAvailabilityForActive to have set up the circuits
implied by the proposed event center and radius.[83:

Mon Jun 15 23:25:57 2020 And I guess we have to revisit checkSiteAvail
first, because needsAnyLocks seems to be relying on CircuitNums..

:83]

:82]

:81]
:80]


:79]
[84:

Mon Jun 15 23:27:16 2020 checkSiteAvailabilityForActive uses
registerWithITCIfNeeded to set up Circuits, plus a variety of visible
and cache predicates to decide if a site is available/live.

T2aEW::registerWithITCIfNeeded uses Circuit::allocate(itc) and
T2ITC::registerActiveCircuitRaw(Circuit&) to set up the relationship.
Did CircuitNum become involved via the latter?[85:

Mon Jun 15 23:31:43 2020 Well, if it _did_, it doesn't now.  What
T2ITC does now is stick a pointer to the Circuit into
T2ITC::mActiveEWCircuits[sn], and that's about it.  And we think it
would be doing that _because_ a lock is needed.[86:

Mon Jun 15 23:37:16 2020 And we note T2aEW::registerWithITCIfNeeded is
making that call AS PART OF THE Circuit allocation sequence.  So as
long as that remains established, we can call Circuit::isAllocated()
on the Circuit to know if we need/want/are going for/have a lock?[87:

Mon Jun 15 23:40:41 2020 Buuut it seemed like there _were_ two cases,
and ITC registration does _not_ necessarily imply lock needed: We said
the EWs had to register with in-scope ITCs even if the ITCs were SHUT,
because the ITCs could begin an opening sequence and they need to know
and wait if any EWs are currently depending on it being closed.

So again, if Circuit::isAllocated() does not imply 'lock needed', what
DOES imply it?[88:

Mon Jun 15 23:44:03 2020 T2ITC::isVisibleUsable is derived from the
T2ITC state table, ditto isCacheUsable.  [89:

Mon Jun 15 23:49:04 2020 OK, so it's checkSITEAvail -- NOT
checkCIRCUITAvail -- that registers EWs with ITCs, using
Circuit::allocate(T2ITC&) & T2ITC::registerActiveCircuitRaw(Circuit&)
to do so.

Once the EW is registered with a T2ITC, then I guess isCacheUsable
means we need a lock?  That's really supposed to be it?[90:

Tue Jun 16 00:30:58 2020 So the deeper effect of having the split
CircuitInfo/Circuit distinction was that CI associated an EW and an
ITC without implying that a lock was required.  Then, in addition,
having a Circuit allocated on the ITC meant that a lock was required.

Now, we have this CircuitState abstraction that, I believe, we are not
yet doing anything with.  Or more properly, it's currently got fantasy
entries that appear to largely duplicate the EW state machine states,
but on a per Circuit basis.  Perhaps we should redo
ALL_CIRCUIT_STATES_MACRO to work in terms of these re-identified
issues such as registered, need a lock, have a lock, and so forth?

I think maybe.
[91:

Tue Jun 16 00:38:31 2020 You know, the problem with these foggen state
tables is they don't representing nesting and other inter-state
relationships.  They're just a foggen enum with attitude.  And if you
need other state -- pointers for examples -- to have certain
relationships with the state and with each other, the state machine
state, by itself doesn't really help you with that either.  You have
to keep adding args to XX to expand the table.  And how is that really
better than just writing predicates as class methods on the underlying
state?
[92:

Tue Jun 16 00:44:58 2020 Circuit states:

 - UNREGISTERED  no ITC involved.
   = Circuit::isRegistered() -> mITC != 0

 - REGISTERED    to a particular ITC
   = Circuit::isRegistered()
   = Circuit::isLockNeeded() -> isReg + mITC->isCacheUsable

 - REQUESTED
   = Circuit::isLockNeeded()
   = Circuit::isLockRequested() -> isLNeeded + mYoinkVal >= 0
   = Circuit::isLockHeld()

 - ACQUIRED

 - HELD

:92]
:91]
:90]

:89]

:88]

:87]

:86]

:85]

:84]
[93:

Tue Jun 16 04:04:50 2020 OK, taking another break.  Have just been
working forward from the front and cleaning up.  The various Circuit
predicates we made feel pretty good and pretty clear.

Current issue is T2ITC::registerActiveCircuitRaw is blowing up because
mActiveEWCircuits[sn] is already set.  We think that's because it was
correctly set up earlier, and we want to revise eliminate this code
now, but we're not sure.[94:

Tue Jun 16 04:10:35 2020 Yeah, Circuit::bindCircuit was already doing
the registerACRaw.  Now we're blowing up on Circuit::isLockHeld()
being unimplemented, and we're not yet sure how we want to implement
it.
[95:

Tue Jun 16 04:50:34 2020 We used to have a 'bool mLockAcquired' in
CircuitInfo, but that seems to have disappeared in the latest
conversion.  I guess the idea was it would go into CircuitState
instead?  But we're not sure how much we like CircuitState..[96:

Tue Jun 16 12:03:24 2020 OK so how do we do this?  Add a 'lock held'
XX arg for ALL_CIRCUIT_STATES_MACRO?  Which would be true of ANSWERED
and TALKED ?  But then you'd think there should be a 'bound' XX arg as
well, that would be true of BOUND, RUNG, ANSWERED, TALKED, and who
knows about DECLINED and DROPPED.

Again it really comes down to are we actually going to use our
CircuitState or not?  In earlier state table macrofests, we tried to
figure out ways to include arbitrary state variables with different
states -- like a T2ITC* or something -- in the tables, but we never
got anything we could stand.  So there was always a split between the
state represented by the state variable itself, and all the other
state that sat in data members or wherever, that was supposed to
remain in sync with the state variable.

And so here we are again.
[97:

Tue Jun 16 12:47:24 2020 Well sigh let's try putting in XX args and
see how much we hate it.  'ITC/ITC bound and 'LKH/Lock Held for now..

:97]

:96]

:95]

:94]

:93]
[98:

Tue Jun 16 13:16:10 2020 OK, now we're back at T2EW::finalizeEW, which
is currently united at T2EW rather than down at T2aEW/T2pEW.  And we
don't know what we want it to do, because unlike my previous
admonition to myself, I did not in fact start with the abort sequence
and how to tear down and clean up stuff.

Do we want to try to take a cut at that now?

:98]
[99:

Tue Jun 16 13:32:43 2020 Well, we're back at hidden events running.
Time for the loopback cable I guess.[100:

Tue Jun 16 13:34:10 2020 Ah okay there's the next esplosion.  Now at

    554	  s8 T2ITC::getYoinkVal(CircuitNum cn, bool forActive) const {
    555	    FAIL(INCOMPLETE_CODE);

(via

    #2  0x004727e2 in MFM::T2ActiveEventWindow::trySendLockRequests (
        this=0x5d7420) at src/T2EventWindow.cpp:627
    #3  0x00472a74 in MFM::T2ActiveEventWindow::tryInitiateActiveEvent (
        this=0x5d7420, center=..., radius=4) at src/T2EventWindow.cpp:669
    #4  0x0046792e in MFM::T2Tile::tryAcquireEW (
  ..
)
[101:

Tue Jun 16 13:43:09 2020 But it's really T2aEW::trySendLockRequests
that wants rewritten.[102:

Tue Jun 16 13:45:37 2020 ..and it looks like trySendLockRequests would
be the place to pick the yoink value, no?

:102]

:101]

:100]

:99]
[103:

Tue Jun 16 14:48:49 2020 Past an advance cooking round to get the
meat into the marinade for tomorrow (for our version of Rodriguez'
Puerco Pibil :).

:103][104:

Tue Jun 16 14:49:53 2020 Now blowing up in handleRingPacket,
unsurprisingly enough.

:104]
[105:

Tue Jun 16 21:56:15 2020 Now blowing up in handleAnswerPacket of
course.  Pick up there.

:105]
[106:

Tue Jun 16 23:06:34 2020 Now on to T2aEW::handleACK.

:106]
[107:

Tue Jun 16 23:28:11 2020 Now T2aEW::trySendCacheUpdatePacket

:107]
[108:

Tue Jun 16 23:33:30 2020 Now T2ITC::hangUpPassiveEW.  We're very late
in an (uncontested) intertile event now!

:108]
[109:

Wed Jun 17 01:15:49 2020 OK, now T2ITC::handleHangUpPacket, after a
long diversion to expand the tracing facility to capture Circuit state
changes, as a subcase of EW tracing..  And then to get more rigorous
about updating our new circuit state vars so that the assertions hold.

:109]
[110:

Wed Jun 17 02:06:56 2020 OK, enough for now.  We got back to
uncontested loopback events 'working' like they were before --
plausible, especially when the bein was heading straight for the ITC,
but liable to see obstacles and change directions in places that
really shouldn't have obstacles.  And occasionally to duplicate while
in transit, until enough clone beins were around that they raced
against each other, at which point we hit INCOMPLETE_CODE in
T2EW::passiveWinsYoinkRace:

    (gdb) l
    230
    231
    232	  bool T2EventWindow::passiveWinsYoinkRace(const T2EventWindow & ew) const {
    233	    MFM_API_ASSERT_ARG(ew.isActiveEW());     // ew is our side active initiation
    234	    MFM_API_ASSERT_ARG(!this->isActiveEW()); // *this is passive ew for them
    235	    FAIL(INCOMPLETE_CODE);
    236	    return false;
    237	#if 0
    238	    Circuit & ci = mCircuits[0]; // Passive CircuitInfo always in [0]
    239	    T2ITC & itc = ci.getITC();
    (gdb) bt
    #0  MFMLongJmpHere (buffer=0xbefff6d0, toThrow=1)
        at src/FailPlatformSpecific.cpp:48
    #1  0x00471962 in MFM::T2EventWindow::passiveWinsYoinkRace (this=0x5697c8,
        ew=...) at src/T2EventWindow.cpp:235
    #2  0x00471df8 in MFM::T2EventWindow::resolveRacesFromPassive (
        this=0x5697c8, conflicts=...) at src/T2EventWindow.cpp:296
    #3  0x00472296 in MFM::T2PassiveEventWindow::checkSiteAvailabilityForPassive
        (this=0x5697c8) at src/T2EventWindow.cpp:362
    #4  0x004612ba in MFM::T2ITC::handleRingPacket (
        this=0x4d9dd0 <MFM::T2Tile::get()::THE_INSTANCE+3280>, pb=...)
        at src/T2ITC.cpp:205
    #5  0x00460c8c in MFM::T2ITC::handleCircuitPacket (
        this=0x4d9dd0 <MFM::T2Tile::get()::THE_INSTANCE+3280>, pb=...)
        at src/T2ITC.cpp:124
    #6  0x004627de in MFM::T2ITC::tryHandlePacket (
        this=0x4d9dd0 <MFM::T2Tile::get()::THE_INSTANCE+3280>, dispatch=true)
        at src/T2ITC.cpp:371
    #7  0x00460a8e in MFM::T2ITC::pollPackets (
        this=0x4d9dd0 <MFM::T2Tile::get()::THE_INSTANCE+3280>, dispatch=true)
        at src/T2ITC.cpp:104
    #8  0x0046057e in MFM::T2ITCPacketPoller::onTimeout (
        this=0x50cbf8 <MFM::T2Tile::get()::THE_INSTANCE+211704>, srcTq=...)
        at src/T2ITC.cpp:28
    #9  0x00468b0a in MFM::T2Tile::main (
        this=0x4d9100 <MFM::T2Tile::get()::THE_INSTANCE>) at src/T2Tile.cpp:599
    #10 0x0044d04a in MFM::MainDispatch (argc=7, argv=0xbefffc94)
        at src/main.cpp:78
    #11 0x0044d22c in main (argc=7, argv=0xbefffc94) at src/main.cpp:106
    (gdb)

[111:

Wed Jun 17 02:25:02 2020 When we start up again,

TODO:
[118: Thu Jun 18 01:36:31 2020
DONE :118] - Review the center mapping and ITC rectangles

[120: Well, added '-mcsv' and '-mitc' to see stuff.  For now call it
DONE :120] - Figure out a way to debug-log ground truth on what the mapping
   should be.

[119:
DONE :119] - Debug-log position and info whenever the bein decides to change
   direction

 - Write a routine to debug-log dump all the in-use active EWs and all
   the in-use passive EWs

:111]

:110]
[112:

Wed Jun 17 10:20:57 2020 OK, I've been working through

    t2@beaglebone:~/MFM$ ./bin/Weaver /tmp/t2trace17.dat
    11: MSG: WP 0
    0/ /tmp/t2trace17.dat

for the last few minutes and I'm pretty sure we
have found an issue.  I'll annotate a segment here:

    16.088 0/a16-IDLE -> AINIT
    16.088 0/a16-AINIT a@(37,31)+4

Event at (37,31) begins in a16.

    16.088 0/a16-AINIT SE CS_UNUSED -> CS_BOUND

Although ITC SE is currently SHUT, if it were to begin to open, it
would have to wait for a16, because (37,31) is relevant (visible?)
there, so an a16<->iSE circuit is bound.

    16.088 0/lDBG EW16-AC/AINIT sites available
    16.088 0/lDBG EW16-AC/AINIT OWNING (37,31)+4
    16.088 0/a16-AINIT -> ABEHAVE
    16.088 0/lDBG EW16-AC/ABEHAVE (37,31)BEIN ngb 6 live 1

Debug log from our bein: It's heading for (relative) site 6 (i.e., SW,
which is (36,32) at the moment), and that site is live.

    16.089 0/lDBG EW16-AC/ABEHAVE FREEING (37,31)+4
    16.089 0/a16-ABEHAVE -> IDLE

a16 event is done.  (There's now trace code to show the circuit being
unbound, but that wasn't in this trace, so we have to just take it on
faith.)

    16.096 0/a12-IDLE -> AINIT
    16.096 0/a12-AINIT a@(36,32)+4
    16.096 0/a12-AINIT SE CS_UNUSED -> CS_BOUND
    16.096 0/lDBG EW12-AC/AINIT sites available
    16.096 0/lDBG EW12-AC/AINIT OWNING (36,32)+4
    16.097 0/a12-AINIT -> ABEHAVE
    16.098 0/lDBG EW12-AC/ABEHAVE (36,32)BEIN ngb 6 live 1

Again the bein goes SW, now from (36,32) to (35,33).

    16.098 0/lDBG EW12-AC/ABEHAVE FREEING (36,32)+4
    16.098 0/a12-ABEHAVE -> IDLE
    16.124 0/a02-IDLE -> AINIT
    16.124 0/a02-AINIT a@(35,33)+4
    16.124 0/a02-AINIT SE CS_UNUSED -> CS_BOUND
    16.124 0/a02-AINIT SW CS_UNUSED -> CS_BOUND

Exciting!  For (35,33)+4 circuits through both ITC_SE and ITC_SW must
be bound.  (And ITC_SW is OPEN!)

    16.124 0/lDBG EW02-AC/AINIT sites available
    16.124 0/lDBG EW02-AC/AINIT OWNING (35,33)+4
    16.125 0/lDBG EW02-AC/AINIT RING abs(35,33) usrel(35,1) yoink=1

a02 rings SW, claiming the desired event center is at (35,1) relative
to the SW ITC.

    16.135 0/iSW:OPEN >SW:RING#2(35,1)+4o +5
    16.135 0/a02-AINIT SW CS_BOUND -> CS_RUNG
    16.135 0/a02-AINIT -> AWLOCKS

The ring packet ships out SW!
The SW circuit state tracks the action!
a02 shifts to waiting for lock acknowledgments!

    16.138 0/iNE:OPEN <NE:RING#2(35,1)+4o +5

Via loopback cable, the ring packet arrives NE.

    16.138 0/lDBG ITC/NE:OPEN: HRP abs(59,1) themrel(35,1) yoink=1

To ITC-NE, relative (35,1) maps to tile coord (59,1) -- which I
thought was clearly wrong, when I started this annotation, because the
tile is only 56 sites wide even if you include the cache.

But now I'm not sure that it is wrong.  A radius 4 event centered on
(59,1) would reach down to (55,1), and that is in cache.

So we're no longer sure we're going to see a bug here, but let's push
on through this event.

    16.149 0/pNE02-PINIT -> PINIT

Because the ring packet arrived on circuit 2, NE fires up passive EW02
to track the action.

    16.149 0/pNE02-PINIT p@(59,1)+4

Its center is set all the way off-tile.

    16.149 0/pNE02-PINIT NE CS_BOUND -> CS_RUNG

The dedicated passive circuit (which never goes all the way back to
CS_UNUSED) updates.

    16.149 0/pNE02-PINIT -> PRESOLVE

p02 goes to resolve races.

    16.149 0/pNE02-PRESOLVE -> PWCACHE

But there are none.  It advances to waiting for cache updates.

    16.152 0/iNE:OPEN >NE:ANSWER#2 +2

And answers the ring packet: Lock granted!

    16.152 0/pNE02-PWCACHE NE CS_RUNG -> CS_ANSWERED

The passive circuit tracks.

    16.158 0/iSW:OPEN <SW:ANSWER#2 +2

The answer arrives back SW.

    16.158 0/lDBG ITC/SW:OPEN: Enter HAP
    16.158 0/a02-AWLOCKS SW CS_RUNG -> CS_ANSWERED

a02's SW circuit tracks the progress.

    16.158 0/lDBG ITC/SW:OPEN EW02-AC/AWLOCKS HAP

ITC/SW handles the answer packet

    16.158 0/lDBG EW02-AC/AWLOCKS hACK ITC/SW:OPEN

Dishing it to a02.

    16.158 0/a02-AWLOCKS -> ABEHAVE

Which is now ready to rumble.

    16.159 0/lDBG EW02-AC/ABEHAVE (35,33)BEIN ngb 6 live 1

The bein sees dir 6 is clear ahead (and advances to (34,34), though we
just have to know that at this point).

    16.159 0/a02-ABEHAVE -> ASCACHE
    16.170 0/iSW:OPEN >SW:TALK#2 +29
    16.170 0/a02-ASCACHE -> AWACKS

a02 ships a cache update and starts to wait for acknowledgments.

    16.174 0/iNE:OPEN <NE:TALK#2 +29
    16.174 0/lDBG ITC/NE:OPEN: Enter HCUP
    16.174 0/pNE02-PWCACHE NE CS_ANSWERED -> CS_TALKED
    16.174 0/lDBG EW02-NE/PWCACHE (C_TALKED(EW02-NE/PWCACHExITC/NE:OPEN)) cPEWAHU

Cache update is processed by NE p02, and committed to the tile.

    16.177 0/iNE:OPEN >NE:HANGUP#2 +2

And it ships the hangup packet.

    16.177 0/pNE02-PWCACHE -> PINIT
    16.177 0/lDBG EW02-NE/PINIT PASSIVE DONE

And the event is done on the passive side.

    16.185 0/iSW:OPEN <SW:HANGUP#2 +2

The hangup arrives SW.

    16.185 0/lDBG ITC/SW:OPEN: Enter HUP
    16.185 0/lDBG EW02-AC/AWACKS hHU ITC/SW:OPEN
    16.185 0/lDBG EW02-AC/AWACKS FREEING (35,33)+4
    16.185 0/a02-AWACKS -> IDLE

a02 commits to the tile, and the event ends active side.

[113:

Wed Jun 17 11:02:25 2020 Well, so that's not a bug case I think, but
there's lots more t2trace17 to look at, and we KNOW there are bugs in
the end.  Back after bfast.
[114:

Wed Jun 17 11:32:52 2020 We need to print out a for-real ASCII tile
map, so we can align tile coordinates with ITC zones and such with
some kind of confidence.  Let's just whip that up before struggling
forward in t2trace17.[115:

Wed Jun 17 12:39:46 2020 OK here it is, all the way-too-wide of it:

root@beaglebone:/home/t2/MFM/src/drivers/mfmt2# ../../../bin/mfmt2 -m
11: MSG: ctor Sites 0x5976C0
12: MSG: CPU Frequency -> 600MHz
     0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55
 0 c34c34c34c34c34c34c34c34 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4c45c45c45c45c45c45c45c45 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5c05c05c05c05c05c05c05c05  0
 1 c34c34c34c34c34c34c34c34 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4c45c45c45c45c45c45c45c45 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5c05c05c05c05c05c05c05c05  1
 2 c34c34c34c34c34c34c34c34 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4c45c45c45c45c45c45c45c45 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5c05c05c05c05c05c05c05c05  2
 3 c34c34c34c34c34c34c34c34 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4c45c45c45c45c45c45c45c45 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5c05c05c05c05c05c05c05c05  3
 4 c34c34c34c34o34o34o34o34 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4o45o45o45o45o45o45o45o45 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5o05o05o05o05c05c05c05c05  4
 5 c34c34c34c34o34o34o34o34 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4o45o45o45o45o45o45o45o45 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5o05o05o05o05c05c05c05c05  5
 6 c34c34c34c34o34o34o34o34 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4o45o45o45o45o45o45o45o45 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5o05o05o05o05c05c05c05c05  6
 7 c34c34c34c34o34o34o34o34 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4o45o45o45o45o45o45o45o45 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5o05o05o05o05c05c05c05c05  7
 8  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0  8
 9  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0  9
10  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 10
11  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 11
12  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 12
13  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 13
14  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 14
15  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 15
16  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 16
17  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 17
18  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 18
19  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 19
20  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 20
21  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 21
22  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 22
23  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 23
24  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 24
25  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 25
26  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 26
27  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 27
28  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 28
29  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 29
30  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 30
31  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 31
32 c23c23c23c23o23o23o23o23 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2o12o12o12o12o12o12o12o12 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1o01o01o01o01c01c01c01c01 32
33 c23c23c23c23o23o23o23o23 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2o12o12o12o12o12o12o12o12 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1o01o01o01o01c01c01c01c01 33
34 c23c23c23c23o23o23o23o23 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2o12o12o12o12o12o12o12o12 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1o01o01o01o01c01c01c01c01 34
35 c23c23c23c23o23o23o23o23 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2o12o12o12o12o12o12o12o12 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1o01o01o01o01c01c01c01c01 35
36 c23c23c23c23c23c23c23c23 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2c12c12c12c12c12c12c12c12 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1c01c01c01c01c01c01c01c01 36
37 c23c23c23c23c23c23c23c23 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2c12c12c12c12c12c12c12c12 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1c01c01c01c01c01c01c01c01 37
38 c23c23c23c23c23c23c23c23 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2c12c12c12c12c12c12c12c12 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1c01c01c01c01c01c01c01c01 38
39 c23c23c23c23c23c23c23c23 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2c12c12c12c12c12c12c12c12 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1c01c01c01c01c01c01c01c01 39
     0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55
root@beaglebone:/home/t2/MFM/src/drivers/mfmt2#
Ugh maybe we should try to get it down to two-columns per?  Nah screw it.

:115]

:114]

:113]

:112]
[116:

Wed Jun 17 16:15:42 2020 OK well with my added debug tools I think I
have found one problem anyway.  This:

    #define T2_SITE_IS_VISIBLE_OR_CACHE(u32x,u32y)  \
      (((u32x)<2*CACHE_LINES)                       \
       || ((u32y)<2*CACHE_LINES)                    \
       || ((u32x)>T2TILE_WIDTH-2*CACHE_LINES)       \
       || ((u32y)>T2TILE_HEIGHT-2*CACHE_LINES))     \

should be this:

    #define T2_SITE_IS_VISIBLE_OR_CACHE(u32x,u32y)  \
      (((u32x)<2*CACHE_LINES)                       \
       || ((u32y)<2*CACHE_LINES)                    \
       || ((u32x)>=T2TILE_WIDTH-2*CACHE_LINES)      \
       || ((u32y)>=T2TILE_HEIGHT-2*CACHE_LINES))    \

and similarly for T2_SITE_IS_CACHE.

DOH.

Let's see how much difference fixing just those makes..

:116]
[117:

Thu Jun 18 01:35:18 2020 Well, have been going since about 11pm and
making a lot of progress.  Understanding the aew vs pew cache update
coord mappings properly, for example.
[121:

Thu Jun 18 01:39:19 2020 And now it's looking like the passive EW
never actually loads the sites from the tile?  But it compares all the
EW atoms (up to mLastSN) against the tile ones, and writes any
changes?  We need to see if this can possibly be true.  loadSites()
never getting called on pEWs?[122:

Thu Jun 18 01:43:50 2020 No, loadSites is never getting called on
pEWs.  Do we have some way to avoid needing to?[123:

Thu Jun 18 05:06:36 2020 OK, well, time to commit this stuff.  There's
still some weirdnesses even with a single bein -- like it can enter
from the NE going straight down, bounce off the bottom and go straight
back up, and yet not be able to reenter NE for some reason -- but
things are working MUCH MUCH better than before.

Yes, NOW we are loading sites on the passive window, and that appears
to have fixed the transporter duplication problems, at least for the
moment.

[124:

Thu Jun 18 05:11:41 2020 And we've been screwing around with the
display code to get the border showing which ITCs are open and so
forth.

Committing.

:124]

:123]

:122]

:121]
:117]
[125:

Thu Jun 18 12:23:50 2020 Well it's time to move the flag again.

FUN NEW APPARENT FACT: It looks like a single bein can get into a
yoink race with itself.

BACKGROUND: I left a single bein running across three otherwise empty
tiles when I went for second sleep.  When I got back it was gone.
Upon inspection I found evidence pointing to native engine restarts
due to failures at T2EventWindow.cpp:235.  Which is:

      bool T2EventWindow::passiveWinsYoinkRace(const T2EventWindow & ew) const {
        MFM_API_ASSERT_ARG(ew.isActiveEW());     // ew is our side active initiation
        MFM_API_ASSERT_ARG(!this->isActiveEW()); // *this is passive ew for them
235->   FAIL(INCOMPLETE_CODE);
        return false;
   ..

[126:

Thu Jun 18 12:28:03 2020 So I'm guessing what might have happened is
that:

(1) The bein did an event that crossed tiles
(2) The passive side -- necessarily the bein's 'arrival' side --
    finished the event first, as it does.  It sent the hangup and then
    released the pEW.
(3) The active side received that hangup and cleaned up that circuit,
    BUT, it could not tear down the whole event because it was waiting
    for a hangup from its SECOND ITC.
(4) The previously-passive side starts an event on the bein and
    requests a lock from the previously-and-not-quite-down active
    side.
(5) Race -> incomplete code -> fail out top-level -> engine restart

[127:

Thu Jun 18 12:35:15 2020 So if this story is true, a key part of it is
an active ew that's holding two locks.  Otherwise, the aEW would get
torn down as soon as the (only) hangup was received, and the lock
request right behind it would find nothing to race against.  (Since by
assumption there's only one bein in the entire universe.)

:127]
:126]

:125]
[128:

Fri Jun 19 05:23:56 2020 OK let's deal with the effen yoink races again.

:128]
[129:

Fri Jun 19 07:13:19 2020 Well, another thing we see is there's some
kind of infelicity that sometimes causes ITCs to take a very long time
to get to OPEN, although they do get there.  I think I just captured
two -l4 trace files of that happening; we should try to get them
together and see what's going on.  (It appears to be one side keeps
doing CACHEXG while the other keeps saying SHUT, but the details are
absolutely unclear.)[130:

Fri Jun 19 08:46:21 2020 Well the first issue seems to be that when
ITC A 'spontaneously' sends SHUT to ITC B, ITC B advances to DRAIN,
and then to CACHEXG, which sends a CACHEXG packet back to ITC A.  But
ITC A is still in state SHUT (not DRAIN), and it encounters this code:

 ..
  void T2ITCStateOps_CACHEXG::receive(T2ITC & itc, T2PacketBuffer & pb, TimeQueue& tq) {
    if (itc.getITCSN() < ITCSN_DRAIN) itc.reset();
 ..

which causes ITC A to reset, so eventually ITC A sends another SHUT,
while ITC B is waiting for inbound CACHEXG.

Like this:

    77.242         1/iSW:SHUT >iSW:SHUT?784756B3  +6

1/iSW sends SHUT w/sync 7847

    77.245         1/iSE:SHUT >iSE:SHUT?795A6ED8  +6
    77.247         1/iNE:SHUT >iNE:SHUT?3BFEC8B4  +6

(So do SE and NE but we're not following them now.)

    77.251                 2/iNE:SHUT <iNE:SHUT?784756B3  +6

7847 arrives at 2/iNE

    77.251                 2/iNE:SHUT -> DRAIN

So 2/iNE advances to DRAIN

    77.253                 2/iNW:SHUT <iNW:SHUT?795A6ED8  +6
    77.253                 2/iNW:SHUT -> DRAIN
    77.254                 2/iNE:DRAIN -> CACHEXG
    77.260                 2/iNE:CACHEXG >iNE:CACHEXG +254

And then starts CACHEXG, sending the first packet to 1/iSW

    77.260                 2/iNW:DRAIN -> CACHEXG
    77.261         1/iSW:SHUT <iSW:CACHEXG +254

Which 1/iSW receives.  But it's unhappy with it,

    77.262         1/iSW:SHUT -> SHUT

And it resets

    77.266         1/iSW:SHUT >iSW:SHUT?49C834EE  +6

Then sends another SHUT.

[131:

Fri Jun 19 08:58:40 2020 So what's the fix?  Do we think 1/iSW
should've gone to DRAIN as soon as it sent the SHUT?  Otherwise how
can it handle the CACHEXG, when it might have EWs in progress?

But if we do say 1/iSW goes to DRAIN 'prospectively', before hearing
from 2/iNE, that's going to cause it to pause events even if there'll
be no response coming.

Hey, how come 2/iNE going to DRAIN didn't send a packet about that?
Wouldn't that be the right / a better way to deal with this?

Receive SHUT when in SHUT, go to DRAIN and send DRAIN.
Receive SHUT when in DRAIN, stay in DRAIN send DRAIN.
Receive SHUT otherwise, reset.
Receive DRAIN when in SHUT, go to DRAIN and send DRAIN.
Receive DRAIN when in DRAIN, ignore.
Timeout in SHUT, if compatible send SHUT and wait MEDIUM
Timeout in DRAIN, if EWs in use, reset (go to SHUT and send SHUT),
  else go to CACHEXG and send CACHEXG
[132:

Fri Jun 19 14:58:11 2020 That seems to've helped out with the observed
'getting to open' failures.

:132]
:131]
:130]

:129]
[133:

Fri Jun 19 14:58:54 2020 So let's sum up our 'single-bein
self-interference' problem.  It's a kind of helpful and concrete way,
if sort of weird and back-door, to get back into the race resolution
issues.

:133]
[134:

Sat Jun 20 00:56:02 2020 OK, I'm going to annotate a full trace that
captures a single-bein self-interference event.  The set-up here is
like this:

         ........ribbon.cable..
        .                      .
        .  +-----------+       .
        .  |  Tile 0/  |       .
        .  |           |       .
        .  |SW       SE|       .
        .  +||-------||+       .
        .   .       +||-------||+
         ...        |NW       NE|
                    |           |
                    |  Tile 1/  |
                    +-----------+

So the two tiles are 'cross connected' at the bottom: 0/iSE<->1/iNW,
and 0/iSW<->1/iNE.

It goes like this:

    173.703 0/a12-IDLE -> AINIT
    173.703 0/a12-AINIT a@(28,35)+4

0/a12 contemplates an event at (28,35).  Row 35 is the extreme
southern row of 'owned sites' on tile#0, and column 28 is the east
side fo the column 27-28 border which is the horizontal center of the
tile.

    173.703 0/a12-AINIT SE CS_UNUSED -> CS_BOUND

0/a12 determines the SE ITC is involved, and binds a circuit to it.

    173.703 0/a12-AINIT SW CS_UNUSED -> CS_BOUND

0/a12 determines the SW ITC is also involves and binds a second
circuit for that.

    173.704 0/lDBG a12/AINIT sites available
    173.704 0/lDBG a12/AINIT OWNING (28,35)+4

a12 takes ownership of the region out to radius 4 on tile 0/

    173.704 0/lDBG a12/AINIT RING SE abs(28,35) usrel(4,3) yoink=1
    173.706 0/iSE:OPEN >SE:RING#12(4,3)+4o +5
    173.706 0/a12-AINIT SE CS_BOUND -> CS_RUNG

a12 sends a 'RING' lock request out the SE ITC, destined for 1/iNW.

    173.706 0/lDBG a12/AINIT RING SW abs(28,35) usrel(28,3) yoink=0
    173.715 0/iSW:OPEN >SW:RING#12(28,3)+4e +5
    173.715 0/a12-AINIT SW CS_BOUND -> CS_RUNG

And sends one out the SW ITC as well.  (Although it's not significant
for this example, note how the coordinates sent in the two cases
differ -- (28,3) vs (4,3)!  RING packets use coordinates relative to
the specific ITC, and the SW ITC origin is precisely 24 sites west of
the SE ITC origin.)

    173.715 0/a12-AINIT -> AWLOCKS

0/a12 switches to waiting for lock replies.

    173.781         1/iNW:OPEN <NW:RING#12(4,3)+4o +5
    173.781         1/lDBG ITC/NW:OPEN: HRP abs(4,3) themrel(4,3) yoink=1
    173.781         1/pNW12-PINIT -> PINIT
    173.781         1/pNW12-PINIT p@(4,3)+4

The NW ITC on tile 1 receives its RING first, and inits 1/pNW12, its
passive event window corresponding to 0/a12.

    173.781         1/pNW12-PINIT NW CS_BOUND -> CS_RUNG

The passive circuit records that a ring was received.

    173.781         1/pNW12-PINIT -> PRESOLVE

The passive EW checks to see about resolving any races.

    173.781         1/pNW12-PRESOLVE -> PWCACHE
    173.783         1/iNW:OPEN >NW:ANSWER#12 +2

But there are none, so 1/pNW12 moves on waiting for cached updates and
ships the lock-granted 'ANSWER' packet back out 1/iNW.

    173.783         1/pNW12-PWCACHE NW CS_RUNG -> CS_ANSWERED

And the passive circuit records that an answer was sent.

    173.792         1/iNE:OPEN <NE:RING#12(28,3)+4e +5

Nine milliseconds later, 1/iNE receives its RING request.

    173.792         1/lDBG ITC/NE:OPEN: HRP abs(52,3) themrel(28,3) yoink=0
    173.792         1/pNE12-PINIT -> PINIT
    173.792         1/pNE12-PINIT p@(52,3)+4
    173.792         1/pNE12-PINIT NE CS_BOUND -> CS_RUNG
    173.792         1/pNE12-PINIT -> PRESOLVE
    173.792         1/pNE12-PRESOLVE -> PWCACHE
    173.794         1/iNE:OPEN >NE:ANSWER#12 +2
    173.794         1/pNE12-PWCACHE NE CS_RUNG -> CS_ANSWERED

And it performs the analogous steps, granting the lock request.

    173.856 0/iSE:OPEN <SE:ANSWER#12 +2
    173.856 0/lDBG ITC/SE:OPEN: Enter HAP
    173.856 0/a12-AWLOCKS SE CS_RUNG -> CS_ANSWERED
    173.856 0/lDBG ITC/SE:OPEN a12/AWLOCKS HAP
    173.856 0/lDBG a12/AWLOCKS hACK ITC/SE:OPEN

The 1/iNW ANSWER arrives at 0/iSE and 0/a12 processes it.

    173.858 0/iSW:OPEN <SW:ANSWER#12 +2
    173.858 0/lDBG ITC/SW:OPEN: Enter HAP
    173.858 0/a12-AWLOCKS SW CS_RUNG -> CS_ANSWERED
    173.858 0/lDBG ITC/SW:OPEN a12/AWLOCKS HAP
    173.858 0/lDBG a12/AWLOCKS hACK ITC/SW:OPEN

The 1/iSE ANSWER is handled as well.

    173.858 0/a12-AWLOCKS -> ABEHAVE

0/a12 has all the locks it needs, and moves to behave

    173.858 0/lDBG a12/ABEHAVE (28,35)BEIN ngb 3 live 1

The bein in (28,35) is heading in the '3' direction, which is straight
down south.  That's going to take it to (28,36), which the bein
examines and sees that it's alive.

And CRUCIALLY for our story, NOTE THIS: (28,36) is actually in the
CACHE of tile 0/.  It is not a 'owned sites' of tile 0/!

Recall that this whole event this began in the SOUTHERNMOST ROW of
tile 0/.  When our intrepid bein swaps one site south from there, it
will ultimately end up in the NORTHERNMOST ROW of tile 1/.

And therefore -- FORESHADOWING -- subsequent events for that bein will
be conducted by tile 1/, not tile 0/.

    173.858 0/a12-ABEHAVE -> ASCACHE

Anyway, the bein's transition takes place in 0/a12, which moves on to
the cache updates stage.

    173.859 0/lDBG SHIP#0 sn3 (28,36) tt 0xFFFF wt 0x0001
    173.859 0/lDBG SHIP#1 sn0 (28,35) tt 0x0001 wt 0xFFFF

Two sites are targeted in the cache update: (28,36) stops being empty
(type 0xFFFF) to becomes a 'bein' (type 0x0001), and (28,35) does the
reverse.

    173.861 0/iSE:OPEN >SE:TALK#12 +29

And that 'TALK' -- cache update -- gets shipped out 0/iSE.

    173.861 0/lDBG SHIP#0 sn3 (28,36) tt 0xFFFF wt 0x0001
    173.861 0/lDBG SHIP#1 sn0 (28,35) tt 0x0001 wt 0xFFFF
    173.863 0/iSW:OPEN >SW:TALK#12 +29

An analogous TALK goes out 0/iSW.

    173.863 0/a12-ASCACHE -> AWACKS

And 0/a12 settles down to await acknowledgments.

    173.989         1/iNW:OPEN <NW:TALK#12 +29
    173.989         1/lDBG ITC/NW:OPEN: Enter HCUP
    173.989         1/pNW12-PWCACHE NW CS_ANSWERED -> CS_TALKED

The 0/iSE cache update arrives at 1/iNW and is dished to 1/pNW12, and
its circuit state updates to note the TALK arrival.

    173.989         1/lDBG p12NW/PWCACHE CUPSN#3 mLastSN 40

1/pNW12 starts processing the cache update.

    173.989         1/lDBG RECV#0 sn3 (4,4) tt 0xFFFF wt 0x0001

1/pNW12's site (4,4) becomes a bein (type 1) instead of empty.

NOTE THAT (4,4) is an OWNED SITE!  Tile 1/ can run events there!

    173.989         1/lDBG p12NW/PWCACHE CUPSN#0 mLastSN 40
    173.989         1/lDBG RECV#1 sn0 (4,3) tt 0x0001 wt 0xFFFF

And 1/pNW12's site (4,3) (which is in tile 1/'s cache) becomes empty.

    173.989         1/lDBG p12NW/PWCACHE CUPSN#255 mLastSN 40

CUPSN#255 means 'no more cache updates'.

    173.989         1/lDBG p12NW/PWCACHE (C_TALKED(p12NW/PWCACHExITC/NW:OPEN)) cPEWAHU

So 1/pNW12 commits!  Its changes get written to tile 1/ site memory!

    173.991         1/iNW:OPEN >NW:HANGUP#12 +2

It sends a HANGUP packet out on 1/iNW, marking the end of the event
from its point of view.

    173.991         1/pNW12-PWCACHE -> PINIT
    173.991         1/lDBG p12NW/PINIT PASSIVE DONE

And 1/pNW12 resets its circuit, and -- as far as 1/pNW12 is concerned
-- the event is done.

    174.000         1/iNE:OPEN <NE:TALK#12 +29

Similarly, the 0/iSW cache update arrives at 1/iNE.

    174.000         1/lDBG ITC/NE:OPEN: Enter HCUP
    174.000         1/pNE12-PWCACHE NE CS_ANSWERED -> CS_TALKED
    174.000         1/lDBG p12NE/PWCACHE CUPSN#3 mLastSN 40
    174.000         1/lDBG RECV#0 sn3 (52,4) tt 0x0001 wt 0x0001
    174.000         1/lDBG p12NE/PWCACHE CUPSN#0 mLastSN 40
    174.000         1/lDBG RECV#1 sn0 (52,3) tt 0x0001 wt 0xFFFF

Affecting two sites (52,4) and (52,3), that are in the tile/1's cache
off in the northeast.

    174.000         1/lDBG p12NE/PWCACHE CUPSN#255 mLastSN 40
    174.000         1/lDBG p12NE/PWCACHE (C_TALKED(p12NE/PWCACHExITC/NE:OPEN)) cPEWAHU
    174.002         1/iNE:OPEN >NE:HANGUP#12 +2

And 1/pNE12 ships its HANGUP packet too.

    174.002         1/pNE12-PWCACHE -> PINIT
    174.002         1/lDBG p12NE/PINIT PASSIVE DONE

And likewise, the event is now done as far as 1/pNE12 is concerned.

So let's pause for a minute and review where we are.  Over on tile 0/,
0/a12 started an event, got locks on 1/iNE and 1/iNW, did the
transition, and send out two cache updates.

At the moment, 0/a12 is in state AWACKS, waiting for acknowledgments
of the cache udpates.

But here on tile 1/, the cache updates have been processed by 1/pNW12
and 1/pNE12, and the HANGUP packets have been sent, and all is quiet.

    174.006         1/a17-IDLE -> AINIT
    174.006         1/a17-AINIT a@(4,4)+4

SO THEREFORE, FOUR MILLISECONDS LATER, THERE'S NO REASON *NOT* TO
START AN EVENT ON TILE 1.  And 1/a17 sets off to do just that.

    174.006         1/a17-AINIT WT CS_UNUSED -> CS_BOUND
    174.006         1/a17-AINIT NW CS_UNUSED -> CS_BOUND

From Tile 1's point of view, site (4,4) requires the involvement of
1/iWT and 1/iNW, so those two circuits are bound.  Now in this case,
1/iWT is SHUT, so no lock request is needed there.

    174.006         1/lDBG a17/AINIT sites available
    174.006         1/lDBG a17/AINIT OWNING (4,4)+4
    174.006         1/lDBG a17/AINIT RING NW abs(4,4) usrel(4,0) yoink=1
    174.008         1/iNW:OPEN >NW:RING#17(4,0)+4o +5

But 0/iNW is OPEN, and so 1/a17 it sends a RING lock request that way.

    174.008         1/a17-AINIT NW CS_BOUND -> CS_RUNG
    174.008         1/a17-AINIT -> AWLOCKS

And records that fact, and goes to await lock acknowledgments.

    174.068 0/iSE:OPEN <SE:HANGUP#12 +2

Back on tile 0/, the HANGUP packet shipped by 1/p12NW arrives at
0/iSE.

    174.068 0/lDBG ITC/SE:OPEN: Enter HUP
    174.068 0/a12-AWACKS SE CS_ANSWERED -> CS_UNUSED
    174.068 0/lDBG a12/AWACKS hHU ITC/SE:OPEN

And 0/a12 handles it, and tears down the SE circuit, which is no
longer needed.

BUT 0/a12 CAN'T FINISH THE EVENT COMPLETELY YET, BECAUSE IT IS STILL
WAITING FOR THE HANGUP FROM 0/iSW!

And that HANGUP packet is (almost surely) available, just sitting in
the 0/iSW buffers waiting to be picked up.

    174.075 0/iSE:OPEN <SE:RING#17(4,0)+4o +5

But for now, tile 0/ continues checking for packets from 0/iSE!

    174.075 0/lDBG ITC/SE:OPEN: HRP abs(28,36) themrel(4,0) yoink=1

And indeed there's a packet to be found there!  It's the RING request
from 1/a17!  ONO!

    174.075 0/pSE17-PINIT -> PINIT
    174.075 0/pSE17-PINIT p@(28,36)+4
    174.075 0/pSE17-PINIT SE CS_BOUND -> CS_RUNG

And 0/pSE17 gets initialized to handle the RING.

    174.075 0/pSE17-PINIT -> PRESOLVE

And it goes to resolve any possible races.

AND THE CODE BLOWS UP RIGHT THERE, BECAUSE IT DETECTS A RACE WITH THE
STILL-EXISTING 0/a12 !!!!  A SINGLE BEIN RACES AGAINST ITSELF!

The 0/ mfmt2 was running inside gdb, and it blocked as soon as they
hit the error.

    186.988         1/iNE:OPEN >iNE:OPEN?5F58690E  +6
    188.972         1/iNW:OPEN >iNW:OPEN?1C380EEB  +6

The 1/ mfmt2 survived a little longer, sending out a couple OPEN
notifications, before it too hit a gdb breakpoint and blocked.

    16971.834         1/t  Failed to top: src/T2EventWindow.cpp:836: INCOMPLETE_CODE [1]

The failures didn't get recorded until way later, when I showed up
again and continue gdb -- thus the time jump from 188 -> 16971.

1/ died here, once it timed-out waiting for a lock ack that never
arrived:

T2EventWindow.cpp:835:      LOG.Error("%s on %s: TO AWLOCKS with pending locks", getStateName(), ew.getName());
T2EventWindow.cpp:836:      FAIL(INCOMPLETE_CODE);

    16974.017         1/t  Total events completed = 3697250
    17033.102 0/t  Failed to top: src/T2EventWindow.cpp:235: INCOMPLETE_CODE [1]

while 0/ died here

T2EventWindow.cpp:832:  bool T2EventWindow::passiveWinsYoinkRace(const T2EventWindow & ew) const {
T2EventWindow.cpp:833:    MFM_API_ASSERT_ARG(ew.isActiveEW());     // ew is our side active initiation
T2EventWindow.cpp:834:    MFM_API_ASSERT_ARG(!this->isActiveEW()); // *this is passive ew for them
T2EventWindow.cpp:835:    FAIL(INCOMPLETE_CODE);
T2EventWindow.cpp:836:    return false;

    17035.236 0/t  Total events completed = 2048941
    [Inferior 1 (process 6427) exited normally]
    (gdb)

:134]
[135:

Sat Jun 20 04:10:17 2020 And YIKES that annotation took THREE HOURS?
Granted I screwed around SOME while doing it, but geez.. I hope it's
worth it.

:135]
[136:

Sat Jun 20 04:53:27 2020 So, discussion question:

HOW TO FIX SINGLE-BEIN SELF INTERFERENCE?

And, restatement: SHOULD WE FIX SINGLE-BEIN SELF INTERFERENCE?

Here's how it looks to me:

(1) If we had added yet one more leg to the event, the passive sides
    could send their HANGUPs but wait for the active side to also hang
    up, before releasing their sites.

(2) That would slow things down, but would 'guarantee' that the active
    EW -- which is the one potentially holding multiple locks --
    finishes before the passive EW, which is releasing only a single
    lock.

(3) What I don't like about that is it seems like it gives a
    rich-get-richer repeated advantage to the active side: At the
    moment that that aEW releases, its tile will be the only one that
    could regrab those sites (or overlapping ones) for another event.
    I worry about 'stochastic starvation' on the passive sides causing
    highly irregular event patterns with high-variance statistics.

(4) And finally, if we FOGGEN GET THE RACE RESOLUTION CODE WRITTEN, we
    could 'just' go ahead and let the (previously) passive side try to
    grab the lock, and have the (still) active side NAK it, if the
    passive new request happens to get in ahead of the last HANGUP the
    old active is still waiting for.

:136]
[137:

Sat Jun 20 05:19:46 2020 Time for morning walk.

:137]
[138:

Sat Jun 20 05:53:01 2020 OK, so

PASSIVE SIDE RACE RULES GO GO GO

 - On receive RING, scan requested region and assemble conflict set

 - Perhaps sort the conflict set according to some notion of age
   (literal wall clock oldest?  Farthest advanced through its event
   sequence?  The latter, breaking ties with the former?)

 - But in any case, eventually, do cases.  And what are the cases?

The case we just annotated was

EXISTING 0/a12-AWACKS vs INCOMING 0/pSE17-PRESOLVE

 -> suggested resolution: NAK the passive and tear it down, done.

[139:

Sat Jun 20 06:27:21 2020 I guess the next question is: Is there really
any OTHER possible outcome, given an inbound passive vs an existing
active?

Well, sure there is: If the existing active is in state AWLOCKS,
that's when we have the yoink race.[140: Sat Jun 20 06:43:08 2020 So
okay what are the cases there?

 - If existing AWLOCKS wins the race, NAK the inbound passive.

 - If existing AWLOCKS loses the race, then DROP any existing locks it
   may have, then tear down the aEW, then allow the inbound passive
   processing to continue.  (Even though it might later fail on some
   other conflict -- meaning both racing aEWs end up blown up.  So be
   it.)

:140]

And then the other category is inbound passive against existing
passive.  In that case it seems like we have to NAK.

:139]

:138]
[141:

Sat Jun 20 06:47:59 2020 And is that it?  To summarize:

=====
PAIRWISE PASSIVE-SIDE CONFLICT RESOLUTION RULES

 VS EXISTING ACTIVE:
 Case 1a: Existing active state is > AWLOCKS.
 Resolution: NAK inbound passive and tear it down.

 Case 2a: Existing active state is == AWLOCKS and WINS Yoink race
 Resolution: NAK inbound passive and tear it down.

 Case 3a: Existing active state is == AWLOCKS and LOSES Yoink race
 Resolution: DROP any aEW circuits at CS_ANSWERED, then tear down aEW

 VS EXISTING PASSIVE:
 Case 1p: Existing passive in any state.
 Resolution: NAK inbound passive and tear it down
=====

and then this would be the entire

=====
INCOMING PASSIVE SIDE RING HANDLING PROCESS

1. Assemble EW conflict set

2. Sort conflict set

3. For each member of the conflict set in turn, perform the PAIRWISE
   PASSIVE-SIDE CONFLICT RESOLUTION to decide who dies.  If the
   inbound passive dies, stop the loop, send NAK, and kill the passive

4. If the inbound passive survives all conflicts, continue from there
   as if no conflicts occured (since they must now all be gone.)
=====

[142:

Sat Jun 20 07:36:15 2020 And I guess the 'last' question is so yes how
do we sort the conflicts?

 - If we have any freedom in the matter, would we want to organize
   things to kill the inbound as quick as possible?  Like sort pEW
   conflicts ahead of active ones?

But does that even make sense?  Suppose we kill the inbound pEW
because of some other established pEW.  ...I still get confused.

Try again.

We're saying that the receiver of an inbound (passive) lock request
has the absolute right to ACK/NAK it, basically for any reason, and
the RING sending (active) side has to both (1) Wait for that ACK/NAK,
and (2) Abide by it.

At the same time, we're saying the active side has the absolute right
to DROP an established circuit to a passive side that ANSWERed its
original RING.  And once again, it can do that for basically any
reason, and the ANSWER sending (passive) side has to accept it and
tear down its event.

SO IN THAT CONTEXT, we could, if we wanted, simply always NAK
conflicting inbound passives, and that would be completely 'legal'.
But since both sides would be be doing that, in a genuine race, we'd
always end up blowing up both events.

So we employ the yoink protocol in an attempt to blow up fewer events.
The results of yoinking must be that at most one conflicting aEW
survives.  And we ensure that by ACKing an inbound passive only after
we've blown up any lost-race existing AWLOCKS.

And it's okay if zero aEWs survive in complex cases, because that's
what would have happened without the yoink anyway (supposedly; we
allege).

[143:

Sat Jun 20 08:58:15 2020 Nap time.  Then we have to polish the
extended abstract for ALIFE2020.  So we won't get back to this until
Sunday, grr.

:143]
:142]

:141]
[144:

Mon Jun 22 02:20:15 2020 Well, finishing the "SPOTs and Spatial
Threads" mini-paper of course took longer that 'planned'.  But it's
shipped now (and it's a lot better than it was at initial submission,
so there's that).

:144]
[145:

Mon Jun 22 02:21:14 2020 But now we're barely over 24 hours till we
need to be shooting the update: How much race resolution do you think
we can get going?

[146:

Mon Jun 22 02:22:12 2020 Who knows; let's find out; follow :141: above
- GO GO GO
[147:

Mon Jun 22 03:11:56 2020 OK we have a reinstated passiveWinsYoinkRace
that I guess we want to commit, because it's not obviously stupid and
that's the easiest way to get the code to the next-door tiles doh.

[148:

Mon Jun 22 03:55:58 2020 OK here's an issue coming up that we kind of
wondered if it would.  This code:

    // our ew must also have itc in its info, but we have to search for it
    const Circuit *aci = ew.getActiveCircuitForITCIfAny(itc);
    MFM_API_ASSERT_NONNULL(aci);

is blowing up because 'itc' is pointing at iNE, but ew's circuits
never mention that, because:

    (gdb) p ew.mActiveCircuits[0].mITC
    $15 = (MFM::T2ITC *) 0x0
    (gdb) p ew.mActiveCircuits[1].mITC
    $16 = (MFM::T2ITC *) 0x4dd0a0 <MFM::T2Tile::get()::THE_INSTANCE+3976>
    (gdb) p ew.mActiveCircuits[1].mITC->mName
    $17 = 0x4966a8 "NW"
    (gdb)

ew only mentions iNW.  Why?  Well for one thing, active-side ew and
passive-side *this have different event centers:

    (gdb) p ew.mCenter
    $18 = {m_x = 35, m_y = 4}
    (gdb) p this->mCenter
    $19 = {m_x = 36, m_y = 3}
    (gdb)


For (35,4), well y==4 is the top row of owned sites, and with x==35,
radius 4 just barely reaches (31,4), which is in the iNW visible
rectangle.  So it makes sense that ew has bound a circuit through
iNW.

What doesn't make sense to me at the moment is: Why isn't iNE in ew's
circuits as well??  (35,4) is totally in the visible rectangle of iNE!

And iNE is definitely open for business:

    (gdb) p itc.mName
    $22 = 0x4966ac "NE"
    (gdb) p itc.mStateNumber
    $23 = MFM::ITCSN_OPEN
    (gdb)

So what's the deal???
[149:

Mon Jun 22 04:13:26 2020 So hey look at this, from the (still-open)
trace file for this run:

    49.315 0/a17-IDLE -> AINIT
    49.315 0/a17-AINIT a@(35,4)+4
    49.316 0/a17-AINIT NE CS_UNUSED -> CS_BOUND
    49.316 0/a17-AINIT NW CS_UNUSED -> CS_BOUND
    49.316 0/lDBG a17/AINIT sites available
    49.316 0/lDBG a17/AINIT OWNING (35,4)+4
    t2@beaglebone:~/MFM/src/drivers/mfmt2$

(There's probably more events that haven't been flushed to disk yet,
but anyway.)  So that sure makes it look like both iNW and iNE were
bound for this event.

[150:

Mon Jun 22 04:29:33 2020 So hey, I think this might be yet another
thinko on my part.  In particular, recall our current physical setup:

         ........ribbon.cable..
        .                      .
        .  +-----------+       .
        .  |           |       .
        .  |   'BLUE'  |       .
        .  |SW       SE|       .
        .  +||-------||+       .
        .   .       +||-------||+
         ...        |NW       NE|
                    |   'RED'   |
                    |           |
                    +-----------+


Note I'm going to be showing traces from UNALIGNED files, here -- so
they have different timebases and they both think they're '0/'.  The
above trace, with the active EW, we'll say is from the RED tile, and
the trace below, with the passive EWs, we'll say is from the BLUE
tile.

    91.200 0/iSW:OPEN <SW:RING#17(11,0)+4e +5

BLUE's iSW recvs RED's active ring#17 via NE (and the ribbon cable).

    91.200 0/lDBG ITC/SW:OPEN: HRP abs(11,36) themrel(11,0) yoink=0

(11,0) relative to the NE visible rect is indeed (35,4) in RED coords.

    91.200 0/pSW17-PINIT -> PINIT
    91.200 0/pSW17-PINIT p@(11,36)+4
    91.200 0/pSW17-PINIT SW CS_BOUND -> CS_RUNG
    91.200 0/pSW17-PINIT -> PRESOLVE
    91.200 0/pSW17-PRESOLVE -> PWCACHE

pSW17 sees no conflict.

    91.202 0/iSW:OPEN >SW:ANSWER#17 +2
    91.202 0/pSW17-PWCACHE SW CS_RUNG -> CS_ANSWERED

And so it grants the lock, answering back on SW.

    91.203 0/iSE:OPEN <SE:RING#17(35,0)+4o +5
    91.203 0/lDBG ITC/SE:OPEN: HRP abs(59,36) themrel(35,0) yoink=1

Now here comes a RING#17 on SE.  It's at (35,0) relative to the NW
visible rectangle -- it isn't even _in_ the NE viz rectangle, but the
radius of four just stretches from (35,0) down to (31,0), which is in
the NW viz rect.

    91.203 0/pSE17-PINIT -> PINIT
    91.203 0/pSE17-PINIT p@(59,36)+4

In BLUE terms, this center is way off in the SE at (59,36)

    91.203 0/pSE17-PINIT SE CS_BOUND -> CS_RUNG
    91.203 0/pSE17-PINIT -> PRESOLVE

Which also appears available.

    91.204 0/pSE17-PRESOLVE -> PWCACHE
    91.205 0/iSE:OPEN >SE:ANSWER#17 +2
    91.205 0/pSE17-PWCACHE SE CS_RUNG -> CS_ANSWERED

So BLUE grants that lock as well.

At this point, from BLUE's point of view, RED's a17 is hogging a total
of 82 BLUE sites at two different locations!

    91.320 0/iSW:OPEN <SW:TALK#17 +29

Here comes an a17 cache update in on SW.

    91.320 0/lDBG ITC/SW:OPEN: Enter HCUP
    91.320 0/pSW17-PWCACHE SW CS_ANSWERED -> CS_TALKED
    91.320 0/lDBG p17SW/PWCACHE CUPSN#7 mLastSN 40
    91.320 0/lDBG RECV#0 sn7 (12,35) tt 0xFFFF wt 0x0001
    91.320 0/lDBG p17SW/PWCACHE CUPSN#0 mLastSN 40
    91.320 0/lDBG RECV#1 sn0 (11,36) tt 0x0001 wt 0xFFFF

pSW17 processes it.

    91.320 0/lDBG p17SW/PWCACHE CUPSN#255 mLastSN 40
    91.320 0/lDBG p17SW/PWCACHE (C_TALKED(p17SW/PWCACHExITC/SW:OPEN)) cPEWAHU
    91.322 0/iSW:OPEN >SW:HANGUP#17 +2
    91.322 0/pSW17-PWCACHE -> PINIT
    91.322 0/lDBG p17SW/PINIT PASSIVE DONE

and p17SW commits, hangs up, and is done.

    91.329 0/iSE:OPEN <SE:TALK#17 +29

Here comes the (analogous) cache update on SE.

    91.329 0/lDBG ITC/SE:OPEN: Enter HCUP
    91.329 0/pSE17-PWCACHE SE CS_ANSWERED -> CS_TALKED

And pSE17 is on the case.

    91.329 0/lDBG p17SE/PWCACHE CUPSN#7 mLastSN 40
    91.329 0/lWRN p17SE/PWCACHE sn7/(60,35) not accessible by ITC/SE:OPEN; ignored
    91.329 0/lDBG p17SE/PWCACHE CUPSN#0 mLastSN 40
    91.329 0/lWRN p17SE/PWCACHE sn0/(59,36) not accessible by ITC/SE:OPEN; ignored

It actually rejects both updates, because the resolved site numbers
aren't actually accessible from the SE.  And, really, RED a17
shouldn't have sent them to us, because it knows they're invalid on
this circuit -- but for the moment I'm leaving that active-side bug in
there to test the passive side rejection.

    91.329 0/lDBG p17SE/PWCACHE CUPSN#255 mLastSN 40
    91.329 0/lDBG p17SE/PWCACHE (C_TALKED(p17SE/PWCACHExITC/SE:OPEN)) cPEWAHU
    91.331 0/iSE:OPEN >SE:HANGUP#17 +2
    91.331 0/pSE17-PWCACHE -> PINIT

And that hangs up too.

    t2@beaglebone:~/MFM/src/drivers/mfmt2$

And that's all we've got so far.

[151:

Mon Jun 22 04:56:28 2020 Hmm, so well the thinko I thought I might
have didn't actually pan out.  I was worried the cross-couple
NE/SW+NW/SE would lead to a single event trying to take two locks on
the same remote sites -- but as we saw, that's not what happens: The
remote sites are far apart, and both get taken.

Well, so do we need to let these guys fail and die, so we can get our
trace buffers flushed and see the ends of the stories?

We still don't have an explanation for how a17 ended up with no NE
circuit.  Oh -- would that be just because a17 already processed the
BLUE iSW HANGUP, and so a17 tore down that circuit?  That seems
plausible.

[152:

Mon Jun 22 05:04:39 2020 So that leads us back to a (different)
thinko: Why should we expect -- or even care -- about whether a
passive/active race is involving the same itc?

Well, we thought it had to be the same itc because we thought the only
way this issue comes up is if two aEW's, both in AWLOCKS, collide with
each other.  And we wanted to resolve that using the yoink values from
the associated RING packets.  And the RING packets are on a per-ITC
basis.  So if we can't match up the ITC, we can't find the matching
yoink val, and we can run the yoink protocol.

But a17 is not in AWLOCKS:

    (gdb) p ew.mStateNum
    $24 = MFM::EWSN_AWACKS
    (gdb)

It already got its locks, had its event, and shipped cache updates.
That means it can have retired circuits, and here we are.

So really, T2PassiveEventWindow::passiveWinsYoinkRace needs to respect
that case.  Instead of blowing up if its ITC can't be found, it really
needs to be checking if aew is in AWLOCKS _first_.  If not, then
there's really no yoink race to be had, and, I guess, the passive
start has to just lose to the existing active.

Now, where is passiveWinsYoinkRace actually called?  Do we maybe want
to get involved a little earlier?[153:

Mon Jun 22 05:13:38 2020 Yeah, maybe caller should check for AWLOCKS
and not even go to passiveWinsYoinkRace otherwise.

:153]

:152]

:151]

:150]


:149]

:148]
:147]
:146]

:145]
[154:

Mon Jun 22 05:56:43 2020 So, it's what we inferred -- but for the
record, here's the rest of the RED trace, picking up from :149: above:

 ..
    49.316 0/lDBG a17/AINIT OWNING (35,4)+4
    49.316 0/lDBG a17/AINIT RING NE abs(35,4) usrel(11,0) yoink=0
    49.318 0/iNE:OPEN >NE:RING#17(11,0)+4e +5
    49.318 0/a17-AINIT NE CS_BOUND -> CS_RUNG
    49.319 0/lDBG a17/AINIT RING NW abs(35,4) usrel(35,0) yoink=1
    49.325 0/iNW:OPEN >NW:RING#17(35,0)+4o +5
    49.325 0/a17-AINIT NW CS_BOUND -> CS_RUNG
    49.325 0/a17-AINIT -> AWLOCKS

a17 RINGs NE and NW

    49.326 0/iNE:OPEN <NE:ANSWER#17 +2
    49.326 0/lDBG ITC/NE:OPEN: Enter HAP
    49.326 0/a17-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    49.326 0/lDBG ITC/NE:OPEN a17/AWLOCKS HAP
    49.326 0/lDBG a17/AWLOCKS hACK ITC/NE:OPEN
    49.328 0/iNW:OPEN <NW:ANSWER#17 +2
    49.328 0/lDBG ITC/NW:OPEN: Enter HAP
    49.328 0/a17-AWLOCKS NW CS_RUNG -> CS_ANSWERED
    49.328 0/lDBG ITC/NW:OPEN a17/AWLOCKS HAP
    49.328 0/lDBG a17/AWLOCKS hACK ITC/NW:OPEN
    49.329 0/a17-AWLOCKS -> ABEHAVE

gets both locks and goes to behave

    49.329 0/lDBG a17/ABEHAVE (35,4)BEIN ngb 7 live 1
    49.329 0/a17-ABEHAVE -> ASCACHE
    49.329 0/lDBG SHIP#0 sn7 (36,3) tt 0xFFFF wt 0x0001
    49.329 0/lDBG SHIP#1 sn0 (35,4) tt 0x0001 wt 0xFFFF
    49.338 0/iNE:OPEN >NE:TALK#17 +29
    49.338 0/lDBG SHIP#0 sn7 (36,3) tt 0xFFFF wt 0x0001
    49.339 0/lDBG SHIP#1 sn0 (35,4) tt 0x0001 wt 0xFFFF
    49.341 0/iNW:OPEN >NW:TALK#17 +29

ships two cache updates

    49.341 0/a17-ASCACHE -> AWACKS
    49.460 0/iNE:OPEN <NE:HANGUP#17 +2
    49.461 0/lDBG ITC/NE:OPEN: Enter HUP
    49.461 0/a17-AWACKS NE CS_ANSWERED -> CS_UNUSED
    49.461 0/lDBG a17/AWACKS hHU ITC/NE:OPEN

gets the first HANGUP and tears down the NE circuit

    49.462 0/iNE:OPEN <NE:RING#10(12,3)+4o +5
    49.462 0/lDBG ITC/NE:OPEN: HRP abs(36,3) themrel(12,3) yoink=1

gets the ensuing RING from NE

    49.462 0/pNE10-PINIT -> PINIT
    49.462 0/pNE10-PINIT p@(36,3)+4
    49.462 0/pNE10-PINIT NE CS_BOUND -> CS_RUNG
    49.462 0/pNE10-PINIT -> PRESOLVE

gets to passiveWinsYoinkRace

    7340.636 0/t  Failed to top: src/T2EventWindow.cpp:243: NULL_POINTER [3]

And blows up.

    7342.789 0/t  Total events completed = 589553
    t2@beaglebone:~/MFM/src/drivers/mfmt2$

:154]
[155:

Mon Jun 22 06:32:26 2020 So, wow!  We had three of these beins going
at once across three tiles, for a fair amount of time before anything
blew up.  And it blew up just because trySendNAK is currently
de-implemented.  Can we work on that a little bit?  [156:

Mon Jun 22 07:03:27 2020 Well, re-implementing it doesn't seem too
hard, but do we have any clue how to handle it when it arrives?[157:

Mon Jun 22 07:04:37 2020 T2ITC::handleDropPacket is also
de-implemented.  Let's go there.

:157]

:156]

:155]
[158:

Mon Jun 22 07:39:03 2020 So now in T2ActiveEventWIndow::handleBusy.
The idea is we'll iterate over the circuits and decide what to do with
each one?  I guess we'll unbind each one, but first we check if it's
state CS_ANSWERED, and if it is, we'll send a DROP first?

I guess we put the matching circuit into CS_DECLINED.  For the other
circuit, if there is one:

 CS <= CS_BOUND, do nothing
 CS <= CS_ANSWERED, send DROP and go to CS_DROPPED

[159:

Mon Jun 22 13:50:19 2020 Well, apparently needed some sleep.

So, thinking a key to this may be having aEW go into some
as-yet-unnamed state where it just soaks up packets aimed at it, and
waits for a timeout, at which point it frees itself.

It's like, once again, the phone company, which (at least previously)
used to let phone numbers lay fallow for a while after customers gave
them up, to help minimize calls to new customers from people looking
for the old customer.

So if a blown-up aEW goes into state AFALLOW (or whatever) for a
while, then we can worry less about prior ANSWERs or BUSYs arriving
late and getting misinterpreted by a fresh-start use of this aEW now.

That would help justify us sending a DROP on the active side even if a
circuit is just RUNG rather than answered.  If aEW is going AFALLOW
after sending the DROP anyway, any subsequent ANSWER or BUSY arriving
from passive side(s) while 'fall on deaf ears' anyway.

So the idea is:

 - To abort an active EW, due to a BUSY, and possibly other
   conditions, we'll see:

 - First, send a DROP on all bound circuits, except for cases where we
   can be pretty sure it's unnecessary -- like when we're aborting
   BECAUSE of a BUSY on a particular bound circuit.

 - Then, unhog the sites, mark the aEW as not having sites (however we
   do that).

 - Then go to state AFALLOW, with a timeout of perhaps 100ms or so.
   This ties up the aEW and prevents it from being reallocated.

 - During AFALLOW, any ANSWER, BUSY, or HANGUP packets to it are
   silently ignored.

 - Upon timeout AFALLOW, the aEW is just returned to the free pool.
   Since it didn't have any sites anyway, nothing else need be done.
[160:

Mon Jun 22 14:24:05 2020 Instead of AFALLOW, would it be too too
stupid to call it AWHILE ??[161:

Mon Jun 22 14:25:47 2020 Actually, why can't we use the existing ADROP
for this?  The ADROP description is "finish NAKed event", which seems
pretty close.  Are we actually going into ADROP anywhere, so far?[162:

Mon Jun 22 14:31:04 2020 T2ActiveEventWindow::dropActiveEW puts us
into ADROP, after (deterministically) unhogging sites.  Timeout and
receive ADROP are both INCOMPLETE_CODE.

So that code seems to be implying that being in state ADROP *means*
we're an active window that has given up its sites...

[163:

Mon Jun 22 14:34:56 2020 Note we also have T2EventWindow::abortEW(),
which calls finalizeEW() and then puts it back on the tile's EW free
list.  And finalizeEW() just resets EW data members internally, as far
as I can tell.  In particular, it doesn't unhog sites.  If we were
REALLY REALLY sure than an in-use aEW would ALWAYS HAVE SITES except
when it was in ADROP, we could have finalizeEW unhog on non-ADROP
states?

Who is currently calling unhog?[164: Mon Jun 22 14:45:45 2020

 - T2ActiveEventWindow::commitAndReleaseActive calls unhog, before
   calling mTile.releaseActiveEW which, among other things, calls
   finalizeEW.

 - T2ActiveEventWindow::dropActiveEW calls unhog, before setting the
   state to ADROP.

 - T2PassiveEventWindow::commitPassiveEWAndHangUp calls unhog, before
   calling initializeEW and going to state PINIT.

So that's like (1) unhog on active success, (2) unhog on active
failure, and (3) unhog on passive success.

And obviously the missing case is unhog on passive failure, which
would happen, at least, when a DROP packet arrives.  A difference is
we don't think we need or want a passive fallow period, so there's no
need for the pEW to block after giving up its sites.

But I guess it would be sensible to have a dropPassiveEW() to call.

:164]

  :163]

:162]

:161]

:160]

:159]
:158]
[165:

Mon Jun 22 16:00:00 2020 Well, tearing out ALL the T2EW::receive
handlers, because we're really not using them and they are just
confusing me.  So now the 'CUSRC' XX arg is always 0 for
ALL_EW_STATES_MACRO.  Rebuilding to see where we are.

:165]
[166:

Mon Jun 22 16:37:00 2020 OK commiting some flails towards sending and
handling BUSY and DROP.

:166]
[167:

Mon Jun 22 20:08:21 2020 Making progress but really running out of
time here.  We have our first full-on genuine yoink race here, leading
to revealing another bug (which we think we just fixed).

Thinly annotated --

    73.568 0/a27-IDLE -> AINIT
    73.568 0/a27-AINIT a@(51,5)+4
    73.568 0/a27-AINIT ET CS_UNUSED -> CS_BOUND
    73.568 0/a27-AINIT NE CS_UNUSED -> CS_BOUND
    73.569 0/lDBG a27/AINIT sites available
    73.569 0/lDBG a27/AINIT OWNING (51,5)+4

0/a27 starts up in the NE corner, binding both ET and NE.

    73.569 0/lDBG a27/AINIT RING NE abs(51,5) usrel(27,1) yoink=0
    73.571 0/iNE:OPEN >NE:RING#27(27,1)+4e +5
    73.571 0/a27-AINIT NE CS_BOUND -> CS_RUNG
    73.571 0/a27-AINIT -> AWLOCKS

0/a27 rings NE and starts to wait.

    73.657         1/lDBG a02/ABEHAVE (23,24)BEIN ngb 7 live 1
    73.657         1/lDBG a02/ABEHAVE FREEING (23,24)+4
    73.657         1/a02-ABEHAVE -> IDLE
    73.657         1/a20-IDLE -> AINIT
    73.657         1/a20-AINIT a@(27,35)+4

A moment later, 1/a02 starts up an event way down in the south of 1/

    73.657         1/a20-AINIT SE CS_UNUSED -> CS_BOUND
    73.657         1/a20-AINIT SW CS_UNUSED -> CS_BOUND

Involving SE and SW

    73.658         1/lDBG a20/AINIT sites available
    73.658         1/lDBG a20/AINIT OWNING (27,35)+4
    73.658         1/lDBG a20/AINIT RING SW abs(27,35) usrel(27,3) yoink=0
    73.666         1/iSW:OPEN >SW:RING#20(27,3)+4e +5
    73.666         1/a20-AINIT SW CS_BOUND -> CS_RUNG
    73.666         1/a20-AINIT -> AWLOCKS

1/a02 rings SW and starts to wait.

    73.669 0/iNE:OPEN <NE:RING#20(27,3)+4e +5

0/iNE picks up the ring from 1/a20!

    73.669 0/lDBG ITC/NE:OPEN: HRP abs(51,3) themrel(27,3) yoink=0
    73.669 0/pNE20-PINIT -> PINIT
    73.669 0/pNE20-PINIT p@(51,3)+4
    73.669 0/pNE20-PINIT NE CS_BOUND -> CS_RUNG
    73.669 0/pNE20-PINIT -> PRESOLVE

It inits 0/pNE20 and goes to resolve races

    73.669 0/lDBG u a27/AWLOCKS (51,5); t p20NE/PRESOLVE (51,3): YOINK ITC/NE:OPEN(Fred) us0 them0 -> we win

A Race is Detected!

It's our 0/a27 vs their 1/a20 (represented by 0/pNE20)!

The Yoink Protocol is Activated!  Our 0/a27 wins!

    73.669 0/lDBG p20NE/PRESOLVE BUSYed by a27/AWLOCKS
    73.671         1/iSE:SHUT >iSE:SHUT?6686D6B3  +6
    73.671 0/iNE:OPEN >NE:BUSY#20 +2

So a BUSY (lock rejected) packet is sent back toward 1/a20

    73.671 0/pNE20-PRESOLVE -> IDLE
    73.671 0/lDBG Passive cn 20 released

And 0/pNE20 is freed.

    73.673 0/iNW:SHUT <iNW:SHUT?6686D6B3  +6
    73.673 0/iNW:SHUT -> DRAIN
    73.675 0/iNW:DRAIN >iNW:DRAIN +2
    73.680         1/iSE:SHUT <iSE:DRAIN +2
    73.680         1/iSE:SHUT -> DRAIN
    73.682         1/iSE:DRAIN >iSE:DRAIN +2
    73.685         1/iSW:OPEN <SW:RING#27(27,1)+4e +5
    73.685         1/lDBG ITC/SW:OPEN: HRP abs(27,37) themrel(27,1) yoink=0
    73.685         1/pSW27-PINIT -> PINIT

Meanwhile, 1/iSW picks up the ring from 0/a27, initting 1/pSW27 to
handle it locally.

    73.685         1/pSW27-PINIT p@(27,37)+4
    73.685         1/pSW27-PINIT SW CS_BOUND -> CS_RUNG
    73.685         1/pSW27-PINIT -> PRESOLVE
    73.685         1/lDBG u a20/AWLOCKS (27,35); t p27SW/PRESOLVE (27,37): YOINK ITC/SW:OPEN(Ginger) us0 them0 -> they win

And it detects the race too!

Now it's our 1/a20 vs their 0/a27 (our 1/pSW27)!

And the Yoink Protocol says that they win!

    73.685         1/a20-AWLOCKS -> ADROP

So we start to drop our own 1/a20

    73.688         1/iSW:OPEN >SW:ANSWER#27 +2
    73.688         1/pSW27-PRESOLVE SW CS_RUNG -> CS_ANSWERED

And we ANSWER to grant the lock to 0/a27

    73.690         1/iSW:OPEN <SW:BUSY#20 +2

Then the BUSY from 0/iNE arrives at 1/iSW for 1/a20

    73.690         1/lDBG ITC/SW:OPEN: Enter hBP
    73.690         1/lDBG a20/ADROP hBUSY ITC/SW:OPEN
    73.690         1/lDBG a20/ADROP Not AWLOCKS, ignoring BUSY

But 1/a20 is already yoinked to ADROP, so the BUSY is not news.

    73.770 0/iNW:DRAIN -> CACHEXG
    73.777 0/iNE:OPEN <NE:ANSWER#27 +2

And then the ANSWER arrives at 0/iNE for 0/a27

    73.777 0/lDBG ITC/NE:OPEN: Enter HAP
    73.777 0/a27-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    73.778 0/lDBG ITC/NE:OPEN a27/AWLOCKS HAP
    73.778 0/lDBG a27/AWLOCKS hANSWER ITC/NE:OPEN
    73.779 0/iNW:CACHEXG <iNW:DRAIN +2
    73.779 0/iNW:CACHEXG -> SHUT
    73.781 0/a27-AWLOCKS -> ABEHAVE
    73.781 0/lDBG a27/ABEHAVE (51,5)BEIN ngb 2 live 1

And 0/a27 moves on to behave.

    73.781 0/a27-ABEHAVE -> ASCACHE
    73.781 0/lDBG SHIP#0 sn2 (51,4) tt 0xFFFF wt 0x0001
    73.781 0/lDBG SHIP#1 sn0 (51,5) tt 0x0001 wt 0xFFFF
    73.788 0/iNE:OPEN >NE:TALK#27 +29
    73.788 0/a27-ASCACHE -> AWACKS

Ships the update, and settles down to wait for acks

    73.790 0/iNW:SHUT >iNW:SHUT?274D8A08  +6
    73.869         1/iSE:DRAIN -> SHUT
    73.878         1/iSW:OPEN <SW:TALK#27 +29
    73.878         1/lDBG ITC/SW:OPEN: Enter HCUP

And 1/pSW27 goes to handle it.  But that died because we forgot to
change 1/pSW27's state to EWSN_PCACHE when we shipped the answer.

    #0  MFMLongJmpHere (buffer=0xbefff6b0, toThrow=4) at src/FailPlatformSpecific.cpp:48
    48          longjmp(buffer,toThrow);
    (gdb) up
    #1  0x00463a28 in MFM::T2ITC::handleCacheUpdatesPacket (this=0x4dcde8 <MFM::T2Tile::get()::THE_INSTANCE+3280>,
        pb=...) at src/T2ITC.cpp:279
    279         MFM_API_ASSERT_STATE(passiveEW.getEWSN() == EWSN_PWCACHE);
    (gdb) p passiveEW.getEWSN()
    $12 = MFM::EWSN_PRESOLVE
    (gdb)

[168:

Mon Jun 22 20:53:33 2020 But we've now made a fix for that.
Committing and going again.

:168]

:167]
[169:

Tue Jun 23 03:15:23 2020 (Took a break to update the web site for our
501(c)(3) status.)  So now we're dying here:

    (gdb) up
    #1  0x004746c0 in MFM::T2PassiveEventWindow::handleDrop (this=0x5b06f8, itc=...) at src/T2EventWindow.cpp:292
    292	      FAIL(ILLEGAL_STATE);
    (gdb) l
    287	  }
    288
    289	  void T2PassiveEventWindow::handleDrop(T2ITC & itc) {
    290	    TLOG(DBG,"%s: handleDrop", getName());
    291	    if (getEWSN() <= EWSN_PINIT) { // What is best predicate here??
    292	      FAIL(ILLEGAL_STATE);
    293	    }

with the trace ending up like

    379.328 0/iNE:OPEN <NE:DROP#1 +2
    379.328 0/lDBG ITC/NE:OPEN: Enter hDP
    379.328 0/lDBG pNE01-PINIT: handleDrop
    t2@beaglebone:~/MFM/src/drivers/mfmt2$

and looking at the neighboring tile's trace:

    106.857 0/iSW:OPEN <SW:BUSY#1 +2

BUSY from SW

    106.857 0/lDBG ITC/SW:OPEN: Enter hBP
    106.857 0/lDBG a01-AWLOCKS hBUSY ITC/SW:OPEN
    106.859 0/iSW:OPEN >SW:DROP#1 +2

DROP back to SW??

    106.859 0/a01-AWLOCKS SE CS_ANSWERED -> CS_DROPPED
    106.859 0/a01-AWLOCKS -> ADROP

I suspect what happened is this second guy sent a DROP back in
response to the source of a BUSY, and it shouldn't do that, because
the passive guy reinits after it sends the BUSY..[170:

Tue Jun 23 03:51:38 2020 And yes that was my stupidity of course as
well:

    --- a/src/drivers/mfmt2/src/T2EventWindow.cpp
    +++ b/src/drivers/mfmt2/src/T2EventWindow.cpp
    @@ -146,7 +146,7 @@ namespace MFM {
             if (&thisITC != &itc) {
               TLOG(DBG,"%s sending drop thisITC %p vs itc %p",
                    getName(), &thisITC, &itc);
    -          trySendDropVia(itc);
    +          trySendDropVia(thisITC);
             }
             ci.setCS(CS_DROPPED);
           }

I VERY CAREFULLY CHECKED that itc I was considering (thisITC) was
different than the one the BUSY came in on.. and then I sent the DROP
to the one the BUSY came in on..  Smoove Dave smoove.

:170]

:169]
[171:

Wed Jun 24 04:06:14 2020 OK, so T2sday update #279 is out.

Aaand where were we, here?

[172:

Wed Jun 24 04:07:48 2020 Well, we blew up in T2ITC::handleRingPacket,
because the targeted passiveEW was in state PWCACHE instead of PINIT.

And we had not yet figured out how that happened.[173:

Wed Jun 24 11:22:14 2020 Let's try to capture another instance, just
on two tiles to keep things simpler..[174:

Wed Jun 24 11:29:09 2020 Didn't take long once started..

:174]

:173]

:172]

:171]
[175:

Wed Jun 24 22:10:50 2020 Well so after the evening break.

Here, I merged this files for this failure, which is another case
where an inbound ring packet goes a pEW -- in this case, 0/pNW30 --
that's in state EWSN_PWCACHE instead of EWSN_PINIT.  Question is: Why
is 0/pNW30 in that state?

So, this is using the same connectivity as the last few cases:

         ........ribbon.cable..
        .                      .
        .  +-----------+       .
        .  |     1/    |       .
        .  |   'BLUE'  |       .
        .  |SW       SE|       .
        .  +||-------||+       .
        .   .       +||-------||+
         ...        |NW       NE|
                    |   'RED'   |
                    |    0/     |
                    +-----------+


    t2@beaglebone:~/MFM/src/drivers/mfmt2$ ../../../bin/Weaver ~/FILEDIR/202006242212-RED-t2trace221.dat ~/FILEDIR/202006242212-BLUE-t2trace221.dat
    11: MSG: WP 0
    12: MSG: WM 0
    0/ /home/t2/FILEDIR/202006242212-RED-t2trace221.dat: Wed Jun 24 11:28:08 2020
    1/ /home/t2/FILEDIR/202006242212-BLUE-t2trace221.dat: Wed Jun 24 11:28:13 2020
    0/ -> 1/ n=44, s=-214.904093, ss=1049.631116, avg=-4.884184, var=23.855253
    1/ -> 0/ n=44, s=214.904093, ss=1049.631116, avg=4.884184, var=23.855253
    Anchor file is 0/
    TWEAKING n1 0.000000
    0/ 0ms
    1/ 4s 884ms
    0.000 0/t  Trace Format Version 5
 ..
    30.484         1/a31-IDLE -> AINIT

Well, I'm not sure if this is really where the whole megillah
'begins' (I've extended backwards from the scene of the failure a
couple of times now, trying to annotate this trace).  But let's find
out.

So 1/a31 starts up at (27,34), deep in SE+SW territory.  Note also
that ANOTHER player in our story -- 1/a30 -- is ALSO going to start up
at THE EXACT SAME SITE, (27,34), SOON!

    30.484         1/a31-AINIT a@(27,34)+4
    30.484         1/a31-AINIT SE CS_UNUSED -> CS_BOUND
    30.484         1/a31-AINIT SW CS_UNUSED -> CS_BOUND
    30.484         1/lDBG a31-AINIT sites available
    30.484         1/lDBG a31-AINIT OWNING (27,34)+4
    30.484         1/lDBG a31-AINIT RING SE abs(27,34) usrel(3,2) yoink=1

1/a31 gets ready to send a RING on SE.

    30.490 0/a18-IDLE -> AINIT
    30.491 0/a18-AINIT a@(31,12)+4
    30.491 0/lDBG a18-AINIT sites available
    30.491 0/lDBG a18-AINIT OWNING (31,12)+4
    30.491 0/a18-AINIT -> ABEHAVE
    30.492 0/a19-IDLE -> AINIT

0/a18 starts up, has a hidden event, and finishes, just like that.

    30.492 0/a19-AINIT a@(4,4)+4
    30.492 0/a19-AINIT WT CS_UNUSED -> CS_BOUND
    30.492 0/a19-AINIT NW CS_UNUSED -> CS_BOUND

0/a19 starts up in the absolute extreme far NE+NW.  Not sure if this
will be significant in the story or not.

    30.492         1/iSE:OPEN >SE:RING#31(3,2)+4o +5

The 1/a31 RING to SE actually ships.

    30.492         1/a31-AINIT SE CS_BOUND -> CS_RUNG
    30.492         1/lDBG a31-AINIT RING SW abs(27,34) usrel(27,2) yoink=0
    30.493 0/lDBG a19-AINIT sites available
    30.493 0/lDBG a19-AINIT OWNING (4,4)+4
    30.493 0/lDBG a19-AINIT RING NW abs(4,4) usrel(4,0) yoink=0

0/a19

    30.499         1/iSW:OPEN >SW:RING#31(27,2)+4e +5
    30.499         1/a31-AINIT SW CS_BOUND -> CS_RUNG
    30.499         1/a31-AINIT -> AWLOCKS
    30.501         1/iSE:OPEN <SE:RING#19(4,0)+4e +5
    30.501         1/lDBG ITC/SE:OPEN: HRP abs(28,36) themrel(4,0) yoink=0
    30.501         1/pSE19-PINIT -> PINIT
    30.501         1/pSE19-PINIT p@(28,36)+4
    30.501         1/pSE19-PINIT SE CS_BOUND -> CS_RUNG
    30.501         1/pSE19-PINIT -> PRESOLVE
    30.501         1/lDBG u a31-AWLOCKS (27,34); t pSE19-PRESOLVE (28,36): YOINK ITC/SE:OPEN(Fred) us1 them0 -> they win
    30.502         1/a31-AWLOCKS -> ADROP
    30.502         1/pSE19-PRESOLVE -> PWCACHE
    30.503 0/iNW:OPEN >NW:RING#19(4,0)+4e +5
    30.503 0/a19-AINIT NW CS_BOUND -> CS_RUNG
    30.503 0/a19-AINIT -> AWLOCKS
    30.504 0/lDBG a18-ABEHAVE (31,12)BEIN ngb 1 live 1
    30.504 0/lDBG a18-ABEHAVE FREEING (31,12)+4
    30.504 0/a18-ABEHAVE -> IDLE
    30.506 0/iNE:OPEN <NE:RING#31(27,2)+4e +5
    30.506 0/lDBG ITC/NE:OPEN: HRP abs(51,2) themrel(27,2) yoink=0
    30.507 0/pNE31-PINIT -> PINIT
    30.507 0/pNE31-PINIT p@(51,2)+4
    30.507 0/pNE31-PINIT NE CS_BOUND -> CS_RUNG
    30.507 0/pNE31-PINIT -> PRESOLVE
    30.507 0/pNE31-PRESOLVE -> PWCACHE
    30.508         1/iSE:OPEN >SE:ANSWER#19 +2
    30.508         1/pSE19-PWCACHE SE CS_RUNG -> CS_ANSWERED
    30.511         1/iSW:OPEN <SW:ANSWER#31 +2
    30.511         1/lDBG ITC/SW:OPEN: Enter HAP
    30.511         1/a31-ADROP SW CS_RUNG -> CS_ANSWERED
    30.511         1/lDBG ITC/SW:OPEN a31-ADROP HAP
    30.511         1/lWRN ITC/SW:OPEN HAP bad aew state a31-ADROP for cn 31
    30.512         1/a31-ADROP SE CS_RUNG -> CS_UNUSED
    30.512         1/a31-ADROP SW CS_ANSWERED -> CS_UNUSED
    30.512         1/a31-ADROP -> IDLE
    30.513         1/a31-IDLE -> AINIT
    30.513         1/a31-AINIT a@(51,25)+4
    30.513         1/a31-AINIT ET CS_UNUSED -> CS_BOUND
    30.515 0/iNE:OPEN >NE:ANSWER#31 +2
    30.515 0/pNE31-PWCACHE NE CS_RUNG -> CS_ANSWERED
    30.517         1/lDBG a31-AINIT sites available
    30.517         1/lDBG a31-AINIT OWNING (51,25)+4
    30.517         1/a31-AINIT -> ABEHAVE
    30.517 0/iNW:OPEN <NW:RING#31(3,2)+4o +5
    30.517 0/lDBG ITC/NW:OPEN: HRP abs(3,2) themrel(3,2) yoink=1
    30.517 0/pNW31-PINIT -> PINIT
    30.517 0/pNW31-PINIT p@(3,2)+4
    30.517 0/pNW31-PINIT NW CS_BOUND -> CS_RUNG
    30.517 0/pNW31-PINIT -> PRESOLVE
    30.518 0/lDBG u a19-AWLOCKS (4,4); t pNW31-PRESOLVE (3,2): YOINK ITC/NW:OPEN(Ginger) us0 them1 -> we win
    30.518 0/lDBG RRFP-2 pNW31-PRESOLVE BUSYed by a19-AWLOCKS
    30.520         1/iSE:OPEN <SE:BUSY#31 +2
    30.520         1/lDBG ITC/SE:OPEN: Enter hBP
    30.520 0/iNW:OPEN >NW:BUSY#31 +2
    30.520         1/lDBG a31-ABEHAVE hBUSY ITC/SE:OPEN
    30.520 0/pNW31-PRESOLVE -> PINIT
    30.520         1/lDBG a31-ABEHAVE Not AWLOCKS, ignoring BUSY
    30.520 0/lDBG Passive cn 31 released
    30.521         1/lDBG a31-ABEHAVE (51,25)BEIN ngb 4 live 0
    30.521         1/lDBG a31-ABEHAVE (51,25)BEIN oth 8 (othlive 0)
    30.521         1/lDBG a31-ABEHAVE FREEING (51,25)+4
    30.521         1/a31-ABEHAVE ET CS_BOUND -> CS_UNUSED
    30.521         1/a31-ABEHAVE -> IDLE
    30.522         1/a30-IDLE -> AINIT
    30.522         1/a30-AINIT a@(13,34)+4
    30.522         1/a30-AINIT SW CS_UNUSED -> CS_BOUND
    30.522         1/lDBG a30-AINIT sites available
    30.522         1/lDBG a30-AINIT OWNING (13,34)+4
    30.522         1/lDBG a30-AINIT RING SW abs(13,34) usrel(13,2) yoink=0
    30.525         1/iSW:OPEN >SW:RING#30(13,2)+4e +5
    30.525         1/a30-AINIT SW CS_BOUND -> CS_RUNG
    30.525         1/a30-AINIT -> AWLOCKS
    30.525 0/iNW:OPEN <NW:ANSWER#19 +2
    30.525 0/lDBG ITC/NW:OPEN: Enter HAP
    30.525 0/a19-AWLOCKS NW CS_RUNG -> CS_ANSWERED
    30.525 0/lDBG ITC/NW:OPEN a19-AWLOCKS HAP
    30.525 0/lDBG a19-AWLOCKS hANSWER ITC/NW:OPEN
    30.532 0/a19-AWLOCKS -> ABEHAVE
    30.534 0/iNE:OPEN <NE:RING#30(13,2)+4e +5
    30.534 0/lDBG ITC/NE:OPEN: HRP abs(37,2) themrel(13,2) yoink=0
    30.534 0/pNE30-PINIT -> PINIT
    30.534 0/pNE30-PINIT p@(37,2)+4
    30.534 0/pNE30-PINIT NE CS_BOUND -> CS_RUNG
    30.534 0/pNE30-PINIT -> PRESOLVE
    30.535 0/pNE30-PRESOLVE -> PWCACHE
    30.538 0/iNE:OPEN >NE:ANSWER#30 +2
    30.538 0/pNE30-PWCACHE NE CS_RUNG -> CS_ANSWERED
    30.538 0/lDBG a19-ABEHAVE (4,4)BEIN ngb 2 live 1
    30.538 0/a19-ABEHAVE -> ASCACHE
    30.687         1/iSW:OPEN <SW:ANSWER#30 +2
    30.687         1/lDBG ITC/SW:OPEN: Enter HAP
    30.687         1/a30-AWLOCKS SW CS_RUNG -> CS_ANSWERED
    30.687         1/lDBG ITC/SW:OPEN a30-AWLOCKS HAP
    30.687         1/lDBG a30-AWLOCKS hANSWER ITC/SW:OPEN
    30.687         1/a11-IDLE -> AINIT
    30.687         1/a11-AINIT a@(28,25)+4
    30.688         1/lDBG a11-AINIT sites available
    30.688         1/lDBG a11-AINIT OWNING (28,25)+4
    30.688         1/a11-AINIT -> ABEHAVE
    30.688         1/a30-AWLOCKS -> ABEHAVE
    30.688         1/lDBG a30-ABEHAVE (13,34)BEIN ngb 7 live 1
    30.688         1/a30-ABEHAVE -> ASCACHE
    30.691 0/lDBG SHIP#0 sn2 (4,3) tt 0xFFFF wt 0x0001
    30.691 0/lDBG SHIP#1 sn0 (4,4) tt 0x0001 wt 0xFFFF
    30.692         1/lDBG a11-ABEHAVE (28,25)BEIN ngb 2 live 1
    30.692         1/lDBG a11-ABEHAVE FREEING (28,25)+4
    30.692         1/a11-ABEHAVE -> IDLE
    30.692         1/lDBG SHIP#0 sn7 (14,33) tt 0xFFFF wt 0x0001
    30.692         1/lDBG SHIP#1 sn0 (13,34) tt 0x0001 wt 0xFFFF
    30.699         1/iSW:OPEN >SW:TALK#30 +29
    30.699         1/a30-ASCACHE -> AWACKS
    30.701 0/iNW:OPEN >NW:TALK#19 +29
    30.701 0/a19-ASCACHE -> AWACKS
    30.702         1/iSE:OPEN <SE:TALK#19 +29
    30.702         1/lDBG ITC/SE:OPEN: Enter HCUP
    30.702         1/pSE19-PWCACHE SE CS_ANSWERED -> CS_TALKED
    30.702         1/lDBG pSE19-PWCACHE CUPSN#2 mLastSN 40
    30.702         1/lDBG RECV#0 sn2 (28,35) tt 0xFFFF wt 0x0001
    30.702         1/lDBG pSE19-PWCACHE CUPSN#0 mLastSN 40
    30.702         1/lDBG RECV#1 sn0 (28,36) tt 0x0001 wt 0xFFFF
    30.702         1/lDBG pSE19-PWCACHE CUPSN#255 mLastSN 40
    30.702         1/lDBG pSE19-PWCACHE (C_TALKED(pSE19-PWCACHExITC/SE:OPEN)) cPEWAHU
    30.709         1/iSE:OPEN >SE:HANGUP#19 +2
    30.709         1/pSE19-PWCACHE -> PINIT
    30.709         1/lDBG pSE19-PINIT PASSIVE DONE
    30.715 0/iNE:OPEN <NE:TALK#30 +29
    30.715 0/lDBG ITC/NE:OPEN: Enter HCUP
    30.715 0/pNE30-PWCACHE NE CS_ANSWERED -> CS_TALKED
    30.715 0/lDBG pNE30-PWCACHE CUPSN#7 mLastSN 40
    30.715 0/lDBG RECV#0 sn7 (38,1) tt 0xFFFF wt 0x0001
    30.715 0/lDBG pNE30-PWCACHE CUPSN#0 mLastSN 40
    30.715 0/lDBG RECV#1 sn0 (37,2) tt 0x0001 wt 0xFFFF
    30.715 0/lDBG pNE30-PWCACHE CUPSN#255 mLastSN 40
    30.715 0/lDBG pNE30-PWCACHE (C_TALKED(pNE30-PWCACHExITC/NE:OPEN)) cPEWAHU
    30.721 0/iNE:OPEN >NE:HANGUP#30 +2
    30.722 0/pNE30-PWCACHE -> PINIT
    30.722 0/lDBG pNE30-PINIT PASSIVE DONE
    30.724 0/iNW:OPEN <NW:HANGUP#19 +2
    30.724 0/lDBG ITC/NW:OPEN: Enter HUP
    30.724 0/a19-AWACKS NW CS_ANSWERED -> CS_UNUSED
    30.724 0/lDBG a19-AWACKS hHU ITC/NW:OPEN
    30.724 0/a19-AWACKS WT CS_BOUND -> CS_UNUSED
    30.724 0/lDBG a19-AWACKS FREEING (4,4)+4
    30.724 0/a19-AWACKS -> IDLE
    30.886         1/a08-IDLE -> AINIT
    30.886         1/a08-AINIT a@(28,24)+4
    30.886         1/lDBG a08-AINIT sites available
    30.886         1/lDBG a08-AINIT OWNING (28,24)+4
    30.887         1/a08-AINIT -> ABEHAVE
    30.894         1/iSW:OPEN <SW:HANGUP#30 +2
    30.895         1/lDBG ITC/SW:OPEN: Enter HUP
    30.895         1/a30-AWACKS SW CS_ANSWERED -> CS_UNUSED
    30.895         1/lDBG a30-AWACKS hHU ITC/SW:OPEN
    30.895         1/lDBG a30-AWACKS FREEING (13,34)+4
    30.895         1/a30-AWACKS -> IDLE
    30.899 0/a10-IDLE -> AINIT
    30.899 0/a10-AINIT a@(30,12)+4
    30.899 0/lDBG a10-AINIT sites available
    30.899 0/lDBG a10-AINIT OWNING (30,12)+4
    30.900 0/a10-AINIT -> ABEHAVE
    30.910 0/lDBG a10-ABEHAVE (30,12)BEIN ngb 1 live 1
    30.910 0/lDBG a10-ABEHAVE FREEING (30,12)+4
    30.910 0/a10-ABEHAVE -> IDLE

    30.921 0/a15-IDLE -> AINIT
    30.921 0/a15-AINIT a@(4,5)+4

0/a15 starts up off in the NW+WT hinterlands.  WT is SHUT, but NW is
OPEN.

    30.921 0/a15-AINIT WT CS_UNUSED -> CS_BOUND
    30.921 0/a15-AINIT NW CS_UNUSED -> CS_BOUND
    30.922 0/lDBG a15-AINIT sites available
    30.922 0/lDBG a15-AINIT OWNING (4,5)+4
    30.922 0/lDBG a15-AINIT RING NW abs(4,5) usrel(4,1) yoink=1
    30.931 0/iNW:OPEN >NW:RING#15(4,1)+4o +5

0/a15 sends a RING on NW

    30.931 0/a15-AINIT NW CS_BOUND -> CS_RUNG
    30.931 0/a15-AINIT -> AWLOCKS

and awaits developments.

    30.940 0/a29-IDLE -> AINIT
    30.940 0/a29-AINIT a@(33,9)+4

0/a29 also starts up, in the central NE/NW region.  Needs two locks.

    30.940 0/a29-AINIT NE CS_UNUSED -> CS_BOUND
    30.940 0/a29-AINIT NW CS_UNUSED -> CS_BOUND
    30.940 0/lDBG a29-AINIT sites available
    30.940 0/lDBG a29-AINIT OWNING (33,9)+4
    30.940 0/lDBG a29-AINIT RING NE abs(33,9) usrel(9,5) yoink=0
    30.943 0/iNE:OPEN >NE:RING#29(9,5)+4e +5

0/a29 rings on NE

    30.943 0/a29-AINIT NE CS_BOUND -> CS_RUNG
    30.943 0/lDBG a29-AINIT RING NW abs(33,9) usrel(33,5) yoink=0
    30.951 0/iNW:OPEN >NW:RING#29(33,5)+4e +5

0/a29 rings on NW

    30.951 0/a29-AINIT NW CS_BOUND -> CS_RUNG
    30.951 0/a29-AINIT -> AWLOCKS

0/a29 sets down to wait

    30.951 0/a07-IDLE -> AINIT
    30.951 0/a07-AINIT a@(29,12)+4
    30.952 0/a07-AINIT -> IDLE

A few event attempts..

    30.984 0/a08-IDLE -> AINIT
    30.984 0/a08-AINIT a@(34,5)+4
    30.984 0/a08-AINIT NE CS_UNUSED -> CS_BOUND
    30.984 0/a08-AINIT NE CS_BOUND -> CS_UNUSED
    30.984 0/a08-AINIT -> IDLE

..fail to acquire..

    31.004 0/a00-IDLE -> AINIT
    31.004 0/a00-AINIT a@(29,12)+4
    31.004 0/a00-AINIT -> IDLE

..the sites they need..

    31.060 0/a11-IDLE -> AINIT
    31.060 0/a11-AINIT a@(29,12)+4
    31.061 0/a11-AINIT -> IDLE

..and end quickly.

    31.093         1/lDBG a08-ABEHAVE (28,24)BEIN ngb 2 live 1
    31.093         1/lDBG a08-ABEHAVE FREEING (28,24)+4
    31.094         1/a08-ABEHAVE -> IDLE

Over in 1/a08, a hidden event (that started way back at 30.886, in
part of the trace I clipped), finally gets a chance to finish up.

    31.094         1/a30-IDLE -> AINIT
    31.094         1/a30-AINIT a@(27,34)+4

1/a30 starts up deep in SW+SE territory

    31.094         1/a30-AINIT SE CS_UNUSED -> CS_BOUND
    31.094         1/a30-AINIT SW CS_UNUSED -> CS_BOUND
    31.095         1/lDBG a30-AINIT sites available
    31.095         1/lDBG a30-AINIT OWNING (27,34)+4
    31.095         1/lDBG a30-AINIT RING SE abs(27,34) usrel(3,2) yoink=1
    31.103         1/iSE:OPEN >SE:RING#30(3,2)+4o +5

1/a30 sends a RING on SE

    31.103         1/a30-AINIT SE CS_BOUND -> CS_RUNG
    31.103         1/lDBG a30-AINIT RING SW abs(27,34) usrel(27,2) yoink=0
    31.109         1/iSW:OPEN >SW:RING#30(27,2)+4e +5

and also on SW

    31.109         1/a30-AINIT SW CS_BOUND -> CS_RUNG
    31.109         1/a30-AINIT -> AWLOCKS

and then settles down to wait for developments.

    31.112         1/iSE:OPEN <SE:RING#15(4,1)+4o +5

Now, that ring from 0/a15, sent way back at 30.931, arrives at 1/iSE.

    31.112         1/lDBG ITC/SE:OPEN: HRP abs(28,37) themrel(4,1) yoink=1
    31.112         1/pSE15-PINIT -> PINIT
    31.112         1/pSE15-PINIT p@(28,37)+4

1/pSE15 sets up to handle it.

    31.112         1/pSE15-PINIT SE CS_BOUND -> CS_RUNG
    31.112         1/pSE15-PINIT -> PRESOLVE
    31.112         1/lDBG u a30-AWLOCKS (27,34); t pSE15-PRESOLVE (28,37): YOINK ITC/SE:OPEN(Fred) us1 them1 -> we win
    31.112         1/lDBG RRFP-2 pSE15-PRESOLVE BUSYed by a30-AWLOCKS

Ono a collision!  1/pSE15 at (28,37)+4 overlaps 1/a30 at (27,34)+4 !
And our active 1/a30 wins the yoink!  1/pSE15 is going to need to send
back a BUSY to 0/a15!  (But that hasn't happened yet.)

    31.115 0/iNE:OPEN <NE:RING#30(27,2)+4e +5
    31.115 0/lDBG ITC/NE:OPEN: HRP abs(51,2) themrel(27,2) yoink=0

Meanwhile, back on 0/iNE, the ring from 1/a30 has arrived

    31.115 0/pNE30-PINIT -> PINIT
    31.115 0/pNE30-PINIT p@(51,2)+4
    31.115 0/pNE30-PINIT NE CS_BOUND -> CS_RUNG

0/pNE30 sets up for it.

    31.115 0/pNE30-PINIT -> PRESOLVE
    31.116 0/lDBG RRFP-1 pNE30-PRESOLVE BUSYed by pNE31-PWCACHE



    31.116         1/iSE:OPEN >SE:BUSY#15 +2
    31.116         1/pSE15-PRESOLVE -> PINIT
    31.116         1/lDBG Passive cn 15 released
    31.122         1/iSE:OPEN <SE:RING#29(33,5)+4e +5
    31.122         1/lDBG ITC/SE:OPEN: HRP abs(57,41) themrel(33,5) yoink=0
    31.122         1/pSE29-PINIT -> PINIT
    31.122         1/pSE29-PINIT p@(57,41)+4
    31.122         1/pSE29-PINIT SE CS_BOUND -> CS_RUNG
    31.122         1/pSE29-PINIT -> PRESOLVE
    31.122         1/pSE29-PRESOLVE -> PWCACHE
    31.124         1/iSE:OPEN >SE:ANSWER#29 +2
    31.124         1/pSE29-PWCACHE SE CS_RUNG -> CS_ANSWERED
    31.125 0/iNE:OPEN >NE:BUSY#30 +2
    31.125 0/pNE30-PRESOLVE -> PINIT
    31.125 0/lDBG Passive cn 30 released
    31.127 0/iNW:OPEN <NW:RING#30(3,2)+4o +5
    31.127 0/lDBG ITC/NW:OPEN: HRP abs(3,2) themrel(3,2) yoink=1
    31.127 0/pNW30-PINIT -> PINIT
    31.127 0/pNW30-PINIT p@(3,2)+4
    31.127 0/pNW30-PINIT NW CS_BOUND -> CS_RUNG
    31.127 0/pNW30-PINIT -> PRESOLVE
    31.128 0/lDBG u a15-AWLOCKS (4,5); t pNW30-PRESOLVE (3,2): YOINK ITC/NW:OPEN(Ginger) us1 them1 -> they win
    31.128 0/a15-AWLOCKS -> ADROP
    31.128 0/pNW30-PRESOLVE -> PWCACHE
    31.129         1/iSW:OPEN <SW:RING#29(9,5)+4e +5
    31.129         1/lDBG ITC/SW:OPEN: HRP abs(9,41) themrel(9,5) yoink=0
    31.129         1/pSW29-PINIT -> PINIT
    31.129         1/pSW29-PINIT p@(9,41)+4
    31.129         1/pSW29-PINIT SW CS_BOUND -> CS_RUNG
    31.129         1/pSW29-PINIT -> PRESOLVE
    31.129         1/pSW29-PRESOLVE -> PWCACHE
    31.131 0/iNW:OPEN >NW:ANSWER#30 +2
    31.131 0/pNW30-PWCACHE NW CS_RUNG -> CS_ANSWERED
    31.132         1/iSW:OPEN >SW:ANSWER#29 +2
    31.132         1/pSW29-PWCACHE SW CS_RUNG -> CS_ANSWERED
    31.135         1/iSW:OPEN <SW:BUSY#30 +2
    31.135         1/lDBG ITC/SW:OPEN: Enter hBP
    31.135         1/lDBG a30-AWLOCKS hBUSY ITC/SW:OPEN
    31.135         1/a30-AWLOCKS -> ADROP
    31.138 0/iNW:OPEN <NW:BUSY#15 +2
    31.138 0/lDBG ITC/NW:OPEN: Enter hBP
    31.138 0/lDBG a15-ADROP hBUSY ITC/NW:OPEN
    31.138 0/lDBG a15-ADROP Not AWLOCKS, ignoring BUSY
    31.140 0/iNW:OPEN <NW:ANSWER#29 +2
    31.140 0/lDBG ITC/NW:OPEN: Enter HAP
    31.140 0/a29-AWLOCKS NW CS_RUNG -> CS_ANSWERED
    31.140 0/lDBG ITC/NW:OPEN a29-AWLOCKS HAP
    31.141 0/lDBG a29-AWLOCKS hANSWER ITC/NW:OPEN
    31.151 0/iNE:OPEN <NE:ANSWER#29 +2
    31.151 0/lDBG ITC/NE:OPEN: Enter HAP
    31.151 0/a29-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    31.151 0/lDBG ITC/NE:OPEN a29-AWLOCKS HAP
    31.151 0/lDBG a29-AWLOCKS hANSWER ITC/NE:OPEN
    31.151 0/a29-AWLOCKS -> ABEHAVE
    31.153 0/lDBG a29-ABEHAVE (33,9)BEIN ngb 1 live 1
    31.153 0/a29-ABEHAVE -> ASCACHE
    31.153 0/lDBG SHIP#0 sn1 (32,9) tt 0xFFFF wt 0x0001
    31.153 0/lDBG SHIP#1 sn0 (33,9) tt 0x0001 wt 0xFFFF
    31.156 0/iNE:OPEN >NE:TALK#29 +29
    31.156 0/lDBG SHIP#0 sn1 (32,9) tt 0xFFFF wt 0x0001
    31.156 0/lDBG SHIP#1 sn0 (33,9) tt 0x0001 wt 0xFFFF
    31.159 0/iNW:OPEN >NW:TALK#29 +29
    31.159 0/a29-ASCACHE -> AWACKS
    31.159 0/a10-IDLE -> AINIT
    31.159 0/a10-AINIT a@(29,12)+4
    31.160 0/a10-AINIT -> IDLE
    31.169 0/a05-IDLE -> AINIT
    31.169 0/a05-AINIT a@(34,5)+4
    31.169 0/a05-AINIT NE CS_UNUSED -> CS_BOUND
    31.169 0/a05-AINIT NE CS_BOUND -> CS_UNUSED
    31.169 0/a05-AINIT -> IDLE
    31.175 0/a10-IDLE -> AINIT
    31.176 0/a10-AINIT a@(34,5)+4
    31.176 0/a10-AINIT NE CS_UNUSED -> CS_BOUND
    31.176 0/a10-AINIT NE CS_BOUND -> CS_UNUSED
    31.176 0/a10-AINIT -> IDLE
    31.209 0/a21-IDLE -> AINIT
    31.209 0/a21-AINIT a@(34,5)+4
    31.209 0/a21-AINIT NE CS_UNUSED -> CS_BOUND
    31.209 0/a21-AINIT NE CS_BOUND -> CS_UNUSED
    31.210 0/a21-AINIT -> IDLE
    31.233 0/a11-IDLE -> AINIT
    31.233 0/a11-AINIT a@(29,12)+4
    31.233 0/a11-AINIT -> IDLE
    31.311         1/iSE:OPEN <SE:ANSWER#30 +2
    31.311         1/lDBG ITC/SE:OPEN: Enter HAP
    31.311         1/a30-ADROP SE CS_RUNG -> CS_ANSWERED
    31.311         1/lDBG ITC/SE:OPEN a30-ADROP HAP
    31.311         1/lWRN ITC/SE:OPEN HAP bad aew state a30-ADROP for cn 30
    31.314         1/a30-ADROP SE CS_ANSWERED -> CS_UNUSED
    31.314         1/a30-ADROP SW CS_RUNG -> CS_UNUSED
    31.314         1/a30-ADROP -> IDLE
    31.320 0/lDBG a15-ADROP fallow period ended, freeing
    31.320 0/a15-ADROP WT CS_BOUND -> CS_UNUSED
    31.320 0/a15-ADROP NW CS_RUNG -> CS_UNUSED
    31.320 0/a15-ADROP -> IDLE
    31.322         1/iSE:OPEN <SE:TALK#29 +29
    31.322         1/lDBG ITC/SE:OPEN: Enter HCUP
    31.322         1/pSE29-PWCACHE SE CS_ANSWERED -> CS_TALKED
    31.322         1/lDBG pSE29-PWCACHE CUPSN#1 mLastSN 40
    31.322         1/lWRN pSE29-PWCACHE sn1/(56,41) not accessible by ITC/SE:OPEN; ignored
    31.322         1/lDBG pSE29-PWCACHE CUPSN#0 mLastSN 40
    31.322         1/lWRN pSE29-PWCACHE sn0/(57,41) not accessible by ITC/SE:OPEN; ignored
    31.322         1/lDBG pSE29-PWCACHE CUPSN#255 mLastSN 40
    31.322         1/lDBG pSE29-PWCACHE (C_TALKED(pSE29-PWCACHExITC/SE:OPEN)) cPEWAHU
    31.325         1/iSE:OPEN >SE:HANGUP#29 +2
    31.325         1/pSE29-PWCACHE -> PINIT
    31.325         1/lDBG pSE29-PINIT PASSIVE DONE
    31.327         1/iSW:OPEN <SW:TALK#29 +29
    31.327         1/lDBG ITC/SW:OPEN: Enter HCUP
    31.327         1/pSW29-PWCACHE SW CS_ANSWERED -> CS_TALKED
    31.327         1/lDBG pSW29-PWCACHE CUPSN#1 mLastSN 40
    31.327         1/lWRN pSW29-PWCACHE sn1/(8,41) not accessible by ITC/SW:OPEN; ignored
    31.327         1/lDBG pSW29-PWCACHE CUPSN#0 mLastSN 40
    31.327         1/lWRN pSW29-PWCACHE sn0/(9,41) not accessible by ITC/SW:OPEN; ignored
    31.327         1/lDBG pSW29-PWCACHE CUPSN#255 mLastSN 40
    31.327         1/lDBG pSW29-PWCACHE (C_TALKED(pSW29-PWCACHExITC/SW:OPEN)) cPEWAHU
    31.331 0/iNW:OPEN <NW:HANGUP#29 +2
    31.331 0/lDBG ITC/NW:OPEN: Enter HUP
    31.331 0/a29-AWACKS NW CS_ANSWERED -> CS_UNUSED
    31.331 0/lDBG a29-AWACKS hHU ITC/NW:OPEN
    31.333         1/iSW:OPEN >SW:HANGUP#29 +2
    31.333         1/pSW29-PWCACHE -> PINIT
    31.333         1/lDBG pSW29-PINIT PASSIVE DONE
    31.339 0/iNE:OPEN <NE:HANGUP#29 +2
    31.339 0/lDBG ITC/NE:OPEN: Enter HUP
    31.339 0/a29-AWACKS NE CS_ANSWERED -> CS_UNUSED
    31.339 0/lDBG a29-AWACKS hHU ITC/NE:OPEN
    31.339 0/lDBG a29-AWACKS FREEING (33,9)+4
    31.340 0/a29-AWACKS -> IDLE
    31.353 0/a21-IDLE -> AINIT
    31.353 0/a21-AINIT a@(29,12)+4
    31.353 0/lDBG a21-AINIT sites available
    31.353 0/lDBG a21-AINIT OWNING (29,12)+4
    31.353 0/a21-AINIT -> ABEHAVE
    31.353 0/lDBG a21-ABEHAVE (29,12)BEIN ngb 1 live 1
    31.354 0/lDBG a21-ABEHAVE FREEING (29,12)+4
    31.354 0/a21-ABEHAVE -> IDLE
    31.373 0/a25-IDLE -> AINIT
    31.373 0/a25-AINIT a@(28,12)+4
    31.373 0/lDBG a25-AINIT sites available
    31.373 0/lDBG a25-AINIT OWNING (28,12)+4
    31.373 0/a25-AINIT -> ABEHAVE
    31.375 0/lDBG a25-ABEHAVE (28,12)BEIN ngb 1 live 1
    31.375 0/lDBG a25-ABEHAVE FREEING (28,12)+4
    31.375 0/a25-ABEHAVE -> IDLE
    31.384 0/a05-IDLE -> AINIT
    31.384 0/a05-AINIT a@(34,5)+4
    31.384 0/a05-AINIT NE CS_UNUSED -> CS_BOUND
    31.384 0/a05-AINIT NW CS_UNUSED -> CS_BOUND
    31.384 0/lDBG a05-AINIT sites available
    31.384 0/lDBG a05-AINIT OWNING (34,5)+4
    31.385 0/lDBG a05-AINIT RING NE abs(34,5) usrel(10,1) yoink=1
    31.387 0/iNE:OPEN >NE:RING#5(10,1)+4o +5
    31.387 0/a05-AINIT NE CS_BOUND -> CS_RUNG
    31.387 0/lDBG a05-AINIT RING NW abs(34,5) usrel(34,1) yoink=0
    31.390 0/iNW:OPEN >NW:RING#5(34,1)+4e +5
    31.390 0/a05-AINIT NW CS_BOUND -> CS_RUNG
    31.390 0/a05-AINIT -> AWLOCKS
    31.400 0/a23-IDLE -> AINIT
    31.400 0/a23-AINIT a@(27,12)+4
    31.401 0/lDBG a23-AINIT sites available
    31.401 0/lDBG a23-AINIT OWNING (27,12)+4
    31.401 0/a23-AINIT -> ABEHAVE
    31.401 0/lDBG a23-ABEHAVE (27,12)BEIN ngb 1 live 1
    31.401 0/lDBG a23-ABEHAVE FREEING (27,12)+4
    31.401 0/a23-ABEHAVE -> IDLE
    31.510         1/a16-IDLE -> AINIT
    31.511         1/a16-AINIT a@(27,34)+4
    31.511         1/a16-AINIT SE CS_UNUSED -> CS_BOUND
    31.511         1/a16-AINIT SW CS_UNUSED -> CS_BOUND
    31.511         1/lDBG a16-AINIT sites available
    31.511         1/lDBG a16-AINIT OWNING (27,34)+4
    31.511         1/lDBG a16-AINIT RING SE abs(27,34) usrel(3,2) yoink=1
    31.519         1/iSE:OPEN >SE:RING#16(3,2)+4o +5
    31.519         1/a16-AINIT SE CS_BOUND -> CS_RUNG
    31.519         1/lDBG a16-AINIT RING SW abs(27,34) usrel(27,2) yoink=1
    31.529         1/iSW:OPEN >SW:RING#16(27,2)+4o +5
    31.529         1/a16-AINIT SW CS_BOUND -> CS_RUNG
    31.529         1/a16-AINIT -> AWLOCKS
    31.532         1/iSE:OPEN <SE:RING#5(34,1)+4e +5
    31.532         1/lDBG ITC/SE:OPEN: HRP abs(58,37) themrel(34,1) yoink=0
    31.532         1/pSE05-PINIT -> PINIT
    31.532         1/pSE05-PINIT p@(58,37)+4
    31.532         1/pSE05-PINIT SE CS_BOUND -> CS_RUNG
    31.532         1/pSE05-PINIT -> PRESOLVE
    31.532         1/pSE05-PRESOLVE -> PWCACHE
    31.535         1/iSE:OPEN >SE:ANSWER#5 +2
    31.535         1/pSE05-PWCACHE SE CS_RUNG -> CS_ANSWERED
    31.535 0/iNE:OPEN <NE:RING#16(27,2)+4o +5
    31.535 0/lDBG ITC/NE:OPEN: HRP abs(51,2) themrel(27,2) yoink=1
    31.535 0/pNE16-PINIT -> PINIT
    31.535 0/pNE16-PINIT p@(51,2)+4
    31.535 0/pNE16-PINIT NE CS_BOUND -> CS_RUNG
    31.535 0/pNE16-PINIT -> PRESOLVE
    31.536 0/lDBG RRFP-1 pNE16-PRESOLVE BUSYed by pNE31-PWCACHE
    31.537         1/iSW:OPEN <SW:RING#5(10,1)+4o +5
    31.537         1/lDBG ITC/SW:OPEN: HRP abs(10,37) themrel(10,1) yoink=1
    31.537         1/pSW05-PINIT -> PINIT
    31.537         1/pSW05-PINIT p@(10,37)+4
    31.537         1/pSW05-PINIT SW CS_BOUND -> CS_RUNG
    31.537         1/pSW05-PINIT -> PRESOLVE
    31.537         1/pSW05-PRESOLVE -> PWCACHE
    31.542         1/iSW:OPEN >SW:ANSWER#5 +2
    31.542         1/pSW05-PWCACHE SW CS_RUNG -> CS_ANSWERED
    31.544         1/iSW:OPEN <SW:BUSY#16 +2
    31.545         1/lDBG ITC/SW:OPEN: Enter hBP
    31.545         1/lDBG a16-AWLOCKS hBUSY ITC/SW:OPEN
    31.545         1/a16-AWLOCKS -> ADROP
    31.545 0/iNE:OPEN >NE:BUSY#16 +2
    31.545 0/pNE16-PRESOLVE -> PINIT
    31.545 0/lDBG Passive cn 16 released
    31.547 0/iNE:OPEN <NE:ANSWER#5 +2
    31.547 0/lDBG ITC/NE:OPEN: Enter HAP
    31.547 0/a05-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    31.547 0/lDBG ITC/NE:OPEN a05-AWLOCKS HAP
    31.547 0/lDBG a05-AWLOCKS hANSWER ITC/NE:OPEN
    31.549 0/iNW:OPEN <NW:RING#16(3,2)+4o +5
    31.549 0/lDBG ITC/NW:OPEN: HRP abs(3,2) themrel(3,2) yoink=1
    31.550 0/pNW16-PINIT -> PINIT
    31.550 0/pNW16-PINIT p@(3,2)+4
    31.550 0/pNW16-PINIT NW CS_BOUND -> CS_RUNG
    31.550 0/pNW16-PINIT -> PRESOLVE
    31.550 0/lDBG RRFP-1 pNW16-PRESOLVE BUSYed by pNW30-PWCACHE
    31.557 0/iNW:OPEN >NW:BUSY#16 +2
    31.557 0/pNW16-PRESOLVE -> PINIT
    31.557 0/lDBG Passive cn 16 released
    31.559 0/iNW:OPEN <NW:ANSWER#5 +2
    31.559 0/lDBG ITC/NW:OPEN: Enter HAP
    31.559 0/a05-AWLOCKS NW CS_RUNG -> CS_ANSWERED
    31.559 0/lDBG ITC/NW:OPEN a05-AWLOCKS HAP
    31.560 0/lDBG a05-AWLOCKS hANSWER ITC/NW:OPEN
    31.562 0/a05-AWLOCKS -> ABEHAVE
    31.562 0/lDBG a05-ABEHAVE (34,5)BEIN ngb 7 live 1
    31.562 0/a05-ABEHAVE -> ASCACHE
    31.562 0/lDBG SHIP#0 sn7 (35,4) tt 0xFFFF wt 0x0001
    31.562 0/lDBG SHIP#1 sn0 (34,5) tt 0x0001 wt 0xFFFF
    31.568 0/iNE:OPEN >NE:TALK#5 +29
    31.568 0/lDBG SHIP#0 sn7 (35,4) tt 0xFFFF wt 0x0001
    31.568 0/lDBG SHIP#1 sn0 (34,5) tt 0x0001 wt 0xFFFF
    31.574 0/iNW:OPEN >NW:TALK#5 +29
    31.574 0/a05-ASCACHE -> AWACKS
    31.731         1/iSE:OPEN <SE:BUSY#16 +2
    31.731         1/lDBG ITC/SE:OPEN: Enter hBP
    31.731         1/lDBG a16-ADROP hBUSY ITC/SE:OPEN
    31.731         1/lDBG a16-ADROP Not AWLOCKS, ignoring BUSY
    31.735 0/a09-IDLE -> AINIT
    31.735 0/a09-AINIT a@(32,9)+4
    31.735 0/a09-AINIT -> IDLE
    31.737         1/iSE:OPEN <SE:TALK#5 +29
    31.737         1/lDBG ITC/SE:OPEN: Enter HCUP
    31.737         1/pSE05-PWCACHE SE CS_ANSWERED -> CS_TALKED
    31.737         1/lDBG pSE05-PWCACHE CUPSN#7 mLastSN 40
    31.737         1/lWRN pSE05-PWCACHE sn7/(59,36) not accessible by ITC/SE:OPEN; ignored
    31.737         1/lDBG pSE05-PWCACHE CUPSN#0 mLastSN 40
    31.737         1/lWRN pSE05-PWCACHE sn0/(58,37) not accessible by ITC/SE:OPEN; ignored
    31.738         1/lDBG pSE05-PWCACHE CUPSN#255 mLastSN 40
    31.738         1/lDBG pSE05-PWCACHE (C_TALKED(pSE05-PWCACHExITC/SE:OPEN)) cPEWAHU
    31.740         1/iSE:OPEN >SE:HANGUP#5 +2
    31.741         1/pSE05-PWCACHE -> PINIT
    31.741         1/lDBG pSE05-PINIT PASSIVE DONE
    31.749         1/iSW:OPEN <SW:TALK#5 +29
    31.749         1/lDBG ITC/SW:OPEN: Enter HCUP
    31.749         1/pSW05-PWCACHE SW CS_ANSWERED -> CS_TALKED
    31.749         1/lDBG pSW05-PWCACHE CUPSN#7 mLastSN 40
    31.749         1/lDBG RECV#0 sn7 (11,36) tt 0xFFFF wt 0x0001
    31.749         1/lDBG pSW05-PWCACHE CUPSN#0 mLastSN 40
    31.749         1/lDBG RECV#1 sn0 (10,37) tt 0x0001 wt 0xFFFF
    31.749         1/lDBG pSW05-PWCACHE CUPSN#255 mLastSN 40
    31.749         1/lDBG pSW05-PWCACHE (C_TALKED(pSW05-PWCACHExITC/SW:OPEN)) cPEWAHU
    31.751         1/iSW:OPEN >SW:HANGUP#5 +2
    31.752         1/pSW05-PWCACHE -> PINIT
    31.752         1/lDBG pSW05-PINIT PASSIVE DONE
    31.752         1/lDBG a16-ADROP fallow period ended, freeing
    31.752         1/a16-ADROP SE CS_RUNG -> CS_UNUSED
    31.752         1/a16-ADROP SW CS_RUNG -> CS_UNUSED
    31.752         1/a16-ADROP -> IDLE
    31.759 0/iNW:OPEN <NW:HANGUP#5 +2
    31.759 0/lDBG ITC/NW:OPEN: Enter HUP
    31.759 0/a05-AWACKS NW CS_ANSWERED -> CS_UNUSED
    31.759 0/lDBG a05-AWACKS hHU ITC/NW:OPEN
    31.766 0/iNE:OPEN <NE:HANGUP#5 +2
    31.766 0/lDBG ITC/NE:OPEN: Enter HUP
    31.766 0/a05-AWACKS NE CS_ANSWERED -> CS_UNUSED
    31.766 0/lDBG a05-AWACKS hHU ITC/NE:OPEN
    31.766 0/lDBG a05-AWACKS FREEING (34,5)+4
    31.767 0/a05-AWACKS -> IDLE
    31.768 0/a14-IDLE -> AINIT
    31.768 0/a14-AINIT a@(32,9)+4
    31.768 0/a14-AINIT NE CS_UNUSED -> CS_BOUND
    31.768 0/a14-AINIT NW CS_UNUSED -> CS_BOUND
    31.769 0/lDBG a14-AINIT sites available
    31.769 0/lDBG a14-AINIT OWNING (32,9)+4
    31.769 0/lDBG a14-AINIT RING NE abs(32,9) usrel(8,5) yoink=1
    31.774 0/iNE:OPEN >NE:RING#14(8,5)+4o +5
    31.774 0/a14-AINIT NE CS_BOUND -> CS_RUNG
    31.774 0/lDBG a14-AINIT RING NW abs(32,9) usrel(32,5) yoink=1
    31.782 0/iNW:OPEN >NW:RING#14(32,5)+4o +5
    31.782 0/a14-AINIT NW CS_BOUND -> CS_RUNG
    31.782 0/a14-AINIT -> AWLOCKS
    31.791 0/a11-IDLE -> AINIT
    31.791 0/a11-AINIT a@(26,12)+4
    31.791 0/lDBG a11-AINIT sites available
    31.791 0/lDBG a11-AINIT OWNING (26,12)+4
    31.791 0/a11-AINIT -> ABEHAVE
    31.793 0/lDBG a11-ABEHAVE (26,12)BEIN ngb 1 live 1
    31.793 0/lDBG a11-ABEHAVE FREEING (26,12)+4
    31.793 0/a11-ABEHAVE -> IDLE
    31.807 0/a07-IDLE -> AINIT
    31.807 0/a07-AINIT a@(35,4)+4
    31.807 0/a07-AINIT NE CS_UNUSED -> CS_BOUND
    31.807 0/a07-AINIT NE CS_BOUND -> CS_UNUSED
    31.807 0/a07-AINIT -> IDLE
    31.900 0/a01-IDLE -> AINIT
    31.901 0/a01-AINIT a@(35,4)+4
    31.901 0/a01-AINIT NE CS_UNUSED -> CS_BOUND
    31.901 0/a01-AINIT NE CS_BOUND -> CS_UNUSED
    31.901 0/a01-AINIT -> IDLE
    31.903 0/a08-IDLE -> AINIT
    31.903 0/a08-AINIT a@(35,4)+4
    31.903 0/a08-AINIT NE CS_UNUSED -> CS_BOUND
    31.903 0/a08-AINIT NE CS_BOUND -> CS_UNUSED
    31.903 0/a08-AINIT -> IDLE
    31.927         1/a30-IDLE -> AINIT
    31.927         1/a30-AINIT a@(28,35)+4
    31.927         1/a30-AINIT SE CS_UNUSED -> CS_BOUND
    31.927         1/a30-AINIT SW CS_UNUSED -> CS_BOUND
    31.927         1/lDBG a30-AINIT sites available
    31.927         1/lDBG a30-AINIT OWNING (28,35)+4
    31.927         1/lDBG a30-AINIT RING SE abs(28,35) usrel(4,3) yoink=0
    31.935         1/iSE:OPEN >SE:RING#30(4,3)+4e +5
    31.935         1/a30-AINIT SE CS_BOUND -> CS_RUNG
    31.935         1/lDBG a30-AINIT RING SW abs(28,35) usrel(28,3) yoink=0
    31.945         1/iSW:OPEN >SW:RING#30(28,3)+4e +5
    31.945         1/a30-AINIT SW CS_BOUND -> CS_RUNG
    31.945         1/a30-AINIT -> AWLOCKS
    31.947         1/iSE:OPEN <SE:RING#14(32,5)+4o +5
    31.947         1/lDBG ITC/SE:OPEN: HRP abs(56,41) themrel(32,5) yoink=1
    31.947         1/pSE14-PINIT -> PINIT
    31.947         1/pSE14-PINIT p@(56,41)+4
    31.947         1/pSE14-PINIT SE CS_BOUND -> CS_RUNG
    31.947         1/pSE14-PINIT -> PRESOLVE
    31.947         1/pSE14-PRESOLVE -> PWCACHE
    31.950         1/iSE:OPEN >SE:ANSWER#14 +2
    31.950         1/pSE14-PWCACHE SE CS_RUNG -> CS_ANSWERED
    31.952         1/iSW:OPEN <SW:RING#14(8,5)+4o +5
    31.952         1/lDBG ITC/SW:OPEN: HRP abs(8,41) themrel(8,5) yoink=1
    31.952         1/pSW14-PINIT -> PINIT
    31.952         1/pSW14-PINIT p@(8,41)+4
    31.952         1/pSW14-PINIT SW CS_BOUND -> CS_RUNG
    31.952         1/pSW14-PINIT -> PRESOLVE
    31.952         1/pSW14-PRESOLVE -> PWCACHE
    31.954 0/iNE:OPEN <NE:RING#30(28,3)+4e +5
    31.955 0/lDBG ITC/NE:OPEN: HRP abs(52,3) themrel(28,3) yoink=0
    31.955 0/pNE30-PINIT -> PINIT
    31.955 0/pNE30-PINIT p@(52,3)+4
    31.955 0/pNE30-PINIT NE CS_BOUND -> CS_RUNG
    31.955 0/pNE30-PINIT -> PRESOLVE
    31.955 0/lDBG RRFP-1 pNE30-PRESOLVE BUSYed by pNE31-PWCACHE
    31.958         1/iSW:OPEN >SW:ANSWER#14 +2
    31.958         1/pSW14-PWCACHE SW CS_RUNG -> CS_ANSWERED
    31.960         1/iSW:OPEN <SW:BUSY#30 +2
    31.960         1/lDBG ITC/SW:OPEN: Enter hBP
    31.960         1/lDBG a30-AWLOCKS hBUSY ITC/SW:OPEN
    31.960         1/a30-AWLOCKS -> ADROP
    31.961 0/iNE:OPEN >NE:BUSY#30 +2
    31.961 0/pNE30-PRESOLVE -> PINIT
    31.961 0/lDBG Passive cn 30 released
    31.963 0/iNE:OPEN <NE:ANSWER#14 +2
    31.963 0/lDBG ITC/NE:OPEN: Enter HAP
    31.963 0/a14-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    31.963 0/lDBG ITC/NE:OPEN a14-AWLOCKS HAP
    31.963 0/lDBG a14-AWLOCKS hANSWER ITC/NE:OPEN
    31.973 0/iNW:OPEN <NW:RING#30(4,3)+4e +5
    31.973 0/lDBG ITC/NW:OPEN: HRP abs(4,3) themrel(4,3) yoink=0
    32.143         1/iNE:SHUT >iNE:SHUT?2EEE4739  +6
    32.143         1/lDBG a30-ADROP fallow period ended, freeing
    32.144         1/a30-ADROP SE CS_RUNG -> CS_UNUSED
    32.144         1/a30-ADROP SW CS_RUNG -> CS_UNUSED
    32.144         1/a30-ADROP -> IDLE
    32.343         1/a08-IDLE -> AINIT
    32.343         1/a08-AINIT a@(28,23)+4
    32.343         1/lDBG a08-AINIT sites available
    32.343         1/lDBG a08-AINIT OWNING (28,23)+4
    32.343         1/a08-AINIT -> ABEHAVE
    32.375         1/lDBG a08-ABEHAVE (28,23)BEIN ngb 2 live 1
    32.375         1/lDBG a08-ABEHAVE FREEING (28,23)+4
    32.375         1/a08-ABEHAVE -> IDLE
    32.387         1/a21-IDLE -> AINIT
    32.387         1/a21-AINIT a@(28,22)+4
    32.388         1/lDBG a21-AINIT sites available
    32.388         1/lDBG a21-AINIT OWNING (28,22)+4
    32.388         1/a21-AINIT -> ABEHAVE
    32.395         1/iSE:OPEN >iSE:OPEN?759BAB81  +6
    32.395         1/a25-IDLE -> AINIT
    32.395         1/a25-AINIT a@(14,33)+4
    32.395         1/a25-AINIT SW CS_UNUSED -> CS_BOUND
    32.395         1/lDBG a25-AINIT sites available
    32.395         1/lDBG a25-AINIT OWNING (14,33)+4
    32.396         1/lDBG a25-AINIT RING SW abs(14,33) usrel(14,1) yoink=1
    32.401         1/iSW:OPEN >SW:RING#25(14,1)+4o +5
    32.401         1/a25-AINIT SW CS_BOUND -> CS_RUNG
    32.401         1/a25-AINIT -> AWLOCKS
 ..

:175]
[176:

Thu Jun 25 00:27:45 2020 You know, working through this -- and I'm
still not done -- I realize that what I'd REALLY like is to have
Weaver NOT JUST interleave the traces BUT ALSO track the current
status of each referenced EW.  I guess it would probably have to be a
curses program or something, so you could step forward and backward
through the merged traces, and on the other side of the screen you'd
have a dump of all the active windows that Weaver knows about as of
that trace record.

Because it seems an awful lot of what I'm doing here, as I struggle to
annotate the traces, is figure out what EWs are alive and what state
they're all in.  And Weaver could absolutely track that.

HMMMMMMM.

:176]
[177:

Thu Jun 25 06:11:22 2020 So I guess maybe the idea would be that when
we load the trace files, we could implicitly or explicitly number all
the trace record in their merged order...  and maybe build a vector
from those numbers to filenum+filepos for where to find that record?

I'm trying to think of a way to allow a curses based file viewer to
scroll back and forward, showing a segment of the merged record plus
a event window status map (and maybe circuit and/or itc status as
well), that's always in sync with the cursor position in the trace
window.

Let's try building that merged map.[178:

Thu Jun 25 09:06:20 2020 OK so we now have FileTrace, which wraps a
regular trace plus a WLFNumAndFilePos, which is a pair holding a file
number and ftell()-ish file position.

Now let's build a merged vector of WLFNumAndFilePos for every trace in
every file.. [179:

Thu Jun 25 09:27:05 2020 OK, I think we have that.  Now I think we
need a data structure to represent all our various ews, recording for
each:

 - Tile number

 - Active or passive mdir6

 - slotnum

as their fixed data, plus

 - statenum

 - center

 - radius

as their modifiable data.

I'm thinking we just immediately centralize all these inside the
Alignment, in a map or something, rather than trying to burst them out
to the WLF's or something.  How are we going to want to iterate them,
though?  Let's pretend just by filenum, then actives, then passives by
..  Actually maybe we want to align filenum on column and slotnum on
the row, then like active vs passive on left-right in column or
something?  It would be helpful to see passive EWs spatially connected
to their active counterparts somehow.

           +-----------------------------------------------------------+
           |   0/            1/            2/        ^0/tracerec       |
           | a00-AWLOCKS                             |0/tracerec       |
           |               pNE00-PWCACHE             |  1/tracerec     |
           |                                         |  1/tracerec     |
           |                                         |0/tracerec       |
           |                                         |    2/tracerec   |
           |               a10-AWACKS                |    2/tracerec   |
           | pSW10-PWCACHE                           >  1/tracerec     |
           |                                         |0/tracerec       |
           |                                         |0/tracerec       |
           |                                         |  1/tracerec     |
           |                                         |  1/tracerec     |
           |                                         |0/tracerec       |
           |                                         |    2/tracerec   |
           |                                         v    2/tracerec   |
           +-----------------------------------------------------------+

or something like that.  Maybe collapse out rows where nobody has EWs
going.

[180:

Thu Jun 25 10:03:26 2020 So what's the data structure?

slotnum -> wlfnum -> <p0..p5,a>

and the point is it's going to be completed built out at all times,
and we'll scan it to decide what needs to be displayed

:180]

:179]

:178]

:177]
[181:

Thu Jun 25 11:06:39 2020 OK, well we have a cut at 'EWSlotMap', and
Alignment is allocating and deallocating one based on the number of
files, but we're not doing anything else with it.

I think the next stop is to start getting a curses framework set up
for Weaver, to be activated if we see the '-c' arg on the command line
or something, so we'll have a place to start displaying the info that
we'll get the EWSlotMap to contain.  We're heading for a bidirectional
iterator over the mTraceLoc..[182:

Thu Jun 25 14:46:15 2020 Had to break for a meeting and then a nap,
and now another meeting coming up, and then it's time to move the
flag!  So continuing probably in the overnight.

:182]

:181]
[183:

Thu Jun 25 17:21:32 2020 WIP commit.

:183]
[184:

Thu Jun 25 23:48:40 2020 OK back.  curses framework; I can't be
starting from scratch on this, right?  I checked that tile-level
simulator I did, though, and that's perl..  So assuming I'm staying
with C++ for Weaver, WHICH I AM..[185:

Fri Jun 26 01:35:53 2020 OK so we have curses starting and stopping
under the -i command line flag.  I think we need some windows design
before we get too much farther.

 - Rolling trace display

 - The map

 - File info?  Tweak info?  etc?

[186:

Fri Jun 26 01:55:49 2020 Well now I'm wondering about trying this
'panel' library that
http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/panels.html#PANELBROWSING
shows examples of, which I tried on the tile and they seem to work.

Let's try it.  So, panels:

 - Rolling trace display

 - The EWMap - which still needs to be designed

 - Misc info, controls, whatever.

:186]


:185]

:184]
[187:

Fri Jun 26 04:50:03 2020 Well, that took... three hours? gah... but
now we have a 'panels'-library-based framework for EWMap, Trace, and
Info windows getting drawn on a terminal window.  Nothing in the
windows mind you, but there's labeled boxes:

┌EWMap─────────────────────────────────────────────────────┐┌Trace─────────────┐
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
│                                                          ││                  │
┌Info──────────────────────────────────────────────────────────────────────────┐
│                                                                              │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘

Right now the Info window is stepping on the others because I've been
imagining it's going to pop-down or something..
[188:

Fri Jun 26 04:55:09 2020 So, let's have some

TODO

 - Window resize: Have panels proportion themselves to the screen size
   and resize on WINCH

[194: Sat Jun 27 01:36:40 2020
EON :194] - TAB to cycle through the windows; top window interprets misc
   keystrokes

[189: Fri Jun 26 05:44:57 2020 First try for Trace
DONE :189] - Subclass IWPanelData for per-panel data?  Like Trace top record and
   active record?

[190: Fri Jun 26 07:19:11 2020
DONE - Display trace records in the trace window

[193: Sat Jun 27 01:36:27 2020
DONE :193] - Respond to arrow, page, and home/end keys to scroll the Trace
   window

 - Nail the active row to the middle of the trace window?  Need to
   handle negative rows then..  One of mTopRecord/mActiveRow becomes
   redundant.

:190]
:188]
:187]
[191:

Sat Jun 27 01:31:01 2020 OK, so I think we're updating the EWModel's
in the forward direction.  Let's flesh on the backward direction and
then start thinking about some kind of first cut EWMap display.[192:

Sat Jun 27 01:35:56 2020 OK well that wasn't too bad.  ..Have some
To-Do To DONE Too.

:192]

:191]
[195:

Sat Jun 27 01:46:44 2020 OK, so, how are we going to display the
'relevant' EWs?

I was thinking slotnum going down rows, skipping unused slotnums.
Which we should probably just try, to get going, but I can see lots of
problems with it..

And across the columns, what?

Or, how about this: Just strip out in reading order with slotnum
slowest then filenum then index?  Have a fixed chunk of space for each
one, so they won't jump around horizontally on state changes, although
the whole thing with re-layout when a short-lived hidden event pops in
or out.  Hmm and option not to display hidden events could be quite
useful for stabilizing that display, but sometimes you're going to
want them..

[196:

Sat Jun 27 02:04:15 2020 OK, so how many columns per EWModel?  Worst
state name is 'PRESOLVE' at 8 + like '1/pNE00-' for another 8, so 16
worst case?  Perhaps try going with 16?[197:

Sat Jun 27 04:34:56 2020 Well it's starting to work, and like I was
worried about it's a real pain to have given EWModel's jumping all
over the place as others come and go.  What if instead we prioritize
stable locations -- keep a map of where live EWM's are displayed,
and let them keep having that spot as long as they're relevant. [198:

Sat Jun 27 04:42:26 2020 Ooh and down the road we could let the user
rearrange them by having a selection mechanism plus swap using the
arrow keys..

So, perhaps std::map<EWModel*,UPoint> ?  And we actually update that
map first, and then go back and draw stuff?  Would want to iterate two
ways for that, so make std::map<UPoint, EWModel*> also?[199:

Sat Jun 27 04:56:25 2020 And we'll assume we can layout for the given
width and as many rows as we need?  And I guess we'll scan for empties
when we need one?[200:

Sat Jun 27 05:01:03 2020 Actually how about we do maps to u32 instead
of UPoint, meaning just 'display order', rather than exact position?
That means things might move if the EWMap panel is resized (in the
future) but [201:

Sat Jun 27 05:42:31 2020 Urrgh, wrote a bunch of code in displayPanel,
but that's actually the wrong place for most of it, because we need to
assign and remove display orders on a per trace basis, not a display
basis..  Just the actual display code stays in drawPanel, I
think.[202:

Sat Jun 27 05:44:50 2020 But ugh, we weren't notifying the display
panel on a per-trace basis -- that happens over in the trace panel.
So the two of them would want to share the display ordering code?  Who
should own it??[203:

Sat Jun 27 05:49:53 2020 The EWSlotMap should own it.

:203]

:202]

:201]

:200]

:199]

:198]


:197]

:196]

:195]
[204:

Sat Jun 27 06:32:19 2020 OK well it's doing what I asked of it but
what I asked isn't super great, so sort of

TODO:

 - Having 0/ and 1/ mixed up across rows and cols is confusing, fix

 - Probably want to go column per tile and sort rows by active then
   passive and slotnum inside each of them.

 - Probably want to go with a full-width shallow trace buffer instead
   of the narrow tall one, and give more width to EWMap

 - Definitely want to have the trace map center the active row rather
   than putting it in the top

 - Not clear that we need to indent the different tiles in the trace
   map since the 0/ 1/ is always right there are the front

 - Want keyboard on EWMap to select a particular EWM

 - Would help to have an info window separate from the log window that
   would should details of the selected EWM.

And that's plenty for starters.

But it's getting time for second sleep perhaps, and we're pretty
extended here, so let's have a WIP commit.
[205:

Sat Jun 27 06:38:07 2020 Oh one more thing though: Our new tool is
already pretty clearly showing us passive EWs that are failing to get
cleaned up after active side drops.  Something like this:

┌EWMap─────────────────────────────────┐┌Trace────────────────────────────13245┐
│1/a29-AWLOCKS   1/pNE31-PWCACHE       │>31.135 0/a30-AWLOCKS -> ADROP         │
│0/pSE29-PWCACHE 1/pNW30-PWCACHE       ││31.138    1/iNW:OPEN <NW:BUSY#15 +2   │
│0/pSW29-PWCACHE 1/a15-ADROP           ││31.138    1/lDBG ITC/NW:OPEN: Enter hB│
│0/a30-AWLOCKS                         ││31.138    1/lDBG a15-ADROP hBUSY ITC/N│
│                                      ││31.138    1/lDBG a15-ADROP Not AWLOCKS│
│                                      ││31.140    1/iNW:OPEN <NW:ANSWER#29 +2 │
│                                      ││31.140    1/lDBG ITC/NW:OPEN: Enter HA│
│                                      ││31.140    1/a29-AWLOCKS NW CS_RUNG -> │
│                                      ││31.140    1/lDBG ITC/NW:OPEN a29-AWLOC│
│                                      ││31.141    1/lDBG a29-AWLOCKS hANSWER I│
│                                      ││31.151    1/iNE:OPEN <NE:ANSWER#29 +2 │
│                                      ││31.151    1/lDBG ITC/NE:OPEN: Enter HA│
│                                      ││31.151    1/a29-AWLOCKS NE CS_RUNG -> │
│                                      ││31.151    1/lDBG ITC/NE:OPEN a29-AWLOC│
│                                      ││31.151    1/lDBG a29-AWLOCKS hANSWER I│
┌Log────────────────────────────────────│31.151    1/a29-AWLOCKS -> ABEHAVE    │
│                                       │31.153    1/lDBG a29-ABEHAVE (33,9)BEI│
│                                       │31.153    1/a29-ABEHAVE -> ASCACHE    │
│                                       │31.153    1/lDBG SHIP#0 sn1 (32,9) tt │
│                                       │31.153    1/lDBG SHIP#1 sn0 (33,9) tt │
│                                       │31.156    1/iNE:OPEN >NE:TALK#29 +29  │
│                                       │31.156    1/lDBG SHIP#0 sn1 (32,9) tt │
└───────────────────────────────────────└──────────────────────────────────────┘

at traceloc 13245, giving way to stuff like this:

┌EWMap─────────────────────────────────┐┌Trace────────────────────────────13337┐
│                1/pNE31-PWCACHE       │>31.353    1/a21-IDLE -> AINIT         │
│                1/pNW30-PWCACHE       ││31.353    1/a21-AINIT a@(29,12)+4     │
│                                      ││31.353    1/lDBG a21-AINIT sites avail│
│                                      ││31.353    1/lDBG a21-AINIT OWNING (29,│
│                                      ││31.353    1/a21-AINIT -> ABEHAVE      │
│                                      ││31.353    1/lDBG a21-ABEHAVE (29,12)BE│
│                                      ││31.354    1/lDBG a21-ABEHAVE FREEING (│
│                                      ││31.354    1/a21-ABEHAVE -> IDLE       │
│                                      ││31.373    1/a25-IDLE -> AINIT         │
│                                      ││31.373    1/a25-AINIT a@(28,12)+4     │
│                                      ││31.373    1/lDBG a25-AINIT sites avail│
│                                      ││31.373    1/lDBG a25-AINIT OWNING (28,│
│                                      ││31.373    1/a25-AINIT -> ABEHAVE      │
│                                      ││31.375    1/lDBG a25-ABEHAVE (28,12)BE│
│                                      ││31.375    1/lDBG a25-ABEHAVE FREEING (│
┌Log────────────────────────────────────│31.375    1/a25-ABEHAVE -> IDLE       │
│                                       │31.384    1/a05-IDLE -> AINIT         │
│                                       │31.384    1/a05-AINIT a@(34,5)+4      │
│                                       │31.384    1/a05-AINIT NE CS_UNUSED -> │
│                                       │31.384    1/a05-AINIT NW CS_UNUSED -> │
│                                       │31.384    1/lDBG a05-AINIT sites avail│
│                                       │31.384    1/lDBG a05-AINIT OWNING (34,│
└───────────────────────────────────────└──────────────────────────────────────┘

by 13337.

:205]
:204]
[206:

Sat Jun 27 14:28:52 2020 OK, let's redo the EWMap layout one more time
here, and then try to declare victory and pop the stack on Weaver for
a while.

Let's go for this:
[208:
DONE :208] - Increase column width to w/2*filecount

[215: Sun Jun 28 04:30:18 2020
DONE :215] - Do file active, file passive, on adjacent columns?

[209:
DONE :209] - Track TTC_EW_AssignCenter records too?

 - Track TTC_EW_CircuitStateChange records too?

 - Assign persistent row numbers, on 3s for active and 2s for passive?

[207:

Sun Jun 28 01:55:15 2020 OK so how are we going to do some of this and
move on to actual debugging?[210:

Sun Jun 28 01:56:01 2020 In particular, we organized the code around
'orders' as a single linear ordering.  How hard would it be to go 2D
there?  (And the whole idea of associating slotnums spatially, that's
getting tossed too?)[211:

Sun Jun 28 02:05:14 2020 Well it's a gross hack but we could go
through the orders several times and filter out the ones we want each
time -- 0/a's, 0/p's, 1/a's, ..  But then we lose position
persistence.

How about we do a+p per file in separate columns, and just list each
column oldest first?  So the flitting hidden a's will almost always be
at the bottom, and the long intertile ews will have pretty stable
row positions.  And informative ones at that.

So we can tag each EWModel by the trace loc of its current assign
center, say?  And set that to U32_MAX (youngest possible) when the
thing is first allocated?[212:

Sun Jun 28 02:21:13 2020 Buuuut how do we back into a lost EWModel,
grr.  We leave its last assign-center traceloc in there?  I guess we
have to..[213:

Sun Jun 28 02:27:38 2020 Sure it's just like the center info itself --
we back back into that..  OK let's go for this.  For now the strategy
is just init the time to U32_MAX, capture the assignCenter time when
we see it, bypass the order stuff completely for the moment, and sort
the columns at drawPanel time.

:213]

:212]

:211]

:210]

:207]

:206]
[214:

Sun Jun 28 04:29:01 2020 OK, laying the EWMs out in columns looks
better (on a big wide terminal anyway) --

┌EWMap────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│0/a30-ADROP......(28,35)+4    0/pSE29-PWCACHE..(57,41)+4    1/a15-ADROP........(4,5)+4    1/pNE31-PWCACHE...(51,2)+4     │
│                              0/pSW29-PWCACHE...(9,41)+4    1/a29-AWLOCKS.....(33,9)+4    1/pNW30-PWCACHE....(3,2)+4     │
│                                                                                                                         │
│                                                                                                                         │
│                                                                                                                         │
│                                                                                                                         │
│                                                                                                                         │
│                                                                                                                         │
│                                                                                                                         │
│                                                                                                                         │
│                                                                                                                         │
│                                                                                                                         │
│                                                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
┌Log────────────────────────────────────────────┐┌Trace──────────────────────────────────────────────────────────────13246┐
│                                               ││31.131    1/pNW30-PWCACHE NW CS_RUNG -> CS_ANSWERED                     │
│11: MSG: WP 0                                  ││31.132 0/iSW:OPEN >SW:ANSWER#29 +2                                      │
│12: MSG: WM 0                                  ││31.132 0/pSW29-PWCACHE SW CS_RUNG -> CS_ANSWERED                        │
│13: MSG: 0/->/home/t2/FILEDIR/202006242212-BLUE││31.135 0/iSW:OPEN <SW:BUSY#30 +2                                        │
│14: MSG: 0/ @Wed Jun 24 11:28:13 2020          ││31.135 0/lDBG ITC/SW:OPEN: Enter hBP                                    │
│15: MSG: 1/->/home/t2/FILEDIR/202006242212-RED-││31.135 0/lDBG a30-AWLOCKS hBUSY ITC/SW:OPEN                             │
│16: MSG: 1/ @Wed Jun 24 11:28:08 2020          ││31.135 0/a30-AWLOCKS -> ADROP                                           │
│17: MSG: 0/ -> 1/ n=44, s=214.904093, ss=1049.6│>31.138    1/iNW:OPEN <NW:BUSY#15 +2                                     │
│18: MSG: 1/ -> 0/ n=44, s=-214.904093, ss=1049.││31.138    1/lDBG ITC/NW:OPEN: Enter hBP                                 │
│19: MSG: Anchor file is 1/                     ││31.138    1/lDBG a15-ADROP hBUSY ITC/NW:OPEN                            │
│210: MSG: TWEAKING n0 0.000000                 ││31.138    1/lDBG a15-ADROP Not AWLOCKS, ignoring BUSY                   │
│211: MSG: 0/ 4s 884ms                          ││31.140    1/iNW:OPEN <NW:ANSWER#29 +2                                   │
│212: MSG: 1/ 0ms                               ││31.140    1/lDBG ITC/NW:OPEN: Enter HAP                                 │
│213: MSG: can_change_color=1                   ││31.140    1/a29-AWLOCKS NW CS_RUNG -> CS_ANSWERED                       │
└───────────────────────────────────────────────┘└────────────────────────────────────────────────────────────────────────┘

:214]
[216:

Sun Jun 28 13:32:34 2020 OK, Weaver -i is good enough.  At this point
I WANT to start changing the mfmt2 code based on issues surfaced by
Weaver:

 - pEWs return to IDLE when done, not just PINIT

Hmm I guess that's really the main one at the moment.  Let's commit
this Weaver stuff, then address the PINIT issue, then see if we can
catch some new bugs to inspect in our Weaver inspection jar.

:216]
[217:

Sun Jun 28 23:54:32 2020 OK, so before dinner, I hacked at getting the
pEWs to return to IDLE, and that seemed to be working okay, and I
changed Weaver to expect that.  And just now I've generated new trace
files

    202006282348-WHITE-t2trace12.dat
    202006282348-RED-t2trace12.dat

that manifests the 'leftover pEWs' problem using the new code.

[218:

Mon Jun 29 00:11:21 2020 So here we go.  Let's try to diagnosis the
problem -- which we are pretty sure involves incomplete clean-up
sometime after an ADROP -- using these log files and Weaver -i

:218]

:217]
[219:

Mon Jun 29 00:14:11 2020 DEBUGGING PROCESS.

 - OK, so by jumping to the end, we see 0/pNE17 appears to be an
   'orphaned pEW'.

 - Let's focus on that one.

 - Searching backwards from the end for '1/a17', we first find:
    >92.408    1/a17-AINIT -> AWLOCKS

 - Search back further with up-arrow, we get to
    >92.407    1/a17-IDLE -> AINIT
   without any lock involvement.  That's a quick hidden event and not
   the one we're looking for.

 - One more up-arrow leads to the more promising:
     >91.189    1/a17-ADROP -> IDLE
   which in fact is the end of an interesting 1/a sequence:

    │91.183    1/iSE:OPEN <SE:ANSWER#17 +2
    │91.183    1/a17-ADROP SE CS_RUNG -> CS_ANSWERED
    │91.183    1/lWRN ITC/SE:OPEN HAP bad aew state a17-ADROP for cn 17
    │91.189    1/a17-ADROP SW CS_RUNG -> CS_UNUSED
    │91.189    1/a17-ADROP SE CS_ANSWERED -> CS_UNUSED
    >91.189    1/a17-ADROP -> IDLE

   where the warning (and subsequent traces) are coming from
   T2ITC.cpp:318:

    if (aew.getEWSN() != EWSN_AWLOCKS) {
      TLOG(WRN,"%s HAP bad aew state %s for cn %d",
           getName(), aew.getName(), cn);
      aew.abortEW(); // XXX ??
      return;
    }

[220: Mon Jun 29 00:28:43 2020

 - So that's perhaps the smoking gun, but it doesn't pinpoint any
   actual bug.  Some possibilities and diagnostic questions:
   = Are we just racing?  Has 1/a17 previously sent a DROP to 0/pNW17,
     who just happened to ANSWER before seeing it?
   = If so, should we be accepting aEW in ADROP there?

 - Let's find out if 1/a17 sent a DROP to 0/pNW17.[221:

 - Hmm, we see
     >91.176    1/a17-AWLOCKS -> ADROP
   perhaps due to losing a yoink race?  The surrounding context isn't
   clear:

    │91.176    1/iSW:OPEN <SW:RING#6(19,0)+4e +5
    │91.176    1/pSW06-IDLE -> PINIT
    │91.176    1/pSW06-PINIT p@(19,36)+4
    │91.176    1/pSW06-PINIT SW CS_BOUND -> CS_RUNG
    │91.176    1/pSW06-PINIT -> PRESOLVE
    >91.176    1/a17-AWLOCKS -> ADROP
    │91.176    1/pSW06-PRESOLVE -> PWCACHE
    │91.176    1/iSW:OPEN >SW:ANSWER#6 +2

[222:

Mon Jun 29 00:41:12 2020 Argh, I didn't run these traces with '-l4'!
It's not include DBG messages!  I bet that's why we don't see explicit
notice of the yoink race.

Darn.  Let's go again.  For the record, gdb set-up is like:

/home/t2/MFM/src/drivers/mfmt2# gdb ../../../bin/mfmt2
(gdb) r -w /home/t2/MFM/res/mfmt2/wconfig.txt -z MFMT2-FAKE-MFZID -l4 -t

:222]

:221]

:220]
:219]
[223:

Mon Jun 29 01:02:22 2020 OK got another one.  This time it's dying on
a RING packet rather than an ANSWER packet, but the issue is upstream
either way, I think..  Tagging these traces with 202006290103

:223]
[224:

Mon Jun 29 01:06:40 2020 OK, starting again, on ~/FILEDIR/

  -rw-r--r-- 1 t2 t2 231899 Jun 29 01:01 202006290103-RED.dat
  -rw-r--r-- 1 t2 t2 317651 Jun 29 01:05 202006290103-WHITE.dat

[225:

Mon Jun 29 01:07:43 2020

 - Jump to end..  Hmm, don't see any obviously orphaned pEWs.

|108.496    1/t  Failed to top: src/T2EventWindow.cpp:888: INCOMPLETE_COD│
│110.450 0/t  Failed to top: src/T2ITC.cpp:198: ILLEGAL_STATE [4]        │
│110.599    1/t  Total events completed = 407904                         │
>112.634 0/t  Total events completed = 632106                            │

 - The 1/t T2EventWindow.cpp:888 is failing due to timeout in AWLOCKS;
   a consequence of 0/t hitting a breakpoint after T2ITC.cpp:198:

    MFM_API_ASSERT_STATE(pEW.getEWSN() == EWSN_IDLE);

 - From the final EWMap, the suspected instigator is 1/a19:

    ───────────────────────────────────────────────────────────
     0/pNE19-PWCACHE..(52,-1)+4    1/a19-AWLOCKS....(28,31)+4
      NE ANSWERED                   SE ANSWERED
     0/pNW19-PWCACHE...(4,-1)+4     SW RUNG
      NW ANSWERED                  1/a15-AWLOCKS....(51,30)+4
                                    ET BOUND
                                    SE RUNG

[226:

Mon Jun 29 01:16:36 2020 Uh-oh, it's worse than I thought.  Stepping
backwards over this:

    >45.152    1/a19-IDLE -> AINIT

causes the 1/a19-AWLOCKS....(28,31)+4 to vanish, but the 0/ps remain
-- are they a vestige of an earlier 1/a19?  Searching back farther.

[227:

Mon Jun 29 01:19:39 2020 Ah so the next stop back is implicated:

│45.118    1/lWRN ITC/SW:OPEN HAP bad aew state a19-ADROP for cn 19      │
>45.119    1/a19-ADROP SE CS_RUNG -> CS_UNUSED                           │
│45.119    1/a19-ADROP SW CS_ANSWERED -> CS_UNUSED                       │
│45.119    1/a19-ADROP -> IDLE                                           │

and that 'bad aew' warning is the same one we saw in :219: above.

But, 1/a19 is already -ADROP at that time.  So let's push back to
where that arises.[228:

Mon Jun 29 01:23:22 2020 OK, back at tracerec 14212 we find

>45.099    1/a19-AWLOCKS -> ADROP

but we're a little screwed because the Trace window is cutting off
part of the previous debug message:

│45.099    1/lDBG u a19-AWLOCKS (28,31); t pSE21-PRESOLVE (30,36): YOINK │
>45.099    1/a19-AWLOCKS -> ADROP                                        │

which is indeed the YOINK RACE debug message.  For the future, let's
break that down to three DBG messages: active side, passive side,
results.
[229:

Mon Jun 29 01:28:31 2020 In the meantime, though, we note that a quick
check-in with our still-fully-functional non-interactive Weaver gets
us the full debug message:

    t2@beaglebone:~/MFM/src/drivers/mfmt2$ ../../../bin/Weaver ~/FILEDIR/202006290103-*.dat | grep 45.099
    14210 45.099         1/pSE21-PINIT -> PRESOLVE
    14211 45.099         1/lDBG u a19-AWLOCKS (28,31); t pSE21-PRESOLVE (30,36): YOINK ITC/SE:OPEN(Fred) us1 them0 -> they win
    14212 45.099         1/a19-AWLOCKS -> ADROP
    14213 45.099         1/pSE21-PRESOLVE -> PWCACHE
    t2@beaglebone:~/MFM/src/drivers/mfmt2$

So it's a yoink from the SE, and SE is a Fred, and Fred takes the
odds, and odds is what we got, so Fred:SW:them:1/pSE21:0/a21 wins, and
our 1/a19 goes to ADROP.  But how did we NOT send a message to 0/pNE19
before that happened?[230:

Mon Jun 29 01:47:45 2020 So that debug message was part of
T2pEW::passiveWinsYoinkRace, and its caller says:

        bool passiveWins = passiveWinsYoinkRace(*aew);
        if (passiveWins) {
          aew->dropActiveEW(false);
          continue;
        }

leading to:

  void T2ActiveEventWindow::dropActiveEW(bool dueToNAK) {
    if (getEWSN() != EWSN_ADROP) {
      unhogEWSites();
      setEWSN(EWSN_ADROP);
      scheduleWait(WC_HALF);
    } else {
      LOG.Warning("%s already dropped", getName());
    }
  }

which shows no sign of notifying anybody about the change.

Is..  That..  Not..  Wrong?

[231:

Mon Jun 29 01:50:48 2020 I guess the counterclaim is that the far side
is supposed to detect the race itself.. no nono that's not this
situation is it?  Here the other side of the yoink race -- 1/pSE21 aka
0/a21 -- is WINNING, and the issue is we're dropping 1/a19 -- aka
0/pNW15 and 0/pNE19.

Do we have any discussion of the intended logic here that we can put
our hands on now?[232:

Mon Jun 29 01:54:22 2020 So back in :161: we talk about _changing_ the
(previously basically non-existent) semantics of ADROP.[233:

Mon Jun 29 01:58:49 2020 And we have :167: tracing through stuff that
does send a BUSY, but that's what happens when we win.  Here we're
dealing with the case where they win, and somebody else needs to get
killed. [234:

Mon Jun 29 02:01:38 2020 And :169: shows a DROP going on the wire.
That particular case turned out to be a bug (shown in :170:) but the
overall approach is still in the code:

  void T2ActiveEventWindow::handleBusy(T2ITC & itc) {
 ..
    for (u32 i = 0; i < CIRCUITS_PER_ACTIVE_EW; ++i) {
      Circuit & ci = mActiveCircuits[i];
      if (ci.isLockHeld()) {
 ..
        if (&thisITC != &itc) {
 ..
          trySendDropVia(thisITC);
        }
        ci.setCS(CS_DROPPED);
      }
    }
    dropActiveEW(true);
  }

and the thought is we need something similar to it .. where exactly?
[235:

Mon Jun 29 02:14:15 2020 Well in this case we're in

T2ITC::handleRingPacket ->
T2PassiveEventWindow::checkSiteAvailabilityForPassive ->
T2PassiveEventWindow::resolveRacesFromPassive

and we're just back from

T2PassiveEventWindow::passiveWinsYoinkRace

with a return value of true.

So the claim is we need to do stuff leading to that trySendDropVia
call, right there.  I guess we should factor it out of handleBusy?

:235]


:234]

:233]

:232]

:231]

:230]

:229]


:228]

:227]

:226]
:225]

:224]
[236:

Mon Jun 29 02:31:23 2020 Well okay, made

void sendDropsExceptTo(T2ITC * notThisOne) ;

and currently saying that when we drop from the passive side, we
should send DROP to everyone, so passing 0 for notThisOne.

Let's commit this WIP and spread it to WHITE and go again.

[237:

Mon Jun 29 02:45:18 2020 OK, seem to've caught a another/similar issue
-- being pSE19-PWCACHE in handleRingPacket -- so let's see if this
looks appreciably different.  Assigning 202006290246[238:

Mon Jun 29 02:48:17 2020 OK, here we go:

 - Jump to end, find a busy EWMap:

┌EWMap────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│0/a11-AWACKS.......(5,6)+4    0/pNE25-PWCACHE...(52,1)+4    1/a25-ADROP......(28,33)+4    1/pSE19-PWCACHE..(54,36)+4     │
│ WT BOUND                      NE ANSWERED                   SE RUNG                       SE ANSWERED                   │
│ NW ANSWERED                                                 SW RUNG                      1/pSW01-PWCACHE...(6,36)+4     │
│0/a27-AWLOCKS.....(30,4)+4                                                                 SW ANSWERED                   │
│ NW RUNG                                                                                  1/pSE11-PWCACHE..(29,38)+4     │
│ NE RUNG                                                                                   SE ANSWERED                   │


 - Just prior in the trace we see 0/a19 getting freed:
│29.448 0/lDBG a19-ADROP fallow period ended, freeing                    │
│29.448 0/a19-ADROP NW CS_RUNG -> CS_UNUSED                              │
│29.449 0/a19-ADROP NE CS_RUNG -> CS_UNUSED                              │
│29.449 0/a19-ADROP -> IDLE                                              │

 - And we don't have great visibility into the actual failure here, we
   ought to be able to see more..

 - But anyway, let's look back to find 0/a19 sending DROPs, which
   1/pSE19 should have reacted to..[239:


Mon Jun 29 02:55:27 2020 Grrrr, so I find:

│26.709 0/lDBG us a19-AWLOCKS (30,4); yoink=0                            │
│26.709 0/lDBG them pNE31-PRESOLVE (36,2); yoink=1                       │
│26.709 0/lDBG YOINK ITC/NE:OPEN(Fred/odds) -> they win                  │
>26.709 0/a19-AWLOCKS -> ADROP                                           │

(which does show our new broken-down triple-dbg yoink message, but)
which still SHOWS NO SIGNS that drop messages are getting sent.[240:

Mon Jun 29 03:00:00 2020 Well, so 'sendDropsExceptTo' does say this:
  ..
      Circuit & ci = mActiveCircuits[i];
      if (ci.isLockHeld()) {
  ..

and in the case at hand, we're calling it on

│0/a19-AWLOCKS......(0,0)+0
│ NE RUNG
│ NW RUNG

which, as we ALL can PLAINLY see, is holding NO locks at all.  Both
its circuits are in state RUNG, while the only lock-holding circuit
states are ANSWERED and TALKED.

So no DROPs are sent.

:240]

:239]

:238]

:237]

:236]
[241:

Mon Jun 29 04:19:45 2020 Gah lost an hour to the damn 'social media'.
But I was also playing with Andrew's CellBrane on mfm.rocks and making
a little video of it, so that's something.

:241]
[242:

Mon Jun 29 04:20:15 2020 But what the fog do we wand sendDropsExceptTo
to do?  Send to every circuit that's in use at all?  CS_RUNG or
greater?  Maybe so.  Do we want to be a coward and pass a flag so
we'll only change behavior when caller says?

Let's try CS_RUNG..CS_TALKED inclusive, for all users of
sendDropsExceptTo, and see what happens.

:242]
[243:

Mon Jun 29 04:53:25 2020 OK, now DROPs are flying and the first new
blow up is line 302, reacting to that:

    299       void T2PassiveEventWindow::handleDrop(T2ITC & itc) {
    300         TLOG(DBG,"%s: handleDrop", getName());
    301         if (getEWSN() <= EWSN_PINIT) { // What is best predicate here??
    302           FAIL(ILLEGAL_STATE);

with

    (gdb) p getEWSN()
    $3 = MFM::EWSN_IDLE
    (gdb)

No idea if it's a 'reasonable' DROP or not.  I guess let's fire up the
Weaver and just take a quick peek.  Code 202006290455 [244:

Mon Jun 29 05:01:33 2020 Well, it might be 'reasonable'.  What
happened was:

0/a18-AINIT.......(4,10)+4  started up..

>24.052 0/iNW:OPEN >NW:RING#18(4,6)+4o +5
│24.052 0/a18-AINIT NW CS_BOUND -> CS_RUNG
│24.052 0/a18-AINIT -> AWLOCKS

..rang NW and started waiting..

>24.202    1/iSE:OPEN <SE:RING#18(4,6)+4o +5                             │
│24.202    1/lDBG ITC/SE:OPEN: HRP abs(28,42) themrel(4,6) yoink=1       │
│24.202    1/pSE18-IDLE -> PINIT                                         │
│24.202    1/pSE18-PINIT p@(28,42)+4                                     │
│24.202    1/pSE18-PINIT SE CS_BOUND -> CS_RUNG                          │

..The ring came in 1/iSE and 1/pSE18 started up..

│24.202    1/pSE18-PINIT -> PRESOLVE                                     │
│24.202    1/lDBG us a25-AWLOCKS (29,35); yoink=1                        │
│24.202    1/lDBG them pSE18-PRESOLVE (28,42); yoink=1                   │
│24.202    1/lDBG YOINK ITC/SE:OPEN(Fred/odds) -> we win                 │
│24.202    1/lDBG RRFP-2 pSE18-PRESOLVE BUSYed by a25-AWLOCKS            │
│24.204    1/iSE:OPEN >SE:BUSY#18 +2                                     │
>24.204    1/pSE18-PRESOLVE -> IDLE                                      │
│24.204    1/lDBG Passive cn 18 released                                 │

..a race was detected and 0/a25 won the yoink, so 1/iSE reported BUSY,
and 1/pSE18 went back to idle.

And Is That Not Pretty Reasonable?

So I guess we're saying inbound DROP is advisory, at least in certain
cases?

[245:

Mon Jun 29 05:18:37 2020 So pEWs hogSites in
checkSiteAvailabilityForPassive, at it appears they will be in state
PRESOLVE at that time.

pEWs unhog sites in commitPassiveEWAndHangUp (successful event path)
at which point it's in PWCACHE, and handleDrop (not).  So I guess in
handleDrop we unhog for EWSN_PRESOLVE..EWSN_PWCACHE and not otherwise?

:245]

:244]

:243]
[246:

Mon Jun 29 05:49:49 2020 Well, RED and WHITE have been going for a
fair while now, with 8 beins between them, and so far nothing untoward
has popped up..

  /tmp:
  total used in directory 8172 available 70396
  -rw-r--r--  1 root root 3735552 Jun 29 05:50 t2trace18.dat

 /tmp:
  total used in directory 4236 available 693108
  -rw-r--r--  1 root root 3751936 Jun 29 05:51 t2trace15.dat

though the trace files are getting pretty hefty hefty hefty.
[247:

Mon Jun 29 05:56:58 2020 Still.  Maybe push to 6am and stop it there
if nothing?  Or at least start packing in lots more beins..

  /tmp:
  total used in directory 13580 available 64988
  -rw-r--r--  1 root root 9269248 Jun 29 05:57 t2trace18.dat

  /tmp:
  total used in directory 9764 available 687580
  -rw-r--r--  1 root root 9412608 Jun 29 05:57 t2trace15.dat

[248:

Mon Jun 29 06:05:20 2020 Well, it's still going..  I shot some phone
video of it, and added a bunch more beins while doing that..  and
still it lives.  I can't really tell if the count is absolutely solid
especially since I just added a bunch, but it doesn't seem obviously
off.

Need to stop this, don't want to stop this.

  /tmp:
  total used in directory 29384 available 49180
  -rw-r--r--  1 root root 25452544 Jun 29 06:09 t2trace18.dat

  /tmp:
  total used in directory 25216 available 672128
  -rw-r--r--  1 root root 25235456 Jun 29 06:09 t2trace15.dat

[249:

Mon Jun 29 06:11:29 2020 Woah, hit a FAIL!  What's it going to be??

Ah hahaha look:

    (gdb) up
    #1  0x00471c8a in MFM::T2PassiveEventWindow::resolveRacesFromPassive (this=0x566458,
        conflicts=...) at src/T2EventWindow.cpp:328
    328         if (sortable.size() > 1) FAIL(INCOMPLETE_CODE);
    (gdb)

It's our first multiway race!  N > 1, with N being the number of
active windows that are conflicting with an inbound passive window.

[250:

Mon Jun 29 06:16:18 2020 So, good news and bad news.

GOOD NEWS: The two-tile system survived for something like fifteen
           minutes with more than a dozen atoms going in parallel.

BAD NEWS:  It took something like fifteen minutes to trigger a failure
           (INCOMPLETE_CODE).  Enjoy the debugging!

[251:

Mon Jun 29 06:20:26 2020 Let's get these log files together and see
how hopeless Weaver -i navigation is.  Code 202006290622

:251]


:250]

:249]
:248]

:247]
:246]
[252:

Mon Jun 29 06:24:14 2020 Yow, Weaver taking forever to start up.
It still hasn't booted curses yet..[253:

Mon Jun 29 06:25:03 2020 Curses just popped.[254:

Mon Jun 29 06:26:29 2020 Ugh! And it appears the sync is off?

│13.884 0/iNW:OPEN <NW:ANSWER#23 +2                                      │
│13.884 0/lDBG ITC/NW:OPEN: Enter HAP                                    │
>13.884 0/a23-AWLOCKS NW CS_RUNG -> CS_ANSWERED                          │

So 0/a23 says it got a NW ANSWER at 13.884.

>13.900    1/iSE:OPEN >SE:ANSWER#23 +2                                   │
│13.900    1/pSE23-PWCACHE SE CS_RUNG -> CS_ANSWERED                     │

Buuuuut 1/iSE says it didn't even send the ANSWER packet until 13.900.

Grrr.
[255:

Mon Jun 29 10:48:18 2020 So Weaver -i is really really slow..[256:

Mon Jun 29 11:00:32 2020 But then it appears isearch was leaking all
the trace records?  Smoove Dave Smoove.

:256]

:255]
:254]

:253]

:252]
[257:

Mon Jun 29 16:19:44 2020 Code 202006291620

:257]
[258:

Tue Jun 30 05:28:32 2020 OK, so we need to take a cut at multiway
races.  We thought we'd seen stuff suggesting an additional 'pEW
leakage' problem in the long traces, but now they're not coming up so
let's go for the problem we know and let the rest resurface as it
wishes.
[259:

Tue Jun 30 05:30:15 2020 So now we need to give up on our absolute
favorite approach to sorting since the demon horde sort:

 ..
    if (sortable.size() > 1) FAIL(INCOMPLETE_CODE);

    // Presto: 'sortable' is sorted.  Now do P4 (202002010352-notes.txt:788:)
 ..

Sigh.

And what do we claim we're going to sort by?  (You know, at this
point, I have to say (again) that I'm not convinced the sorting is
anything more than an optimization, to avoid blowing up more EWs than
'necessary'.  But we'll see, perhaps anyway.)
[260:

Tue Jun 30 05:40:15 2020 'P4 (202002010352-notes.txt:788:)' says:

    (P4) If all of the conflict windows are active, consider them in
         oldest-first order. For each, first apply the yoink protocol and
         determine if the local active or the incoming active wins.

So how is 'oldest' operationalized in the current code?  Are we
capturing an 'event stamp' or something when we start an aEW?[261:

Tue Jun 30 08:05:14 2020 Well so we added a bunch more counters to
T2Tile and captured the mTotalActiveEventsConsidered into each aEW and
sorted for oldest based on that.

And now we had a bunch (dozen+) of beins bopping around between two
tiles for a bunch of minutes anyway -- 27MB of WHITE and 30MB of RED
trace files worth -- until I shut them down deliberately.

Let's try without tracing, even though we KNOW SOMETHING WILL DIE AND
WE WON'T BE ABLE TO DIAGNOSE IT.

Just to see it happen.

:261]

:260]

:259]

:258]
[262:

Tue Jun 30 08:25:47 2020 So, started up a two-tile no-tracing run at
8:22, and added a bunch of beins -- like two dozen+ I'd say.  [263:

Tue Jun 30 08:27:16 2020 And it's still going at this point.  And it's
really not that foggen slow![264:

Tue Jun 30 09:37:51 2020 OK, so after going off for breakfast I come
back and the party is gummed up: While I was gone we hit another pEW
state inconsistency:

    Thread 1 "mfmt2" hit Breakpoint 1, MFMLongJmpHere (buffer=0xbefff6c0, toThrow=4) at src/FailPlatformSpecific.cpp:48
    48          longjmp(buffer,toThrow);
    (gdb) up
    #1  0x0046114a in MFM::T2ITC::handleRingPacket (this=0x4d5cac <MFM::T2Tile::get()::THE_INSTANCE+2932>, pb=...) at src/T2ITC.cpp:198
    198         MFM_API_ASSERT_STATE(pEW.getEWSN() == EWSN_IDLE);
    (gdb) p pEW.getEWSN()
    $5 = MFM::EWSN_PWCACHE
    (gdb) bt
    #0  MFMLongJmpHere (buffer=0xbefff6c0, toThrow=4) at src/FailPlatformSpecific.cpp:48
    #1  0x0046114a in MFM::T2ITC::handleRingPacket (this=0x4d5cac <MFM::T2Tile::get()::THE_INSTANCE+2932>, pb=...) at src/T2ITC.cpp:198
    #2  0x00460b84 in MFM::T2ITC::handleCircuitPacket (this=0x4d5cac <MFM::T2Tile::get()::THE_INSTANCE+2932>, pb=...) at src/T2ITC.cpp:128
    #3  0x0046266e in MFM::T2ITC::tryHandlePacket (this=0x4d5cac <MFM::T2Tile::get()::THE_INSTANCE+2932>, dispatch=true) at src/T2ITC.cpp:361
    #4  0x00460986 in MFM::T2ITC::pollPackets (this=0x4d5cac <MFM::T2Tile::get()::THE_INSTANCE+2932>, dispatch=true) at src/T2ITC.cpp:108
    #5  0x0046045a in MFM::T2ITCPacketPoller::onTimeout (this=0x508c30 <MFM::T2Tile::get()::THE_INSTANCE+211704>, srcTq=...) at src/T2ITC.cpp:28
    #6  0x00468c32 in MFM::T2Tile::main (this=0x4d5138 <MFM::T2Tile::get()::THE_INSTANCE>) at src/T2Tile.cpp:624
    #7  0x0044c57a in MFM::MainDispatch (argc=5, argv=0xbefffc84) at src/main.cpp:78
    #8  0x0044c75c in main (argc=5, argv=0xbefffc84) at src/main.cpp:106
    (gdb) p mTile
    $6 = (MFM::T2Tile &) <error reading variable>
    (gdb) p mTile.mTotalActiveEventsConsidered
    $7 = 100825165
    (gdb) p mTile.mTotalActiveEventsCompleted
    $8 = 95530093
    (gdb)

So between you and me, that's nearly 100 MILLION events completed
before the inconsistency was detected.  And, of course, as stated at
the outset, tracing was off, so we have nothing to look at.

So, What We REALLY Need (TM), is a rolling trace buffer on disk.  Like
make a dir on startup, and have up to N MB of trace data in there,
where we start a new file after the current one grows to say N/5 MB,
and we automatically unlink the oldest one after the total goes over N
MB.  And we make a new kind of trace sync point that we dump at the
end of the old file and the beginning of the new one.

And then we leave that fogger running as long as it takes to catch a
bug.  We have to acknowledge that Weaver will be picking up in the
middle of things, so we'll need to understand what that looks like,
and hope to have plenty of data to wash all the fractions out before
getting to whatever the issue turns out to be.

:264]

:263]

:262]
[265:

Wed Jul  1 01:06:18 2020 OK, have been working since right around
midnight.  We now have '-r MB' to specify rolling log files totalling
up to MB, and we create a /tmp/t2trace%D directory for them, and we
reuse 10.dat .. 13.dat within that dir.
[266:

Wed Jul  1 01:21:35 2020 Now trying to figure out why Weaver is
blowing a UniqueTime-related assertion grrrr.[267:

Wed Jul  1 02:12:56 2020 Weaver was right..  It was because I delayed
dumping a built trace until after the trace files rolled, so there the
built trace had a backwards time relative to the initiation of the new
file.  Doh.

So, the current status is

(1) we are rolling 10.dat .. 13.dat files apparently plausibly
(2) Given /tmp/t2trace%D/*.dat Weaver does apparently sequence them
    correctly and find the correct anchor file, based on the new sync
    tags we put in just for that purpose..
(3) But using Weaver that way is problematic because successive trace
    rolls get successive file numbers, so they don't map to the same
    locations EWMap.

So I think some quick

TODO
[270:
DONE :270] - Don't roll the numbers.  Just let the file numbers count up, but
   when rolling, try to unlink num-4.

 - Extend the WeaverLogFile concept to support directory-as-file,
   where directory implies implicitly concatenating all the (.dat?)
   files within it, and treating that as one big file.

 - Have WLF maintain a set of 'cut points' determining which file to
   go to for a given 'effective file pos'.
[268: Wed Jul  1 02:23:13 2020

 - GO GO GO

:268]

:267]

:266]

:265]
[269:

Wed Jul  1 02:59:26 2020 OK got one.  [271:

Wed Jul  1 03:00:04 2020 Now WLF.

:271]

:269]
[272:

Wed Jul  1 05:14:02 2020 OK WLF hack is hitting a lot of code..  Time
to gork off for second sleep.  Current loose ends:

 - TraceLogReader should not require an FBS& in ctor.  (Of course.)
   Give it at init(FileByteSource&bs) and let it hold a non-owned ptr

 - TLR currently has a mPrevTimespec it's not using.  Ditch it.

 - It's unclear whether TLR should have mFirstTimeSpec either, vs
   lifting that up to the WLF level

 - Ton of stuff hacked and untried in WLF

Sleep now.

:272]
[273:

Wed Jul  1 15:25:11 2020 OK, have a meeting now, but got stuff all
hacked up and just now re-buildable, with INCOMPLETE_CODE all over the
place.  Will have to return to it in the overnight.[274:

Wed Jul  1 23:18:09 2020 OK let's debug.[275:

Thu Jul  2 06:07:00 2020 Did a couple hours and then slept more; now
we're on it again for a bit.

Currently trying to get the time offsets settled again.  Restate
fundamentals:

 - We have mFirstTimespec, the timespec of the first trace in each
   WeaverLogFile.  But note if we're in 'directory' mode,
   mFirstTimespec is the first trace of the first physical file
   within the directory.

 - We have mEffectiveOffset (with mHasEffectiveOffset), which is the
   time difference between the beginning of the anchor file, and the
   beginning of the WLF.  Again, even in directory mode, there is only
   one mEffectiveOffset for the whole directory.  (Because we're
   saying non-zero mEffectiveOffsets arise from data being gathered on
   different tiles, but all the files in one WLF directory are
   perforce taken as from one tile.)

 - We have a per-trace timespec 'tmpTime', which TraceLogReader::reads
   from whatever ByteSource (physical file) it is given.

 - And we have the netTimeOffset, which TraceLogReader (currently)
   subtracts from the tmpTime, to get the imputed aligned time of the
   given trace

[276:

Thu Jul  2 06:39:58 2020 So, given all that, I guess the question is:
How should netTimeOffset be computed so the imputed aligned times are
all 'harmonious'?  (OK, 'consistent'.)

I guess it's:

 netTimeOffset = mFirstTimespec - mEffectiveOffset

so we get

  tmpTime - netTimeOffset
  tmpTime - (mFirstTimespec - mEffectiveOffset)
  tmpTime - mFirstTimespec + mEffectiveOffset

so we take out the first timespec of this WLF dir (say), which gives
us the trace time relative to that, and then add the effective offset,
which gives us 'global harmonious time'.

[277:

Thu Jul  2 06:47:06 2020 So where in the code is netTimeOffset being
computed? [278:

Thu Jul  2 06:47:55 2020 In WLF::readSequential, at least.  Right now
it's just the effective offset.  We have to subtract the first
timespec.[279:

Thu Jul  2 06:50:06 2020 But at the moment we only know how to
subtract UniqueTimes, not struct timespecs.  But UniqueTime doesn't
allow negative results, right?[280:

Thu Jul  2 06:51:59 2020 Yeah, UniqueTime::operator-(rhs) asserts that
*this >= rhs..  And it does the seconds arithmetic in u32.[281:

Thu Jul  2 06:55:18 2020 And it looks like struct timespec.tv_sec is
declared a time_t, which can, apparently be either signed or unsigned.
A highly-rated answer on SO says unix uses signed, but 'some systems
correctly handle negative time values, while others do not'.
[282:

Thu Jul  2 06:58:56 2020 So what do we do?  Pass a double, ick?  Pass
two timespecs?  Maybe.  Just pass mfirstTimespec, and have caller
apply the mEffectiveOffset?  Defensible.  Yeah maybe let's try
that.[283:

Thu Jul  2 07:07:52 2020 Ah whoops.  Just one small issue:
Trace::mLocalTimestamp is const.

OK screw it pass in two timespecs.[284:

Thu Jul  2 07:12:35 2020 But can't we be sure that netTimeOffset is
never negative?  It's supposed to be the ..  Ah, no, we absolutely
can't: If the tile A clock happened to be set to like 1/1/1970, but
after alignment, the tile B trace data extended farther into the
relative past, then (mFirstTime - mEffectiveOffset), without the
actual trace time added in, could definitely be negative.

OK two timespecs.[285:

Thu Jul  2 07:33:16 2020 OK, two timespecs sorted out the individual
file case.  Let's try out the directory case now..[286:

Thu Jul  2 07:38:27 2020 Well, the single directory case looks okay.
I guess I could try the single directory twice as a test..[287:

Thu Jul  2 07:39:36 2020 Actually I can't, because it detects multiple
anchor files -- as it should -- and horks.  Good Weaver, good!

:287]

:286]

:285]

:284]

:283]

:282]
:281]

:280]

:279]

:278]

:277]

:276]

:275]

:274]

:273]
[288:

Thu Jul  2 07:45:25 2020 So, I guess we should think about committing
all this, and getting towards letting a rolling tracer run until it
does bomb out, and then see if we can learn something![289:

Thu Jul  2 07:48:26 2020 Oh we should probably recheck the trace
unparsing stuff first; there's something off there.[290:

Thu Jul  2 07:59:16 2020 Just a bad printf format mostly.

:290]

:289]

:288]
[291:

Thu Jul  2 13:50:13 2020 Well, flag moved, and we did a long two-tile
run with the new rolling trace buffers, which finally hit FAILs.

Now, the normal pattern is that one tile blows up with some kind of
inconsistency, and then, because it's at a breakpoint and not
responding, the other tile blows up with a timeout soon after, usually
in AWACKS.

So what happened this time?  They.. BOTH.. blew up with timeouts in
AWACKS..

[292:

Thu Jul  2 13:55:33 2020 So I guess we're guessing either

(1) The timeout is too short, and one blew up 'naturally', which took
    the other down afterwards, or

(2) There's some kind of resource starvation -- leaking aEWs or
    something perhaps -- that's slowing things down so much that the
    perfectly reasonable timeout finally hit.

Well, let's get the rolling trace buffers together and see what we can
see..  Code 202007021359

:292]



:291]
[293:

Thu Jul  2 17:19:28 2020 Well, pretty aggravating -- I think I have a
pretty clear case that there's no possible consistent alignment
between two trace files.

But made a bunch of tweaks while running a lot of Weaver, and have now
upped the timeouts a little in case that was the problem.

Committing, to go again.

:293]
[294:

Fri Jul  3 04:47:07 2020 Well, left that pair running over the evening
break.  When I got back to it around midnight it was stopped and had
been since quarter to eleven.  With the standard AWACKS timeout on
WHITE and... a kernel panic on RED?

Couldn't reconstruct too much detail -- and the systemd log was
apparently corrupted big surprise -- but ITC_PktShipr was mentioned in
the oops output, but no file/line info.  Looking through itcpkt.c I
don't see a lot of BUG_ON but who knows.

I also saw some evidence of a disk I/O error, which seems certainly
plausible.  But no clear proof of anything.

Which does highlight a problem with using /tmp for trace data, since
we have /tmp getting cleared on reboot.  Which is a good thing.  I
think we need to manage a dir of rolling dirs on our own.

[295:

Fri Jul  3 04:52:04 2020 Anyway, I couldn't find any distinct smoking
gun, so I just restarted the pair and they've been going for a few
hours here -- up to around 400K log messages, and 258.dat in the
rolling trace dir.  So far so good.

:295]

:294]
[296:

Fri Jul  3 08:18:52 2020 Well, we're up over a million log messages
and I need to stop this run so I can try out the new
EventStatsSnapshot trace record.

I'm going to call this run a success!

:296]
[297:

Fri Jul  3 09:31:29 2020 We also need to start refreshing an inventory
of atomic types, and get a stats window going.

I think we should build an atomic histogram during redisplay, since we
hit all the atoms at that point anyway.  We will not try to
incrementally update the counts as we go; we'll just recount from
scratch on every redisplay, and display the latest result when we need
it.

Hmm, do we actually avoid the site iteration when the Sites panel is
not visible?  I suspect we don't.. right?

:297]
[298:

Sat Jul  4 08:08:29 2020 OK, so we're working our way through getting
the ITC status plausibly showing on the T2InfoPanel, and we've gotten
as far as needing to 'XXXFIXMEXXX' the kernel stats showing up in
/sys/class/itc_pkt/statistics.

That stuff got messed up with the recent T2-PHF redo, and now we need
to figure out what we want and can have the stats to say.

The previous header said something like

dir psan sfan toan blkbsent blkbrcvd blkpsent blkprcvd urgbsent urgbrcvd urgpsent urgprcvd

0 direction
1 packet sync announcements
2 sync failure announcements
3 timeout announcements
4 bulk bytes sent
5 bulk byts received
6 bulk packets sent
7 bulk packets received
8 urgent bytes sent
9 urgent bytes received
10 urgent packets sent
11 urgent packets received

[299:

Sat Jul  4 09:52:38 2020 But now instead of bulk/urgent the high-order
bit is MFM/non-MFM, and both cdm and flash traffic are considered
'bulk'.  (So much for flash traffic.)  And the LKM is counting
MFM/non-MFM, or no?[300:

Sat Jul  4 09:59:14 2020 On outbound anyway, the distinction is based
on the KIFO being marked 'mPriority' or not, with the resulting stats
being marked TRAFFIC_MFM if so and TRAFFIC_SERVICE if not.[301:

Sat Jul  4 10:01:31 2020 Same for inbound, no surprise.  But to be
explicit, on inbound we are indeed checking PKT_HDR_BITMASK_MFM to
make that distinction.[302:

Sat Jul  4 10:03:02 2020 So we should just change the
/sys/class/itc_pkt/statistics labels to 'm' for mfm and 's' for
service, and then go looking downstream for the users of that
file. [303:

Sat Jul  4 10:11:31 2020 Which appears primarily to be the enum at
ITCStatus.h:25..

:303]

:302]

:301]

:300]

:299]
:298]
[304:

Sun Jul  5 04:00:30 2020 OK got a pWEsn==CACHE instead of IDLE failure
while logs were rolling -- but only on one tile, rats -- so let's take
a look at that.  Code 202007050401

:304]
[305:

Sun Jul  5 04:16:18 2020 OK, so at 346.335361 secs (relative to the
rolling buffer start), a RING#17 packet arrived on 0/iNW, targetting
(11,3)+4.

0/pNW17 was launched to handle it, and an ANSWER#17 reply resulted:

│346.335361 0/iNW:OPEN <NW:RING#17(11,3)+4e +5                                             │
│346.335438 0/lDBG ITC/NW:OPEN: HRP abs(11,3) themrel(11,3) yoink=0                        │
│346.335493 0/pNW17-IDLE -> PINIT                                                          │
>346.635338 0/pNW17-PINIT p@(11,3)+4                                                       │
│346.635375 0/pNW17-PINIT NW CS_BOUND -> CS_RUNG                                           │
│346.635394 0/pNW17-PINIT -> PRESOLVE                                                      │
│346.635564 0/pNW17-PRESOLVE -> PWCACHE                                                    │
│346.645799 0/iNW:OPEN >NW:ANSWER#17 +2                                                    │
│346.645935 0/pNW17-PWCACHE NW CS_RUNG -> CS_ANSWERED

Then at 346.721227 seconds, a(n associated) RING#17 arrived on 0/iNE,
targetting (34,3)+4, and it too was ANSWER#17ed:

│346.721227 0/iNE:OPEN <NE:RING#17(35,3)+4e +5                                             │
│346.721372 0/lDBG ITC/NE:OPEN: HRP abs(59,3) themrel(35,3) yoink=0                        │
│346.721492 0/pNE17-IDLE -> PINIT                                                          │
│346.721515 0/pNE17-PINIT p@(59,3)+4                                                       │
│346.721535 0/pNE17-PINIT NE CS_BOUND -> CS_RUNG                                           │
|346.721552 0/pNE17-PINIT -> PRESOLVE                                                      │
│346.721632 0/pNE17-PRESOLVE -> PWCACHE                                                    │
>346.727945 0/iNE:OPEN >NE:ANSWER#17 +2                                                    │
│346.727994 0/pNE17-PWCACHE NE CS_RUNG -> CS_ANSWERED                                      │

And then for vast stretches of time -- tens of seconds -- nothing
happens to either 0/pNE17 or 0/pNW17, except that occasionally their
existence blocks some other event, such as (some unseen) 1/a22:

│368.385577 0/iNW:OPEN <NW:RING#22(18,3)+4o +5                                             │
│368.385650 0/lDBG ITC/NW:OPEN: HRP abs(18,3) themrel(18,3) yoink=1                        │
│368.385705 0/pNW22-IDLE -> PINIT                                                          │
│368.385725 0/pNW22-PINIT p@(18,3)+4                                                       │
│368.385744 0/pNW22-PINIT NW CS_BOUND -> CS_RUNG                                           │
│368.385761 0/pNW22-PINIT -> PRESOLVE                                                      │
>368.385861 0/lDBG RRFP-1 pNW22-PRESOLVE BUSYed by pNW17-PWCACHE                           │
│368.390407 0/iNW:OPEN >NW:BUSY#22 +2                                                      │
│368.390469 0/pNW22-PRESOLVE -> IDLE                                                       │

It seems clear that the (inferred but uncaptured grr) 1/a17 on the far
side is long long gone, but it either somehow failed to notify 0/pNE17
and 0/pNW17, or it did but, I guess conceivably, BOTH those packets
were somehow lost.[306:

Sun Jul  5 04:44:45 2020 And, finally, another RING#17 arrived, and
the inconsistency was detected:

>369.088971 0/iNW:OPEN <NW:RING#17(18,3)+4e +5                                             │
│369.089142 0/lDBG ITC/NW:OPEN: HRP abs(18,3) themrel(18,3) yoink=0                        │
│16688.902212 0/t  Failed to top: src/T2ITC.cpp:198: ILLEGAL_STATE [4]                     │
│16690.994965 0/t  sec=38,621; tot=75,097,419; emp=74,349,143; occ=628,695; estAER=1.263916│
│16690.995023 0/t  File sync mark -?499DEAF7                                               │
│16690.995035 0/t  TRACE STOP                                                              │

[307:

Sun Jul  5 06:19:36 2020 And that tells us very very little about what
was going on on the active side that lead to this outcome.  :(

But nonetheless, big progress and time to commit again.

:307]

:306]

:305]
[308:

Sun Jul  5 11:49:15 2020 OK I think I have an idea about the
"irreversibility of vertical bouncing" that I've observed with the
current turn-at-edge-of-universe bein I've been using.

It goes like this:

               +-----------------+              +-----------------+
               |.   happy south- |              |                 |
               |.   going bein   |              |                 |
(1)            |v                |     (2)      |.                |
               |                 |              |.                |
               +-----------------+              +-----------------+
     +-----------------+              +-----------------+
     |                 |              | goes     .      |
     |                 |              | inter-   .      |
     |                 |              | tile no  v      |
     |                 |              | problem         |
     +-----------------+              +-----------------+


               +-----------------+              +-----------------+
               |                 |              |                 |
               |                 |              |                 |
(3)            |                 |     (4)      |                 |
               |                 |              |                 |
               +-----------------+              +-----------------+
     +-----------------+              +-----------------+
     | reaches         |              | & happens       |
     | edge of         |              | to head         |
     | universe        |              | back up  ^      |
     |          v      |              | north    .      |
     +-----------------+              +-----------------+



               +-----------------+              +-----------------+
               |                 |              |                 |
               |                 |              |                 |
(5)            |                 |     (6)      |                 |
               |                 |              |                 |
               +-----------------+              +-----------------+
     +-----------------+              +-----------------+
     | back at  ^      |              | but it   . . >  |
     | the site .      |              | turns           |
     | it came  .      |              | instead of      |
     | in at           |              | going on through|
     +-----------------+              +-----------------+


And the question has always been: Why does it turn in (6)?

And the answer has always been: It must see the site to its north as
not live -- but why?

And now we say it's somehow got to be because the lower tile's NW ITC
is closed.  That has to be interfering with the liveness determination
somehow, right?  That's what wouldn't be seen -- at least not in any
way directly, by the upper tile's SW ITC.

[309:

Sun Jul  5 12:03:21 2020 Have to go finish and ship this month's
Computing Up, but look at this afterwards, or whenever time opens up.

[310:

Sun Jul  5 12:09:00 2020 (Peeking now while files move.)

tryInitiateActiveEvent
 -> checkSiteAvailabilityForActive
 -> iterate over affected sites
 -> this code:

      // For cache and visible, also assess and accumulate ITC
      // involvements.  NOTE that 'ITC registration' does NOT
      // necessarily imply 'lock needed': We register even with
      // ITCSN_SHUT, so they know about us in case they start to open.

      bool isLive = true;
      for (u32 dir6 = 0; dir6 < DIR6_COUNT; ++dir6) {
        if (tile.getVisibleAndCacheRect(dir6).Contains(site)) {
          T2ITC & itc = tile.getITC(dir6);
          if (!itc.isVisibleUsable()) return false; // Sorry folks, this exhibit is closed
          registerWithITCIfNeeded(itc);
          if (itc.getCacheRect().Contains(site) && !itc.isCacheUsable())
            isLive = false; // Exhibit's working but that site is currently dead
        }
      }

so, we're thinking tile.getVisibleAndCacheRect(dir6).Contains(site)
will be returning true for both dir6==DIR6_NE and DIR6_NW, and
suspecting that for DIR6_NW, itc.isVisibleUsable() must be returning
true, but

 itc.getCacheRect().Contains(site) && !itc.isCacheUsable()

must be returning true for the site directly north of the bein, and
thus causing that site to be marked as not live.
[311:

Sun Jul  5 12:18:57 2020 (Files still moving grrr.)  So to be
completely specific to the case at hand, the south-going bein in the
upper tile would have been travelling down column 4 in upper tile
coordinates.

When it went intertile it would have arrived at (28,4) -- I believe --
in lower tile coordinates.

When it was heading back north after bouncing, it would arrive once
again at (28,4), and it would ask about the status of (28,3).

And (28,3) will be reported as in both NW cache and NE cache.

And NW cache will report it is unusable, because NW is closed.

But NE will or would have reported it available, because NE is open.

That's the problem for sure.  We need a logical-OR, not the current
(implicit) logical-AND, on the isLive computation.

A cache site is live if AT LEAST ONE involved ITC is OPEN, and no
involved ITC is unsettled.
[312:

Sun Jul  5 12:31:54 2020 (Jeez files STILL moving.)

In other words, perhaps something more like this code:

      bool isLive = false;
      for (u32 dir6 = 0; dir6 < DIR6_COUNT; ++dir6) {
        if (tile.getVisibleAndCacheRect(dir6).Contains(site)) {
          T2ITC & itc = tile.getITC(dir6);
          if (!itc.isVisibleUsable()) return false; // Sorry folks, this exhibit is closed
          registerWithITCIfNeeded(itc);
          if (itc.getVisibleRect().Contains(site) || itc.isCacheUsable())
            isLive = true; // That site is visible, or is accessible via this cache
        }
      }
[313:

Sun Jul  5 12:38:42 2020 Nope, that's not QUITE it :)... That allows
one open ITC to declare a closed neigbor's visible sites as
accessible, and the bein marches off into the void.  What we want is
to say if it's in any itc's cache and THAT itc says isCacheUsable,
then yes.

If it's not in anybody's cache, then it's also live if it's visible,
unless it's in any itc's visible and THAT itc says !isVisible usable.

So we're going to compute isVisible and isInUsableCache separately,
and then say (isVisible || isInUsableCache) afterwards?
[314:

Sun Jul  5 12:51:20 2020 So the confusing part of this is the code is
saying itc.isVisibleUsable() and itc.getVisibleRect().Contains(site),
but what we really want to know is if the site is in the neighboring
ITC's visible, not if it's in our ITC's cache.  Because our ITC's
cache covers visible sites of MULTIPLE neighbors, only some of which
might be open.[315:

Sun Jul  5 12:56:16 2020 Should we just make an additional rectangle
-- say, getNeighborVisibleRect()?  It's not quite equivalent to
anything we already have?[317:

Sun Jul  5 19:41:02 2020 So, one question is: Why do the existing
'visible' rectangles include obviously cached sites?

          VIZ                    CCH                    ALL
    ET 0: (48, 0)-(51,39)  4x40  (52, 0)-(55,39)  4x40  (48, 0)-(55,39)  8x40

For example, Y==0..39 includes the cache rows 0..3 and 36..39 -- why?

..Dunno.  But I'm afraid to change it now.[318:

Sun Jul  5 20:12:13 2020 Seems like it should be

          VIZ                    CCH                    ALL
    ET 0: (48, 4)-(51,35)  4x32  (52, 0)-(55,39)  4x40  N/A

and so forth.  And the 'getNeighborVisibleRect()', if we needed it,
would be the direct shift of the 4x32 viz:

          (52,4)-(55,35)

:318]

    SE 1: (24,32)-(55,35) 32x 4  (24,36)-(55,39) 32x 4  (24,32)-(55,39) 32x 8
    SW 2: ( 0,32)-(31,35) 32x 4  ( 0,36)-(31,39) 32x 4  ( 0,32)-(31,39) 32x 8
    WT 3: ( 4, 0)-( 7,39)  4x40  ( 0, 0)-( 3,39)  4x40  ( 0, 0)-( 7,39)  8x40
    NW 4: ( 0, 4)-(31, 7) 32x 4  ( 0, 0)-(31, 3) 32x 4  ( 0, 0)-(31, 7) 32x 8
    NE 5: (24, 4)-(55, 7) 32x 4  (24, 0)-(55, 3) 32x 4  (24, 0)-(55, 7) 32x 8


:317]
[316:

Sun Jul  5 13:13:33 2020 (Files FINALLY moved SHEESH.)

:316]
:315]

:314]
:313]
:312]
:311]

:310]

:309]

:308]
[319:

Mon Jul  6 06:37:31 2020 OK, so getNeighborOwnedRect() is seeming
pretty plausible.  It even almost seems sensible that it's different
than either visible or cache rects.  We even have our command line
switch -mitc updated for it:

      VIZ                    CCH                    ALL                    NGB
ET 0: (48, 0)-(51,39)  4x40  (52, 0)-(55,39)  4x40  (48, 0)-(55,39)  8x40  (52, 4)-(55,35)  4x32
SE 1: (24,32)-(55,35) 32x 4  (24,36)-(55,39) 32x 4  (24,32)-(55,39) 32x 8  (28,36)-(55,39) 28x 4
SW 2: ( 0,32)-(31,35) 32x 4  ( 0,36)-(31,39) 32x 4  ( 0,32)-(31,39) 32x 8  ( 0,36)-(27,39) 28x 4
WT 3: ( 4, 0)-( 7,39)  4x40  ( 0, 0)-( 3,39)  4x40  ( 0, 0)-( 7,39)  8x40  ( 0, 4)-( 3,35)  4x32
NW 4: ( 0, 4)-(31, 7) 32x 4  ( 0, 0)-(31, 3) 32x 4  ( 0, 0)-(31, 7) 32x 8  ( 0, 0)-(27, 3) 28x 4
NE 5: (24, 4)-(55, 7) 32x 4  (24, 0)-(55, 3) 32x 4  (24, 0)-(55, 7) 32x 8  (28, 0)-(55, 3) 28x 4

Time to commit, stop hacking, and move on to the day and to t2sup
prep.

Actually, can we hack our test bein so that it might reproduce a
little?  Make a slightly more fun demo?[320:

Mon Jul  6 07:10:01 2020 OK now our bein starts taking reproduction
shots after some small count of edge-of-universe interactions.  And
we're up to like 77 beins on the one tile that's running that code.

Can we advance the estAER-in-the-Tile-window story before we commit?
Didn't we start that?[321:

Mon Jul  6 10:37:36 2020 Well that took a while but OK we have some
kind of middle-speed AER estimate in the Tile window.  Not at all
confident in it yet but we'll see.

Committing.

(We're up to 73% beins 26% empty in our working tile, with just the
reverse -- 26% beins 73% empty, weird -- in the neighboring tile, and
we haven't yet locked up or crashed..  Just sayin.)

:321]

:320]

:319]
[322:

Sat Jul 25 03:34:49 2020 Well here we are again finally, after
ALIFE2020 and t2sup and waffling and fidgeting because coming back
and working on this stuff is so painful![323:

Sat Jul 25 03:41:47 2020 Adding a 'Boot' reboot button and an 'Off'
poweroff button[324:

Sat Jul 25 04:11:08 2020 OK, trying the reboot button..
[325:

Sat Jul 25 04:15:24 2020 Seemed to work okay.  Might be nice to try to
shut the engine down rather than 'just go', but ..  not now.  Got too
many fish to fry.

Committing this stuff.

Then let's have a status check and round of to-do construction..

:325]
:324]

:323]

:322]
[326:

Sat Jul 25 13:17:41 2020 OK, a few developments (plus some sleep):

 - I was freaking here because my :322:+ changes to this notes file
   had vanished and I couldn't get them back, even though they were
   clearly in the repo on github.

   = DIAGNOSIS: cdm.pl had gotten around to overwritting /home/t2/MFM
     with the official cdm-MFM.mfz file it found in /cdm/common

   = SOLUTION: I think, just need to be careful to have an up-to-date
     tag file (specifically, ~/cdmd-MFM.mfz-cdm-install-tag.dat, which
     currently contains (and needs to) 1594052102.

 - I lucked out and caught a tile having the kernel panic while I was
   connected to its serial port, and minicom had enough scrollback for
   me to see this:

    [ 2065.384380] Empty pkt? OB kfifolen = -1 but pktlen = 0 (kfifo a27e561)
    [ 2065.401594] ------------[ cut here ]------------
    [ 2065.406268] kernel BUG at /home/t2/T2-12/pru/itcio/module/itcpkt.c:28!

  which was enough to begin localizing the issue.  It's in
  itcOBPktThreadRunner (AKA 'ITC_PktShipr')
   -> shipCurrentOBPackets
    -> shipAPacketToPRU
     -> sendPacketViaRPMsg

  = DIAGNOSIS: Incomplete, but the 'kfifolen = -1' is the proximal
    problem.  That 'should be impossible'.  By looking at the kfifo
    source:

        #define kfifo_len(fifo) \
        ({ \
                typeof((fifo) + 1) __tmpl = (fifo); \
                __tmpl->kfifo.in - __tmpl->kfifo.out; \
        })

    it suggests that kfifo.out has passed kfifo.in, which we presume
    means we overflowed that kfifo sometime previously.  Where, we
    don't yet know, but we now have something specific to look for, in
    the outbound packet workflow.

  = SOLUTION: Pending complete diagnosis.
[331:

Sat Jul 25 14:39:40 2020 So, shipAPacketToPRU has two calls on
sendPacketViaRPMsg, and we don't know which call lead to the panic.  I
want to think it's mPriorityOB, but we did think we saw cdm's moving
too.

[332:

Sat Jul 25 14:45:36 2020 Currently we see:

    root@beaglebone:~# cat /sys/class/itc_pkt/statistics
    dir psan sfan toan mfmbsent mfmbrcvd mfmpsent mfmprcvd svcbsent svcbrcvd svcpsent svcprcvd
    0 0 0 0 0 0 0 0 0 0 0 0
    1 1 0 0 7487 300272 791 2284 62192 84331 1156 1542
    2 1 0 0 6849 326451 744 2243 60393 86422 1124 1586
    3 1 0 0 9680 0 4840 0 212 0 53 0
    4 0 0 0 0 0 0 0 0 0 0 0
    5 1 0 0 9400 274740 752 2146 62945 120672 1166 2185
    6 1 0 0 9652 313571 765 2171 61005 87459 1126 1598
    7 1 0 0 4138 59726 522 999 61753 101296 1141 1849
    root@beaglebone:~#

so there is service traffic moving, in the 10KB-100KB range, in
addition to mfm traffic.

But come on, let's just take a quick look at writers to mPriorityOB.
The fact that we're seeing 'kfifolen = -1' suggests a genuine
off-by-one problem could be it..[333:

Sat Jul 25 14:55:03 2020 So, in trySendMFMRoutedKernelPacket we have:

      if (kfifo_avail(&ipb->mFIFO) < count) return -EAGAIN; /* Never block */
      ret = kfifo_in(&ipb->mFIFO, pkt, count); /*0 on no room else count*/

      wakeOBPktShipper(); /* if we got this far, kick the linux->pru thread */

      return ret ? ret : -ENOSPC;

and I note a couple things:

 - It could be 'if (kfifo_avail(&ipb->mFIFO) <= count)' if we wanted
   to be safer, and

 - We go to wakeOBPktShipper without checking if ret is zero
[334:

Sat Jul 25 15:14:51 2020 So looking at __kfifo_in_r, it makes me think
that it's up to us -- caller -- to take the packet-length-overhead
into consideration when we're checking if there's enough room to
insert a packet.

It says:

	if (len + recsize > kfifo_unused(fifo))
		return 0;

	__kfifo_poke_n(fifo, len, recsize);

	kfifo_copy_in(fifo, buf, len, fifo->in + recsize);
	fifo->in += len + recsize;
	return len;

(and recsize == 1 for our case).  We say

  if (kfifo_avail(&ipb->mFIFO) < count) return -EAGAIN; /* Never block */

where count is just exactly our packet length, not our packet length
plus one.

What's the difference between kfifo_avail and kfifo_unused?
[335:

Sat Jul 25 15:20:38 2020 Well, we see

    static inline unsigned int kfifo_unused(struct __kfifo *fifo)
    {
            return (fifo->mask + 1) - (fifo->in - fifo->out);
    }

and

    #define	kfifo_avail(fifo) \
    __kfifo_uint_must_check_helper( \
    ({ \
            typeof((fifo) + 1) __tmpq = (fifo); \
            const size_t __recsize = sizeof(*__tmpq->rectype); \
            unsigned int __avail = kfifo_size(__tmpq) - kfifo_len(__tmpq); \
            (__recsize) ? ((__avail <= __recsize) ? 0 : \
            __kfifo_max_r(__avail - __recsize, __recsize)) : \
            __avail; \
    }) \
    )

And I do not want to try unpacking that foggen kfifo_avail.

[336:

Sat Jul 25 15:30:17 2020 Let's just examine our kfifo_ins and such
with an eye towards thinking we always need one more byte than the
length of our packet, and see what we find.[337:

Sat Jul 25 15:37:16 2020 (Need to remember mEvent is a fixed-size u32
kfifo -- it does not have the record-length overhead.)

:337]

:336]

:335]

:334]

:333]

:332]

:331]
:326]
[327:

Sat Jul 25 13:46:44 2020 And watch out!  /home/t2/T2-12 (sometime
quite recently) got overwritten by our industrious cdm.  Need to git
clone a new tree there too..

[328:

Sat Jul 25 13:48:51 2020 Could we have 'make cdmd' automatically
update the relevant tag file(s) to protect the repos we're working in?

:328]

:327]
[329:

Sat Jul 25 13:50:00 2020 Ooh I bet we need to be careful about not
updating packages, with a brand-new cloned T2-12 repo.[330:

Sat Jul 25 14:13:05 2020 So it looks like 'make cdmd' excludes .git
files, so could we perhaps have cdm.pl choose not to overwrite dest
dirs if a .git/ exists in the destination?  Or is that too implicit?

:330]

:329]
[338:

Sat Jul 25 15:38:42 2020 Woah, just saw an engine failure out of the
blue on this very tile!  But it involved packet problems the LKM saw:

    Jul 25 15:17:01 beaglebone CRON[3559]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
    Jul 25 15:37:26 beaglebone kernel: [ 8470.846038] (WT) Packet overrun reported on size 229 packet
    Jul 25 15:37:26 beaglebone kernel: [ 8470.851745] (WT) Packet error reported on size 229 packet
    Jul 25 15:37:26 beaglebone kernel: [ 8470.905538] (WT) Packet overrun reported on size 229 packet
    Jul 25 15:37:26 beaglebone kernel: [ 8470.911233] (WT) Packet error reported on size 229 packet
    Jul 25 15:37:26 beaglebone mfm.sh[1679]: Failed out of top-level
    Jul 25 15:37:26 beaglebone kernel: [ 8470.954248] (WT) Packet overrun reported on size 229 packet
    Jul 25 15:37:26 beaglebone kernel: [ 8470.959921] (WT) Packet error reported on size 229 packet
    Jul 25 15:37:29 beaglebone mfm.sh[1679]: src/ITCIterator.cpp:11: FAILED: ILLEGAL_STATE
    Jul 25 15:37:29 beaglebone mfm.sh[1679]: Failed out of main
[341:

Sat Jul 25 15:52:40 2020 Now I'm a little confused how we get a packet
overrun on a packet that's much less that 255 bytes long..  Wondering
if it could possibly be confusion from the kfifo len problems we're
currently investigating.

:341]
Unfortunately we don't get the failure itself logged.  Why do we see
the useless src/ITCIterator.cpp:11 failure -- coming from attempting
to close the ITCs under stress -- but we don't see whatever lead to
failing out of top level?  Something different between the two
unwind_protects? [339:

Sat Jul 25 15:48:19 2020 I guess it's the earlier one doesn't have this:

      MFMPrintErrorEnvironment(stderr, &unwindProtect_errorEnvironment);

but why doesn't it?
[340:

Sat Jul 25 15:52:13 2020 Well now it does.  We'll see.

:340]
:339]

:338]
[342:

Sat Jul 25 16:18:44 2020 OK, about time to go start dinner, but: We
just finished going through all hits for 'kfifo_' in
pru/itcio/module/*.[ch], and indeed we made a few changes like:

    -  if (kfifo_avail(&ipb->mFIFO) < count) return -EAGAIN; /* Never block */
    +  if (kfifo_avail(&ipb->mFIFO) < count + 1) /* Need +1 for packet length byte in fifo */
    +    return -EAGAIN; /* Never block */

and

    -    while (kfifo_avail(&ipb->mFIFO) < count) {
    +    while (kfifo_avail(&ipb->mFIFO) < count + 1) { /*Need +1 for packet length byte in kfifo */

Going to commit it defensively at least.

:342]
[343:

Sun Jul 26 00:11:25 2020 Well, let's see if we can get a cdmd
production flow that preserves our work tile repos but lets the
updates get out into our mini grid, here.

How do we think that could work?

 - Where does the cdm install tag value come from?[344:

Sun Jul 26 00:24:29 2020 Apparently it's the 'inner timestamp' from
the cdmd itself.  And that's defined when the cdmd is created: Maybe
we could do this in Makefiles.[345:

Sun Jul 26 00:47:10 2020 So 'checkMFZDataFor' in cdm.pl seems to be
parsing out the innerTimestamp.

:345]

:344]

 - Could we make a special cdmctl function that sets up the tag
   without installing the file locally?[346:

Sun Jul 26 00:50:28 2020 OK, so this command seems pretty key:

    t2@beaglebone:~$ /home/t2/MFM/bin/mfzrun -kd /cdm /cdm/common/cdmd-MFM.mfz VERIFY
    SIGNATURE_CHECK [OK]
    INNER_CHECKSUM [413536-cd1e-0e467d]
    INNER_TIMESTAMP [1594073702]
    SIGNING_HANDLE [t2-keymaster-release-10]
    HANDLE_FINGERPRINT [85ee-b41-7cb3]
    HANDLE_PUBKEY [-----BEGIN RSA PUBLIC KEY-----
    MIGJAoGBAMUbUl/GDrkKYB3ORkeetZEkKisfgiwl6TgoqAB7dfK1gGN3bzDyz/+A
    LisTyW0b+64ePqv1liBxJEBOd2eX9+hTnngasOrb8RIQN6vTPg6+3WGAmgtez3kg
    5KSeBLlgMaEbKkeOXZU+pbAaUzL6EGr/O/ESdTE6Lh6azq2DR3P7AgMBAAE=
    -----END RSA PUBLIC KEY-----
    ]
    t2@beaglebone:~$

[347:

Sun Jul 26 00:52:11 2020 Although in that context this is a little
distressing:

    t2@beaglebone:~$ cat cdmd-MFM.mfz-cdm-install-tag.dat
    1594052102
    t2@beaglebone:~$

[348:

Sun Jul 26 00:55:03 2020 Eeew, look:

    t2@beaglebone:~$ perl -e 'printf("%f\n",1594073702-1594052102)'
    21600.000000
    t2@beaglebone:~$ perl -e 'printf("%f\n",(1594073702-1594052102)/60.0/60.0)'
    6.000000
    t2@beaglebone:~$

The install tag time is _exactly_ six hours earlier than the mfzrun
inner timestamp, which is _exactly_ the GMT to Mountain Time offset.

So we _think_ this disgusting hack in cdm.pl --

    #### REPLACE THIS WITH 'mfzrun VERIFY' ONCE AVAILABLE
 ..
    my $strp = DateTime::Format::Strptime->new(
        pattern   => '%a %b %e %H:%M:%S %Y',
        );
    my $dt = $strp->parse_datetime( $timestamp );
    my $epoch = $dt->strftime("%s");
 ..

is giving us local time, which ends up in the tag?

[349:

Sun Jul 26 03:08:24 2020 OK, so we've made an attempt at switching to
'mfzrun VERIFY', which we think would solve the timezone screwup..
We've committed and pushed on T2-12 in case cdm tries to reinstall
over our repos again.  But we think if all this untested code is
plausible, we ought to be able to do VERIFY on the existing cdmds, and
copy the inner timestamp to the tag files, and cdm ought to leave us
alone.

OUGHT TO LEAVE US ALONE.

[350:

Sun Jul 26 03:32:53 2020 Committing these notes.

:350]

:349]

:348]

:347]
:346]

:343]
[351:

Sun Jul 26 03:51:06 2020 Well, had a bug or two in the new code, but
it appears manually updating the tag files did indeed save our
repos..

Now, what is supposed to be the workflow for releasing a new cdmd?
And how shall we modify it to Save The Repos (TM)?[352:

Sun Jul 26 04:08:17 2020 Well, T2-12/apps/cdm/cdmctl appears not to be
involved.  So far it's all about deletions:

my %cmds = (
    "help" => \&doHelp,
    "delete" => \&doDelete,
    "listdeleted" => \&doListDeleted,
    "initmap" => \&doInitMap,
    );

So do we just stick a new cdmd in common and let cdm.pl sniff it up?

Let's make up a procedure and try it for T2-12.  That's the one we'd
like to push the most right now, and it's a LOT smaller than the
absurd MFM one..

[353:


Sun Jul 26 04:10:42 2020

HOW TO RELEASE cdmd-T2-12.mfz:

(0) Be on the keymaster

(1) Get /home/t2/T2-12 exactly the way you want it, and make sure
    everything is committed and pushed and the tree is clean

(2) Do
      # cd /home/t2/T2-12
      # make cdmd
    and check it seems to've worked properly

(3) On a connected machine, perhaps do
      $ cd /data/ackley/PART4/hardware/T2-Tile-Project/CDM-TGZS-BACKUP
      $ ./scripts/T2PullCode IP.OF.KEY.MASTER
    and see if the cdmd just made arrives in
    /data/ackley/PART4/hardware/T2-Tile-Project/CDM-TGZS-BACKUP/CDMSAVE/CDMDS/
    [355: Sun Jul 26 04:45:56 2020 E.g., can do:

        .../hardware/T2-Tile-Project/CDM-TGZS-BACKUP$ /data/ackley/PART4/code/D/MFM/bin/mfzrun CDMSAVE/CDMDS/cdmd-T2-12.mfz VERIFY
        SIGNATURE_CHECK [OK]
        INNER_CHECKSUM [3b2dfe-b23f-60ed9f]
        INNER_TIMESTAMP [1595760220]
        SIGNING_HANDLE [t2-keymaster-release-10]
        HANDLE_FINGERPRINT [85ee-b41-7cb3]
        HANDLE_PUBKEY [-----BEGIN RSA PUBLIC KEY-----
        MIGJAoGBAMUbUl/GDrkKYB3ORkeetZEkKisfgiwl6TgoqAB7dfK1gGN3bzDyz/+A
        LisTyW0b+64ePqv1liBxJEBOd2eX9+hTnngasOrb8RIQN6vTPg6+3WGAmgtez3kg
        5KSeBLlgMaEbKkeOXZU+pbAaUzL6EGr/O/ESdTE6Lh6azq2DR3P7AgMBAAE=
        -----END RSA PUBLIC KEY-----
        ]
        .../hardware/T2-Tile-Project/CDM-TGZS-BACKUP$

    :355]

(4) Do
      $ /home/t2/MFM/bin/mfzrun -kd /cdm ~/cdmd-T2-12.mfz VERIFY
    and find the inner timestamp, like 'INNER_TIMESTAMP [1594073702]'

(5) Stuff it into the tag file, like
      $ echo 1594073702 > ~/cdmd-T2-12.mfz-cdm-install-tag.dat

(6) If all looks okay, 'release' by copying to /cdm/common:

      # cp /home/t2/cdmd-T2-12.mfz /cdm/common

    and watch syslog, or wherever you have cdm.pl reporting, to see
    if/when it picks up the modtime change on the file.

(7) Observe cautiously until something like

        INSTALL T2-12: We are up to date; nothing to do

    occurs.
    [356: Sun Jul 26 04:48:55 2020 E.g, whammo!

        root@beaglebone:/home/t2/T2-12# cp /home/t2/cdmd-T2-12.mfz /cdm/common
        root@beaglebone:/home/t2/T2-12# MODTIME CHANGE /cdm/common/cdmd-T2-12.mfz size 2598477
         /cdm/common/cdmd-T2-12.mfz: t2-keymaster-release-10 => 1595760220
        Assigning seqno 5 for cdmd-T2-12.mfz
        INSTALL found candidate T2-12 -> /home/t2
        INSTALL T2-12: We are up to date; nothing to do
        ANNOUNCED cdmd-T2-12.mfz to 4
        To NW Starting to send cdmd-T2-12.mfz (1595760220:c69fa22015)
        To SW Starting to send cdmd-T2-12.mfz (1595760220:c69fa22015)
        To SE Starting to send cdmd-T2-12.mfz (1595760220:c69fa22015)

  :356]

[354:

Sun Jul 26 04:40:38 2020 Well okay, trying :353:, we shall see.[357:

Sun Jul 26 04:49:38 2020

:357]

:354]

:353]

:352]

:351]
[358:

Sun Jul 26 04:54:06 2020 Well, so I wonder if we can shrink
cdmd-MFM.mfz a bit.  At the moment it's 28 FOGGEN MEG and takes hours
to propagate one hop.

:358]
[359:

Sun Jul 26 06:00:37 2020 Well so I've been watching cdmd-T2-12.mfz
propagate on a few tiles.  Two observations:

 - cdmd-T2-12.mfz gets installed twice on every destination!  The
   first time it gets installed, it's the old cdm.pl running, which
   uses the localtime for the tag file.  Then cdm.pl restarts
   automatically, and the new cdm.pl assumes the tag file is GMT (as
   it should), and observes the tag file is (precisely six hours)
   obsolete, and it installs again.  And then it restarts again, and
   then things are stable.

 - The tile does not reboot automatically, so although the new LKM is
   built, it doesn't actually take effect without a manual
   intervention of some kind.  What do we think about that?  Rebooting
   automatically is scary.

:359]
[360:

Sun Jul 26 06:07:06 2020 Poking around in cdmd-MFM.mfz, it looks like
I could save seven meg just by getting rid of

 -rw-r--r--       0/0       7282674 MFM/res/images/mfms-icons-ZSHEET-orig.png

Is anybody even looking at that?
[361:

Sun Jul 26 06:17:41 2020 Well, I git rm'd it.  We shall see.  Trying

    /home/t2/MFM# make cdmd

after doing a 'make clean' (not realclean).  [362:

Sun Jul 26 06:18:51 2020 Result:

  -rw-r--r--  1 root root 15421782 Jul 26 06:18 cdmd-MFM.mfz
  -rw-r--r--  1 root root 15549495 Jul 26 06:17 MFM-built.tgz
  -rw-r--r--  1 t2   t2         11 Jul 26 04:47

15MB is still horrible but it's better than 28MB..[363:

Sun Jul 26 06:33:41 2020 Well, trying an optimized build, then will do
'make clean' then 'make cdmd', and then we'll see about letting cdm.pl
try to distribute that.[364:

Sun Jul 26 06:44:03 2020 Wow, well the size is certainly improved:

  -rw-r--r--  1 root root 5551433 Jul 26 06:43 cdmd-MFM.mfz



:364]

:363]

:362]

:361]
:360]
[365:

Sun Jul 26 06:49:09 2020 Auggh and I fogged it up by doing:

    t2@beaglebone:~/MFM$ echo 1595767408 ../cdmd-MFM.mfz-cdm-install-tag.dat
    1595767408 ../cdmd-MFM.mfz-cdm-install-tag.dat
    t2@beaglebone:~/MFM$

and not noticing!  Arrrrgh!.

:365]
[366:

Sun Jul 26 06:52:04 2020 Well, cloned afresh, and did manage to save
these notes, FWTW.

Committing them.

:366]
[367:

Mon Jul 27 00:06:05 2020 Ah okay, so: We still have LKM issues :( --
corruption of some kind, with our kfifo use still suspect.  On the
keymaster, we got stuff like this:

    Jul 26 09:38:33 beaglebone kernel: [ 5508.469507] Malformed locstd3 (len=20)
    Jul 26 09:38:33 beaglebone kernel: [ 5508.497351] Malformed locstd3 (len=20)
    Jul 26 09:38:33 beaglebone kernel: [ 5508.522103] Malformed locstd3 (len=20)
    Jul 26 09:38:33 beaglebone kernel: [ 5508.526052] Illegal standard local packet 29
    Jul 26 09:38:33 beaglebone kernel: [ 5508.534352] Illegal standard local packet 13
    Jul 26 09:38:33 beaglebone kernel: [ 5508.539174] Empty pkt? OB kfifolen = -2400432 but pktlen = 0 (kfifo 5c253382, prudev c061d7c8)

    Message from syslogd@beaglebone at Jul 26 09:38:33 ...
     kernel:[ 5508.563464] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP ARM

And the only thing we can think of to do at this point is:

 - Review all 'kfifo_' hits _again_ on first principles

   = In particular, checking the flows of control after an out-of-room
     situation occurred when trying to put something in a kfifo

 - Armor all writes to a kfifo, e.g., using wrapper macros of our own:

   = Check that space really is available

   = Check that the avail after the write is indeed the (availBefore -
     len - 1), for packet kfifos


 - Double check what we think are all our possible races: Interrupts,
   kthreads, and syscalls.

Sigh.

I feel like the Indians starting to whoop it up at the end of
'Temporarily Humboldt County':

Well, let's go.

Go.. go... go. GO.. GO.. GO GO GO GO (fade)

:367]
[368:

Mon Jul 27 02:45:43 2020 Well I started into kfifo armoring and did
some stuff, without apparently breaking or discovering anything
significant, and then I ended up in the time machine reading old
notes -- 201901191229-intertile-model-notes.txt in particular, which
is where the whole outbound packet shipper thread concept was first
invented.

And I see this interesting note, which I had quite forgotten:

    [210

    Thu Jun 20 01:15:05 2019 So, with variable length records such as we
    are using, kfifo_avail returns the max number of bytes YOU CAN PUT IN
    THE NEXT RECORD.  That's why I'm seeing avail==255 both before and
    after I stick stuff in a kfifo.

    210]

So that kind of undercuts my big 'off by 1 because of size' claim, at
least for anything involving kfifo_avail.[369:

Mon Jul 27 03:28:28 2020 Releasing another bein to flood stuff.  Doing
'dmesg -wH' on my two serial connections to hope to see anything
interesting new.

:369]

:368]
[370:

Mon Jul 27 23:40:21 2020 Well, added a bunch of LKM that purports to
dump info about most of our kfifos, and purportedly set it up to fire
as a drive-by when we do

   $ cat /sys/class/itc_pkt/statistics

But it's entirely untested, beyond building successfully, and I think
we ought to be extra careful here, because we're way out of practice
in LKM land, so I'm going to both WIP commit and bits off as well.

:370]
[371:

Tue Jul 28 00:39:11 2020 Well it didn't die, but it was hooked onto
something that MFM was reading every second so it spammed the log more
than I meant.  Reorged a little and moved it do
/sys/class/itc_pkt/pru_bufs..  Going again

RISKY BITS OFF.

:371]
[372:

Tue Jul 28 03:37:04 2020 OK, going to commit again.  Hacked around
with several things:

 - Making /etc/sysctl.d/T2-12-sysctl.conf with 'kernel.panic = 30' in
   it, that's supposed to cause an automatic reboot 30 seconds after a
   panic.  If it avoids blowing the disk journal after a panic that
   could be quite helpful, and we're obviously going to need 'nonstop'
   service down the road no matter what.

 - New buttons so we can build non-splitting (#1) and splitting (#2)
   beins without recompiling.

 - Alleged auto-erase on failed event transitions

 - A new write-only /sys/class/itc_pkt/dump that triggers kfifo status
   info to syslog, with a user message.

:372]
[373:

Tue Jul 28 04:18:14 2020 Well, let's commit and push T2-12 and MFM,
try them one more time on the keymaster, then roll out new cdmd's for
them.

I want to see splits with the new kfifo logging.  Could get lucky.
Especially with the kernel.panic autoreboot thing, if that works.

:373]
[374:

Wed Jul 29 06:15:49 2020 Well, tried a bunch of things without much
new insight.

 - The autoboot stuff works, but panic reboots don't sync the disk so
   we still lose data.  The only thing that works is minicom on the
   serial port with a huge scrollback buffer.  And we only have two
   USB-serial cables with us at present (plus limited available USB
   ports).

 - Still upping the logging in itcpkt trying to improve the chances of
   seeing something helpful.  About to reboot to try another round of
   that.[375:

Wed Jul 29 06:19:44 2020 Latest anything that we caught was this (yes,
it's cleaned up from minicom scrollback):

    [31002.851701] XKFIFO OB prudev itc!pru!1, kfifo mPriorityOB, kfifolen = 3, pktlen = 0

So the problem is kfifo_len()==3 is saying there's something there,
but kfifo_peek_len()==0 is saying the next packet outbound packet is
of length 0, and that should be impossible.

    [31002.865035] DUMPITCSTATUS DUMPITCSTATUS DUMPITCSTATUS
    [31002.878107] kfifoptr---kfifoin/out------mskin/out----len-avail-mnrflg name----------------
    [31002.892839] 7de8f689         0/0            0/0       0l 255a   0   mLocalIB-itc!pru!0
    [31002.907716] 07337d5b         0/0            0/0       0l 255a   0rp mPriorityOB-itc!pru!0
    [31002.927702] b727ac4a         0/0            0/0       0l 255a   0r  mBulkOB-itc!pru!0
    [31002.953916] 6c913277         0/0            0/0       0l 255a   1   mLocalIB-itc!pru!1
    [31002.968541] 4a68b444   7129366/7129297   2326/2257   69l 255a   1rp mPriorityOB-itc!pru!1

Interestingly, by the time the status dump got this far, that same
kfifo -- mPriorityOB for PRU1 -- now has kfifo_len() == 69.

    [31002.981651] d04a4086   1503419/1503419    187/187     0l 255a   1r  mBulkOB-itc!pru!1
    [31002.995409] 9327dea3   1339328/1339328   4032/4032    0l 255a   2   mUserIB-itc!bulk
    [31003.008373] a81c968a         0/0            0/0       0l 255a   3   mUserIB-itc!flash
    [31003.022516] 16aea8a9         0/0            0/0       0l 255a   6   mUserIB-itc!mfm!ET
    [31003.035869] 606d31fc         0/0            0/0       0l 255a   7   mUserIB-itc!mfm!SE
    [31003.049713] 4245ecf8         0/0            0/0       0l 255a   8   mUserIB-itc!mfm!SW
    [31003.065295] 5a234c1a   1898075/1898075   1627/1627    0l 255a   9   mUserIB-itc!mfm!WT
    [31003.077259] d6bc9360   1691891/1691885    243/237     6l 255a   a   mUserIB-itc!mfm!NW
    [31003.090307] 33548300   2311965/2311965   1821/1821    0l 255a   b   mUserIB-itc!mfm!NE
    [31003.104486] ------------[ cut here ]------------
    [31003.112388] kernel BUG at /home/t2/T2-12/pru/itcio/module/itcpkt.c:344!

And this is the explicit BUG_ON(1) following the status dump following
the pktlen == 0..

    [31003.119033] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP ARM
    [31003.124894] Modules linked in: joydev cpufreq_userspace c_can_platform c_can can_dev fb_
    ili9486(C) fbtft(C) ads7846 evdev uio_pdrv_genirq uio iptable_nat nf_nat_ipv4 nf_nat nf_con
    ntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_mangle iptable_filter itc_pkt(O) itc(O) ip_tab
    les x_tables spidev
    [31003.150663] CPU: 0 PID: 1213 Comm: ITC_PktShipr Tainted: G         C O      4.19.79-ti-r30 #1buster
    [31003.159747] Hardware name: Generic AM33XX (Flattened Device Tree)
    [31003.165954] PC is at sendPacketViaRPMsg+0x7c/0x298 [itc_pkt]
    [31003.171655] LR is at wake_up_klogd+0x7c/0xa8
    [31003.175943] pc : [<bf048964>]    lr : [<c01ad434>]    psr: 600e0013
    [31003.182236] sp : db0c9ef8  ip : db0c9c88  fp : db0c9f34
    [31003.187482] r10: 00000003  r9 : 0000007f  r8 : db0c4040
    [31003.192730] r7 : 00000001  r6 : bf04db7c  r5 : 00000000  r4 : db0c5314
    [31003.199286] r3 : bad55a76  r2 : bad55a76  r1 : c10ff388  r0 : 0000004a
    [31003.205844] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none
    [31003.213011] Control: 10c5387d  Table: 9b1dc019  DAC: 00000051
    [31003.218786] Process ITC_PktShipr (pid: 1213, stack limit = 0x06308bbc)
    [31003.225343] Stack: (0xdb0c9ef8 to 0xdb0ca000)
    [31003.229720] 9ee0:                                                       00000000 bf04d980
    [31003.237938] 9f00: db0c9f1c c14d0adc ffffe000 db0c4040 ffffe000 bf04db7c 00000001 00000000
    [31003.246155] 9f20: 0000007f 00000002 db0c9f74 db0c9f38 bf048c44 bf0488f4 bf04d980 c1505dc8
    [31003.254372] 9f40: db0c9f74 bad55a76 c0160a5c db041540 db041e00 00000000 db0c8000 bf04dbac
    [31003.262589] 9f60: bf048b80 dc621a2c db0c9fac db0c9f78 c0160f6c bf048b8c db04155c db04155c
    [31003.270805] 9f80: 00000000 db041e00 c0160e00 00000000 00000000 00000000 00000000 00000000
    [31003.279021] 9fa0: 00000000 db0c9fb0 c01010e8 c0160e0c 00000000 00000000 00000000 00000000
    [31003.287238] 9fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    [31003.295454] 9fe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000
    [31003.303734] [<bf048964>] (sendPacketViaRPMsg [itc_pkt]) from [<bf048c44>] (itcOBPktThreadRunner+0xc4/0x188 [itc_pkt])
    [31003.314421] [<bf048c44>] (itcOBPktThreadRunner [itc_pkt]) from [<c0160f6c>] (kthread+0x16c/0x174)
    [31003.323341] [<c0160f6c>] (kthread) from [<c01010e8>] (ret_from_fork+0x14/0x2c)
    [31003.330594] Exception stack(0xdb0c9fb0 to 0xdb0c9ff8)
    [31003.335668] 9fa0:                                     00000000 00000000 00000000 00000000
    [31003.343884] 9fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    [31003.352100] 9fe0: 00000000 00000000 00000000 00000000 00000013 00000000
    [31003.358750] Code: e30a0e68 e34b0f04 eb4594c6 ebffff8e (e7f001f2)
    [31003.364887] ---[ end trace c3351d5684549665 ]---
    [31003.369528] Kernel panic - not syncing: Fatal exception

Urggh.  I understand why.. but that means all this stuff I'm showing
you, right here, is not actually anywhere on the disk.

    [31003.374791] Rebooting in 20 seconds..

And this worked.

:375]

:374]
[376:

Wed Jul 29 14:31:14 2020 So, because it's 2020, more hardware
anxieties too:

 - SETUP: Three tiles connected in a triangle:

    +--------++---------+
    |        ||         |
    |        --         |
    |on      --      off|
    |T1  sf! ||       T2|
    +----||--++--||-----+
       +-||------||-+
       | sf!        |
       |            |
       |on          |
       |KM          |
       +------------+

   = All share grid power

   = T2 is off, T1 and KM are booted

 - BEHAVIOR: The T1/SE <-> KM/NW connection gets repeated sync
   failures, every 0.5-2 seconds or so, and fails to stay open.

 - SETUP: Now, power up T2:

    +--------++---------+
    |        ||         |
    |        --         |
    |on      --       on|
    |T1  OK! ||       T2|
    +----||--++--||-----+
       +-||------||-+
       | OK!        |
       |            |
       |on          |
       |KM          |
       +------------+

 - BEHAVIOR: The sync failures on the T1/SE <-> KM/NW connection
   vanish; the connection is solid.[377:

Wed Jul 29 14:50:41 2020 Oh and here's a lovely new wrinkle I
absolutely wasn't expecting.

 - SETUP: As above, except now T1 and T2 are not directly connected at
   all:

    +--------++---------+
    |        ||         |
    |        ||         |
    |on      ||      off|
    |T1  ns  ||       T2|
    +----||--++--||-----+
       +-||------||-+
       | ns         |
       |            |
       |on          |
       |KM          |
       +------------+

 - BEHAVIOR: The T1/SE <-> KM/NW connection fails to sync at all.

 - SETUP: Now power up T2:

    +--------++---------+
    |        ||         |
    |        ||         |
    |on      ||       on|
    |T1  OK! ||       T2|
    +----||--++--||-----+
       +-||------||-+
       | OK!        |
       |            |
       |on          |
       |KM          |
       +------------+

 - BEHAVIOR: The T1/SE <-> KM/NW connection opens and remains solid.

[378:

Wed Jul 29 15:12:33 2020 So it appears the issue is 'all' in KM?

 - QUESTION: Suppose we disconnect KM/NE <-> T2/SW?  Does T1/SE <->
   KM/NW then open, even though T2 is off?

 - BEHAVIOR: YES, yes it does: 

    +--------++---------+
    |        ||         |
    |        ||         |
    |on      ||      off|
    |T1  OK! ||       T2|
    +----||--++---------+
       +-||---------+
       | OK!        |
       |            |
       |on          |
       |KM          |
       +------------+

 - QUESTION: Suppose we reconnect T1/ET <-> T2/WT?  Does T1/SE <->
   KM/NW remain open?

 - BEHAVIOR: YES, yes it does: 

    +--------++---------+
    |        ||         |
    |        --         |
    |on      --      off|
    |T1  OK! ||       T2|
    +----||--++---------+
       +-||---------+
       | OK!        |
       |            |
       |on          |
       |KM          |
       +------------+

[379:

Thu Jul 30 00:31:18 2020 So maybe we could actually break out the
oscilloscope and see if we can see anything that might help explain
this behavior.

If this behavior is really actually repeatable, in the end..

Let's stick a PD into T2/SW <-> KM/NE and see if T1/SE <-> KM/NW loses
sync.. [380:

Thu Jul 30 00:36:40 2020 Seems like apparently not? :(

 - SETUP: Now we have this:

    +--------++---------+
    |        ||         |
    |        --         |
    |on      --      off|
    |T1  OK  ||       T2|
    +----||--++--||-----+
       +-||------||-+
       | OK         |
       |            |
       |on          |
       |KM          |
       +------------+

 - BEHAVIOR: ..and the preexisting T1/SE <-> KM/NW remains open.

   = So it's not immediately repeatable.  Let's power up T2 and see
     what happens..

[381:

Thu Jul 30 00:48:43 2020 Hmm, so T2/SE <-> KM/NW gitched a bunch of
times, while I was (trying to get into position and) pushing the power
button, but then stopped glitching and remained open, long before T2
had finished booting.

[382:

Thu Jul 30 00:59:01 2020 So the hardware debugging remains ambiguous
and frustrating.

:382]

:381]

:380]

:379]
:378]
:377]

:376]
[383:

Thu Jul 30 01:21:10 2020 Well so I relaxed in the afternoon and
concluded that we have to step up the engine tracing machinery yet
another notch.  In for a penny in for a ton.

Last we talked on this topic, we had implemented rolling disk buffers
so that we would retain the latest 8MB (by default) of engine tracing,
when it was active.

But we were seeing failures-to-log and kernel panics that we
interpreted as possible evidence that the actual disk was being
stressed by the rate we were pounding trace data out to it.  Which
made us unwilling or unable to have tracing turned on by default
[387:

Thu Jul 30 03:24:29 2020 And so my plan for RIGHT NOW is to rehack the
engine tracing based on the following observations and goals:

 - Unlike the LKM, the engine rarely actually crashes (although we're
   having some issues with that at the moment).  Usually it's a FAIL
   that we have no idea how to respond to.

 - We will keep a rolling trace buffer in memory, with a command line
   configurable size (defaulting to perhaps 4MB?), and we won't commit
   that buffer to disk AT ALL, unless some triggering condition -- such
   as but not limited to FAIL-out-of-top-level -- occurs.

 - When such a triggering condition occurs, which we will call an
   'EJECT', we'll stop and atomically write the whole rolling trace
   buffer to disk, leaving the buffer empty, before continuing with
   whatever happens next

 - We'll also roll ejected disk buffers as needed to minimize the
   total space trace data is taking up.

[388: Thu Jul 30 03:31:49 2020

 - We'd also like to get flash traffic going, so there could be a
   chance of requesting EJECTs from one's neighbors, but that's a
   whole separate kettle of fish.

 - We'd ALSO like to draft our physical push button to generate an
   EJECT, so we could do that independent of GUI context.

[389:

Thu Jul 30 03:39:15 2020 Are we reading the button at all, in the
engine?  I kind of think we're not ATM..

:389]

:388]

:387]
:383]
[384:

Thu Jul 30 01:48:17 2020 Oops, caught another panic in one of my
serial ports:

    [39602.426096] Illegal standard local packet e0+2
    [39602.430664] <pru1: b7132885: e0 5b                                            .[

So that's our 'improved error message', dumping the illegal packet (at
ictpkt.c:2366).  Not sure how much it tells us, but at least it's
pointing the finger at pru1 now.
[385:

Thu Jul 30 02:05:03 2020 Is it possible this packet might be an actual
corruption (tied to heavy use perhaps), and we're mishandling it and
something corrupting kfifos in the process?[386:

Thu Jul 30 02:22:50 2020 Well, it's hard to see how: We don't actually
store those packets anywhere anyway..  Problem almost surely starting
elsewhere.. 

:386]

:385]
    [39602.440741] XKFIFO OB prudev itc!pru!1, kfifo mPriorityOB, kfifolen = -101, pktlen = 0
    [39602.462231] DUMPITCSTATUS DUMPITCSTATUS DUMPITCSTATUS
    [39602.473087] kfifoptr---kfifoin/out------mskin/out----len-avail-mnrflg name----------------
    [39602.487550] 3e88bc91      2447/0         2447/0    2447l 255a   0   mLocalIB-itc!pru!0
    [39602.503827] 558a7f4d   4498498/4498407   1090/999    91l 255a   0rp mPriorityOB-itc!pru!0
    [39602.519994] 55228e26   1293882/1293717   3642/3477  165l 255a   0r  mBulkOB-itc!pru!0
    [39602.532971] bc63cdcb       104/0          104/0     104l 255a   1   mLocalIB-itc!pru!1
    [39602.546910] f10ff6d1   2414326/2414427   1782/1883 -101l 255a   1rp mPriorityOB-itc!pru!1

So we have lot more non-empty kfifos this time, leading up to our -101
problem.

    [39602.560488] 262c8dc5    635777/635722     897/842    55l 255a   1r  mBulkOB-itc!pru!1
    [39602.574507] b4cfd749   2196866/2196866   1410/1410    0l 255a   2   mUserIB-itc!bulk
    [39602.587565] 9a12c977         0/0            0/0       0l 255a   3   mUserIB-itc!flash
    [39602.601409] 2e3f8adf    416746/416746    3050/3050    0l 255a   6   mUserIB-itc!mfm!ET
    [39602.614704] 1738beaa   1925417/1925417    297/297     0l 255a   7   mUserIB-itc!mfm!SE
    [39602.628904] 005a7f04   2406585/2406585   2233/2233    0l 255a   8   mUserIB-itc!mfm!SW
    [39602.642036] 37428f47         0/0            0/0       0l 255a   9   mUserIB-itc!mfm!WT
    [39602.655977] e16c3dae         0/0            0/0       0l 255a   a   mUserIB-itc!mfm!NW
    [39602.669475] 4ad87ea9   2044233/2044233    329/329     0l 255a   b   mUserIB-itc!mfm!NE
    [39602.683630] ------------[ cut here ]------------
    [39602.691487] kernel BUG at /home/t2/T2-12/pru/itcio/module/itcpkt.c:344!
    [39602.698130] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP ARM
    [39602.703991] Modules linked in: joydev cpufreq_userspace c_can_platform c_can can_dev fb_ili9486(C) fbtft(C) evdev ads7846 uio_pdrv_genirq uio 80
    21q garp stp mrp llc iptable_nat nf_nat_ipv4 nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_mangle iptable_filter itc_pkt(O) itc(O) ip_t
    ables x_tables spidev
    [39602.731783] CPU: 0 PID: 1236 Comm: ITC_PktShipr Tainted: G         C O      4.19.79-ti-r30 #1buster
    [39602.740868] Hardware name: Generic AM33XX (Flattened Device Tree)
    [39602.747075] PC is at sendPacketViaRPMsg+0x80/0x2a4 [itc_pkt]
    [39602.752777] LR is at wake_up_klogd+0x7c/0xa8
    [39602.757066] pc : [<bf048a3c>]    lr : [<c01ad434>]    psr: 60070013
    [39602.763359] sp : db173ef8  ip : db173c88  fp : db173f34
    [39602.768605] r10: ffffff9b  r9 : 0000007f  r8 : db128040
    [39602.773853] r7 : 00000001  r6 : bf04eb7c  r5 : 00000000  r4 : db129318
    [39602.780408] r3 : bad55a76  r2 : bad55a76  r1 : c10ff388  r0 : 0000004a
    [39602.786966] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none
    [39602.794131] Control: 10c5387d  Table: 9c7e8019  DAC: 00000051
    [39602.799908] Process ITC_PktShipr (pid: 1236, stack limit = 0x26571f6a)
    [39602.806465] Stack: (0xdb173ef8 to 0xdb174000)
    [39602.810842] 3ee0:                                                       00000000 db129318
    [39602.819060] 3f00: db173f1c c14d0adc ffffe000 db128040 ffffe000 bf04eb7c 00000001 00000000
    [39602.827277] 3f20: 0000007f 00000002 db173f74 db173f38 bf048d24 bf0489c8 bf04e980 c1505dc8
    [39602.835494] 3f40: db173f74 bad55a76 c0160a5c db112800 db112540 00000000 db172000 bf04ebac
    [39602.843711] 3f60: bf048c60 da837a2c db173fac db173f78 c0160f6c bf048c6c db11281c db11281c
    [39602.851927] 3f80: 00000000 db112540 c0160e00 00000000 00000000 00000000 00000000 00000000
    [39602.860144] 3fa0: 00000000 db173fb0 c01010e8 c0160e0c 00000000 00000000 00000000 00000000
    [39602.868360] 3fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    [39602.876577] 3fe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000
    [39602.884857] [<bf048a3c>] (sendPacketViaRPMsg [itc_pkt]) from [<bf048d24>] (itcOBPktThreadRunner+0xc4/0x188 [itc_pkt])
    [39602.895544] [<bf048d24>] (itcOBPktThreadRunner [itc_pkt]) from [<c0160f6c>] (kthread+0x16c/0x174)
    [39602.904465] [<c0160f6c>] (kthread) from [<c01010e8>] (ret_from_fork+0x14/0x2c)
    [39602.911718] Exception stack(0xdb173fb0 to 0xdb173ff8)
    [39602.916792] 3fa0:                                     00000000 00000000 00000000 00000000
    [39602.925008] 3fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    [39602.933223] 3fe0: 00000000 00000000 00000000 00000000 00000013 00000000
    [39602.939873] Code: e30b0ec0 e34b0f04 eb459490 ebffff8d (e7f001f2) 
    [39602.946010] ---[ end trace ffe0a9448ad2f5e1 ]---
    [39602.950649] Kernel panic - not syncing: Fatal exception
    [39602.955912] Rebooting in 20 seconds..



:384]
