{206}  -*- text -*-
[0:

Fri Jun 12 01:17:00 2020 Well we finally moved the ulam5 branch, and
the mfmt2 branch, onto develop.  And that's now seeming to settle
down, although I expect a few lingering explosions or overlooked bits
will turn up occasionally.

In any case, for ages we have been doing notes for itcSpike12 in the
T2-12 tree, which really does seem just wrong for all this MFM tree
development, so I'm starting up this notes file here in honor of
merging to develop.

:0]
[1:

Fri Jun 12 01:19:47 2020 To get us started, some quick

TODO:

 - Rework the Tile menu to pull in the old CPU freq changing stuff[2:
   Fri Jun 12 03:06:32 2020 Which turned out to be nothing more than a
   system() call.. :2]

[5: Fri Jun 12 03:59:13 2020
DONE :5] - Pull in the CPU freq changing stuff sufficient to start slowing the
   clock when the core temperature goes high.[3: Making another
   TimeoutAble to watch the core temp and control the CPU..  :3]

   = core temp ACCEPTABLE -> 1000MHz
   = core temp HIGH -> 720MHz
   = core temp
[4: Fri Jun 12 03:07:27 2020

 - Consider ditching the circuit abstraction.  With each ITC having a
   rack of passive EWs, aren't 16 active EWs really enough?  We could
   ensure we reserve one for hidden events if we wanted, right?  So if
   there's only one active EW left, we reject any centers that would
   require locks?

[6: Fri Jun 12 04:25:09 2020

 - Rough out a plan for ditching the circuit abstraction and
   simplifying the EW lifecycle as much as possible.  Key stages:
   = Allocate
   = Hog Sites          Note that site lifetimes
   = Acquire locks      and lock lifetimes are
   = Unhog sites        overlapping, not nested.
   = Release locks
   = Free

 :6]


:4]
:1]
[7:

Fri Jun 12 04:38:03 2020 So, active side EW story:



                +------------------+                                    +------------------+
                |Allocate active EW|                                    |+----------------+|
                |init center+radius|     /----------------------------->||Free active EW  ||
                +------------------+     |                              |+----------------+|
                        |                |                              +------------------+
                        v                |                                     ^
                      /    \             |                                     |
                     /      \   Fail     |                               +--------------+
                    Try to hog ----------/                               |Send HANGUPs  |
                    \ sites /                                            |for any ACKed |
                     \     /                                             |locks         |
                      \   /                                              +--------------+
                        v                                                      ^
                        | Succeed                                              |
                        v                                                +---------------+
                  +-------------+                                        |  Unhog sites  |
                  |  Send lock  |                                        |               |
                  |  requests   |                                        +---------------+
                  +-------------+
                        |
                        v
                       / \
                      /   \
                     / need\         +------------+
                    / more  \   No   |Perform     |
             ------>\  ACKs?/------->|transition  |
             |       \     /         +------------+
             |        \   /
             |         \ /
             |          v
             |          | Yes
             |          |
             |          v
             |    +------------+
             |    |Wait & check|  Timeout
             |    |for replies |------>
             |    +------------+
 -           |          |
             |          V           ^
             |         / \         / \
      +---------+     /   \       /   \
      |Record   | Yes/ Got \ No  / Got \
      |ACK      |<---\ ACK?/-----\ NAK?/
      +---------+     \   /       \   /
                       \ /         \ /
                        v           v




:7]
[8:

Fri Jun 12 05:22:15 2020 Well have been working on the retro flowchart
in :7: but realizing that we can't entirely ditch the 'circuit'
concept because, at the very least, each active EW needs to track what
locks it's got and how far it's gotten sending cache updates -- and
both of those items are currently stored in the CircuitInfos.

Now, we have CircuitInfo structs inside the EWs, but we ALSO have
Circuit structs inside the ITCs:

    in T2EventWindow                       in T2ITC

  struct CircuitInfo {                  struct Circuit {
    T2ITC * mITC;                         CircuitNum mNumber; // 0..CIRCUIT_COUNT-1
    CircuitNum mCircuitNum;     vs        u8 mEW;             // 1..MAX_EWSLOTS
    bool mLockAcquired;                   s8 mYoinkVal;       // -1,0,1
    s8 mMaxUnshippedSN;                 };
  };

Which looks a pretty damn ridiculous juxtaposition, just sitting
there, doesn't it?

Shouldn't we:

 - Move the yoinkVal into CircuitInfo,

 - Change CircuitNum mCircuitNum to T2EventWindow & mEW, always
   referring to the containing EW as a convenience,

 - Reduce MAX_EWSLOT from 32 to 16,

 - Use the EW slotNum wherever we used to use the CircuitNum, and

 - Terminate struct Circuit with prejudice

?

[9:

Fri Jun 12 05:45:16 2020 But do we also need a bit more CircuitInfo
state to make this go smoothly?[10:

Fri Jun 12 09:19:44 2020 Had a nice chat with Jeff.  Nap time.

:10]

:9]
:8]
[11:

Fri Jun 12 13:57:05 2020 Well do we execute here?  Sure.  struct
Circuit DIE DIE DIE
[12:

Fri Jun 12 13:58:26 2020 Do we maybe want an explicit state variable
in CircuitInfo?  Rather than, say, just the three-way s32 yoinkVal?
What would its states be?  Something like

  UNUSED    - Rest of CircuitInfo fields are invalid
  RUNG      - RING sent (active), recvd (passive)
  ANSWERED  - ANSWER recvd (active), sent (passive)

  DROPPED   - DROP recvd (active), sent (passive)
  TALKED    - CUPS sent/in progress
  HUNGUP    - Active side, done, free -> UNUSED



:12]
:11]
[13:

Sat Jun 13 11:21:58 2020 OK, in the middle of tearing out
T2ITC::Circuit and shifting to just an expanded T2EW::CircuitInfo.
Still tons of broken stuff on both sides.  Wondering about trying to
make the active vs passive EW distinction clearer somehow.  Right now
there's fundamentally different routes to looking them up -- active
EWs are owned by T2Tile, and are now accessed via

  T2EventWindow & getActiveEW(u32 idx)

, while passive EWs are stored in a T2ITC data member

  T2EventWindow * mPassiveEWs[CIRCUIT_COUNT];

and are apparently directly accessed via that member.

I'm also wondering about declaring a single extra one, like

  T2EventWindow T2Tile::mHiddenEW;

to use solely for lock-free 'hidden' events, so that (1) all 16
'active' EWs can be used for intertile events, and (2) hidden events
can still be run when all 16 active EWs are busy.

I wonder if EWInitiator should be designed to always check if any
active EWs are available first.. and do what with that information?
Try preferentially to pick a random spot that needs locks?  Nah.  Note
whether any active EWs are available, but then pick uniformly as
always.  If the chosen center requires no locks, use the hiddenEW,
otherwise allocate an active one.

Now that requires doing a bunch of stuff, without a chosen EW, that an
EW itself is currently doing.

It's also a throw-back to the 'as fast as possible' design approach
vs the 'stay in tempo' style that we dawningly realize is the
fundamental systemic approach.
[14:

Sat Jun 13 12:14:01 2020 But!  I'm looking at T2-PHF-18 and really
longing for one more bit for 'circuit number' so we could get back to
32.  And we note that both the Urgent bit (byte 0 bit 5) used to
identify Bulk traffic, and the MFM bit (byte 1 bit 7) used to identify
Flash traffic, are both associated with either slow or rare purposes.
We could merge them together and break them apart later.

Swap URG and MFM.  Then Flash and Bulk both have MFM (byte.bit 0.5)
set to 0, flash has URG (1.7) set to 0, and bulk has 1.7 set to 1.

Except I guess we have to rename URG to BLK or something.  Flash has
BLK set to 0 and Bulk has BLK set to 1.

Then, when MFM is 1, we have all of byte[1] available, and we could
have five bits of CN.

So this approach would take one bit of byte 1 away from Bulk -- which
can surely afford to lose it -- and give it to MFM, which could surely
use it.

It would mean doubling the space used for passive EWs, which was
already kind of non-trivial.[15:

Sat Jun 13 12:43:12 2020 Recall from
T2-12/pru/itcio/notes/202002010352-notes.txt :698:


        (gdb) p 6*16*sizeof(mSites)
        $210 = 346368

    Or about 350KB for all the passive EWs on a tile.

So that would go up to ~700KB?  It's still under 1MB.  And mfmt2 is
currently taking under 10% of memory.  We could spring for another
400KB.

But jeez, it means tearing up a lot of stuff:

 - LKM itc_pkt would have to be reworked and restabilized (AGAIN GAH)

 - app/cdm.pl would have to be reworked

 - (The current native engine code has to be reworked, but that's true
   no matter what.)

 - T2-PHF-18 would have to be reworked.

Yikes.  I can feel me: We're going to do this, aren't we?
[16:

Sat Jun 13 12:52:59 2020 Gah, We Are.

Starting with T2-PHF-19![17:

Sat Jun 13 13:05:57 2020 OK T2-PHF-19 exists, with first round
modifications for MFM<->URG + URG->BLK.

Question: Do we want to ditch/rename-away the 'telco lingo' -- RING,
TALK, etc?  It's cute but we've already had one confusion between BUSY
(passive side tells active side that active lost a race, so no) and
DROP (active side tells passive side the event passive agreed to has
been aborted without commit).

[18:

Sat Jun 13 13:23:59 2020 Not sure.  But let's keep it for now, with
the hope for once-burned-twice-shy on BUSY/DROP.

So.  Let's take a quick look at itc_pkt and see how horrible doing
this change might be.[19:

Sat Jun 13 13:26:29 2020 I guess we'd:

[22: Sat Jun 13 14:46:50 2020
DONE :22] - Rename PKT_HDR_BITMASK_URGENT -> PKT_HDR_BITMASK_MFM in itcpkt.h

[23: Mostly
DONE :23] - In general rename 'urgent' stuff to 'mfm' stuff

[24: Somewhat
DONE :24] - (Rename 'bulk' stuff to 'service' stuff?)

[25: First attempt anyway
DONE :25] - Rework the destination selection logic at itc_pkt_cb:2209+

[26:
DONE :26] - Rework the XITC values at itcpkt.h:90+ to shift by 5

[27:
DONE :27] - Rename PKT_HDR_BYTE1_BITMASK_MFM -> PKT_HDR_BYTE1_BITMASK_BULK at
   itcpkt.h:89

[28:
DONE :28] - Redefine PKT_HDR_BYTE1_BITMASK_XITC from 0x70 -> 0xe0

[29: Fixed, for the moment anyway, so
DONE :29] - Note the userspace XITC defs (itcpkt.h:95+) are also broken -- fix
   or ditch.

 - Rename mPriorityOB to mMFMOB?  itcpkt.h:241

 - Rename mBulkOB to mServiceOB? itcpkt.h:242

[20:

Sat Jun 13 13:44:25 2020 UGH: AND DO we ALSO want to take this
opportunity to give up on /dev/itc/mfm/ET..WT and go back to just
/dev/itc/mfm?

 - Currently, outbound mfm packets get routed to the appropriate PRU
   kfifo based on their packet header, regardless of which device was
   used to write them.  So having six devices does NOTHING for us
   there -- no extra speed or buffering or ordering or ANYTHING.

 - It does affect reading inbound mfm packets, where we get to
   decide which ITC packets to consider in our own randomized order,
   rather than necessarily dealing with them in the order that itc_pkt
   saw them arrive from the PRUs.  It does mean the different dirs
   aren't competing for inbound kfifo buffer space, which is probably
   a good thing on isotropy grounds but unlikely to matter except in
   highly stressed circumstances anyway.  And sharing a single kfifo
   is probably better on cache behavior grounds.

Let's leave it be for now.  At least, let's do and stabilize the PHF
changes before reconsidering this.[21:

Sat Jun 13 14:11:48 2020 Well, tearing into LKM.  Got at least two or
three hours here.  GO GO GO

:21]



:20]


:19]

:18]

:17]

:16]
:15]

:14]

:13]
[30:

Sat Jun 13 14:49:02 2020 So, that can't be it, can it?  Let's just
eyeball the inbound and outbound logic again before trying to build..

INBOUND
 - packet arrives at itc_pkt_cb
 - Say it's a standard packet
 - Say it's not a local packet, and it doesn't signal overrun or error
 - We set bool mfm = byte0&PKT_HDR_BITMASK_MFM, which is bit 2
 - We choose stats buffer TRAFFIC_MFM or TRAFFIC_SERVICE based on that
 - If !mfm, we check byte1&PKT_HDR_BYTE1_BITMASK_BULK for
   /dev/itc/bulk, else /dev/itc/flash.  (Management acknowledges its
   regret that so-called 'flash' traffic now actually travels at bulk
   rate, by solemnly dedicating this memorial parenthetical note.)
 - If mfm and XITC (byte1 mask 0xe0) !=
   PKT_HDR_BYTE1_XITC_VALUE_KITC(0x0<<5), that means userspace, so we
   deliver if we have MFZID compatibility established.

 - Otherwise it's KITC traffic, which goes to recvKITCPacket, which
   seems kind of updated okay.[31:

Sat Jun 13 15:17:37 2020 The packet tracing stuff 'seems' not to care
specifically about the pkthdr bits, leaving that up to the packet
trace system user.  I think, anyway..

[32:

Sat Jun 13 15:19:00 2020

OUTBOUND:

 - All outbound-from-userspace packets go to writePacketHelper

 - Which is still saying 'bool bulkRate' for something that should now
   be called 'bool serviceRate' or something.

 - The check of minors (/dev/itc/{bulk|flash|ET..WT}) for routing is
   still right.

 - We now clear bulkRate on PKT_MINOR_FLASH (moment of silence) where
   we didn't before.

 - We go to routeOutboundStandardPacket.  We got rid of some constants
   for some names, but everything works the same there.  We map dirs
   to pru minors.[38: Sat Jun 13 15:54:55 2020

 - We then select mBulkOB or mPriorityOB based on bulkRate.  We either
   block or error out if there's no room, depending on how userspace
   opened whatever minor we came in on.  (It will be error out for all
   mfmt2 stuff.)

 - Otherwise we kfifo_from_user to the appropriate OB, and we're done.

:38]

 - Then we stick the packet in the mPriorityOB kfifo no matter
  what???[37:  Sat Jun 13 15:53:30 2020 Yes, when the packet arrives
  from the KITC system, which is the only user of
  trySendMFMRoutedKernelPacket.

:37]
   What the heck is this about:

itcpkt.c:1601:   ipb = &prudevstate->mPriorityOB;  /*priority dispatch only at present*/

  ??

[33:

Sat Jun 13 15:40:05 2020 Well so we're in (the newly-renamed)
trySendMFMRoutedKernelPacket, so isn't that the answer?  All MFM is
priority?  How did I miss/forget that in the walkthrough?[34:

Sat Jun 13 15:42:39 2020 Well, trySendMFMRoutedKernelPacket is called
from sendPacketHandler.. but that's static in itcmfm.c so we suspect
only mfm packets can get to it..[35:

Sat Jun 13 15:43:59 2020 ..And trySendMFMRoutedKernelPacket is called
from nowhere else.. so okay.  Maybe we could assert our new MFM bit,
just to be sure?[36:

Sat Jun 13 15:51:58 2020 OK, didn't assert, but added:

  /*only mfm packets allowed via this route*/
  if (!(pkt[0] & PKT_HDR_BITMASK_MFM)) return -ENXIO; /*never the error code you want*/

and changed to this:

  ipb = &prudevstate->mPriorityOB;  /*MFM packets are always priority dispatch*/

So.  Where were we?

:36]

:35]

:34]

:33]

:32]

:31]

:30]
[39:

Sat Jun 13 15:59:04 2020 Well the eyeball walkthrough looks plausible
enough.  Let's build.

[40:

Sat Jun 13 16:00:28 2020 Urgh, just one typoe:

  return ph->pktbuf[1] & 0xPKT_HDR_BYTE1_BITMASK_XITC_SN;

otherwise it builds.

Now.  We also need to change mfmt2 and cdm.pl.  But we have less than
an hour here before it's time for the evening.

Let's look at cdm.pl now and save mfmt2 for the overnight run.
[41:

Sat Jun 13 16:32:48 2020 cdm.pl seems to be fixed up.  Let's try
installing the LKM..

:41]
:40]

:39]
[42:

Sun Jun 14 03:17:39 2020 OK where are we?  Updating mfmt2 for the
packet format changes.[43:

Sun Jun 14 03:34:21 2020 Converting in T2PacketBuffer.h.  What say we
also take this opportunity to move the yoink bit from 4.7 to 4.3, so
there's four contiguous reserved bits in byte[4]?  And let's sneak
that into to T2-PHF-19, even though it's already pushed?  Vs going to
T2-PHF-210?

Fog it let's make T2-PHF-210.[44:

Sun Jun 14 03:51:16 2020 Made T2-PHF-210.  Put yoink bit at 4.7 and
radius at 4.6 - 4.4, leaving 4.3 - 4.0 undefined.  Noting that if we
had shipped RADIUS-1 instead of RADIUS, we could have fit it in two
bits instead of three.  Did we think that was too tricky?  Or did we
imagine there might be a radius 0 event going intertile??  Or did we
want to 'save room for the future'???

OK well of course now that I'm thinking about it I guess I have to go
check the old monster notes file see what I can find..
In T2-12/pru/itcio/notes/202002010352-notes.txt..

[45:

Sun Jun 14 03:56:51 2020 Well right there at :272: from this past
March I was thinking of a two bit radius-1:

       MFM ITC SYN
      +---+---+---+---+---+---+---+---+
      | 1 | 0 | 0 |EC1|EC0|RV1|RD1|RD0|
      +---+---+---+---+---+---+---+---+

    EC 0..3  RD 0..3
    EC == 0 Non-EventWindow command (RV1,RD1,RD0 unused)
    EC == 1 EventWindow lock req + RD radius-1 + u8:YLSeqno + u8:myewslotno + s8:atx + s8:aty
    EC == 2 EventWindow lock ack + RD radius-1 + u8:YLSeqno + u8:yourewslotno
    EC == 3 EventWindow lock rej + RD radius-1 + u8:YLSeqno + u8:yourewslotno

[46:

Sun Jun 14 04:00:13 2020 (And noting in passing that :487: of that
file is where per-ITC origins for RING coords comes up -- which is one
thing we think needs to be rechecked once the current clean-up
settles.)

:46]

:45]
:44]

:43]

:42]
[47:

Sun Jun 14 04:08:55 2020 Well, by :713: in that file we're just
blithely saying 'radius:u3'[48:

Sun Jun 14 04:10:46 2020 And :808: sticks mRadius in the packet
directly:

          u8 yoinkRad = ((yoinkVal&0x1)<<7)|mRadius;
          pb.Printf("%c",yoinkRad);

and that's the last hit for 'radius' in that file.[49:

Sun Jun 14 04:12:39 2020 Let's go with (radius-1):u2.  What you cannot
say, you cannot command.

"What good is a phone call if you are unable to speak?"

[50:

Sun Jun 14 04:37:28 2020 And in this context note we're also exposed
on s8:ctrx and ctry: Recheck their inbound handling.

:50]
:49]

:48]

:47]
[51:

Sun Jun 14 04:39:54 2020 OK done with T2PacketBuffer.h.  Where are the
outbound packets developed?
[52:

Sun Jun 14 04:41:01 2020 Some of it at least is in T2ITC.cpp.  We
should really rewrite all these hex constants though -- if not to
avoid version skew bugs, then just to improve greppability.[53:

Sun Jun 14 04:50:04 2020 Well, it appears I can move the LKM PKT_HDR
enum values from itcpkt.h -- which is not set up for userspace use --
to itcpktevent.h -- which is already #included from userspace --
without ill effect on the LKM side..  Let's try switching to those
names.

[54:

Sun Jun 14 06:04:05 2020 OK, well that took over an hour but I did
kill a tremendous number of '0x' instances in the mfmt2 code.  Started
making use of __builtin_ctz to derive shift distance _POS constants
from the associated _BITMASK constants -- I think nice.

I did *not* go so far as to define _POS constants for masks that are
currently right-justified in their byte, though.

:54]

:53]

:52]
:51]
[55:

Sun Jun 14 06:15:09 2020 Well, fading here a bit -- after only three
hours, say, hmm -- but we've had a pretty good cleaning up run.  Still
much much broken stuff in mfmt2 but the 0x-elimination damage seems to
be mostly handled.

:55]
[56:

Sun Jun 14 06:22:26 2020 Taking a break with mfmt2 still not
building.  When we pick up, walk through scenarios involving
CircuitInfos and just start cleaning them the fog up.
[57:

Sun Jun 14 15:56:34 2020 Well the business of the day ate up a pretty
big chunk.  But we've got a couple hours here; let's start eyeballing
anyway.

For starters, let's walk the active side event window process again.

 - EWInitiator onTimeout goes to tile.maybeInitiateEW

 - which picks a non-cache ctr and goes to considerSiteForEW(ctr)

   = which returns 0 (meaning don't use this ctr) if (1) the site is
     already hogged by some EW, or (2) the radius of the center atom
     is 0, meaning it's Empty.

 - Once considerSiteForEW(ctr) returns a non-zero radius,
   maybeInitiateEW ends by calling tryAcquireEW(ctr, radius, true)

 - T2Tile::tryAcquireEW attempts to allocate an EW, and the event
   attempt fails if it cannot.  If it CAN, we then have a 'live'
   allocated EW whose lifetime has to be tracked and managed.

 - With the ew, T2Tile::tryAcquireEW goes to
   ew->tryInitiateActiveEvent(ctr, radius).  If that returns true, the
   ew remains in use and T2Tile::tryAcquireEW returns true, otherwise
   the ew is immediately deallocated.

[58:

Sun Jun 14 16:15:06 2020 Now T2EventWindow::tryInitiateActiveEvent
returns false in these cases:

 - checkSiteAvailability returns false

 - checkCircuitAvailability returns false

 - needsAnyLocks() returns true but trySendLockRequests returns false

   And there's an ugliness in that -- if trySendLockRequests returns
   false, we return false without unhogging the sites, so some
   mSiteOwners will still be pointing at this EW.

[59:

Sun Jun 14 16:18:55 2020 So that seems like a bug -- at least if
trySendLockRequests might actually return false.  Which happens if and
only if T2ITC::trySendPacket returns false.  Which we hope will be
rare but fear it won't be.

So, I think, although it's risky to go down this road, that:

 - We should add 'bool mHasHoggedSites' to every ew, and have
   'finalizeEW' automatically unhog sites if need be.  (Actually, doh,
   it appears we already have 'bool mIsHoggingSites;' but finalizeEW
   is not examining it.)

 - Similarly, we should add 'bool mIsAllocated' and have finalizeEW
   check (and reset) that also.  Right now we're apparently using
   'mRadius != 0' to mean something like 'isAllocated' but I think
   that's asking for trouble.

Now, what _can't_ finalizeEW do?  Well, how does the allocation
process work?  And isn't the allocation process different for active
vs passive EWs, and isn't that bad?

Active EWs: Raw allocation is via T2Tile::allocEW, final free by
T2Tile::freeEW.  allocEW modifies the EWSet T2Tile::mFree, but doesn't
touch the EW.  freeEW modifies whatever set the EW is currently in, if
any, and also modifies T2Tile::mFree.

Now, at the moment T2ITC is doing a whole different thing, using an
array of ptrs:

    T2EventWindow * mPassiveEWs[CIRCUIT_COUNT];

allocated in the ctor and freed in the dtor.

It would be nicer if we could consolidate ownership-of-set-of-EWs
under a common framework; the current challenge is that EWSet
currently provides random allocation but not targeted allocation.

How about we extend EWSet to support both mechanisms?  And then have
it trace both allocated and free EWs, not just free ones?[60:

Sun Jun 14 16:41:47 2020 Now, one issue with that is:

    ~EWSet() ;  // EWSet DOES NOT own its EWs

but given that both T2Tile and the T2ITCs now allocate the EWs on the
heap, I'm not sure why we don't let the EWSet own the EWs.[61:

Sun Jun 14 16:44:03 2020 So the idea would be:

 - Say EWSet does own its EWLinks

 - Add 'std::vector<EWLinks*> mMembersByIdx;' as the canonical
   ownership pointer

 - Change 'std::vector<EWLinks*> mMembers;' to like

   'std::vector<u32> mFreeIndices;'

 - Add a EWSet::takeOwnershipOf(EWLinks*) to add EWLinks to
   mMembersByIdx, setting the ewlinks idx in the process.  Newly owned
   EWLinks* are always free

 - Have the dtor destroy the contents of mMembersByIdx


:61]

:60]

:59]

:58]

:57]

:56]
[62:

Sun Jun 14 23:28:19 2020 OK, after the evening.[63:

Sun Jun 14 23:56:57 2020 Grr, OK, after the late evening Twitter+ time
sink.

As I wanted to start to say: I've been reorganizing the ownership of
2EventWindows.  What really are the needs/wants for that container?

 - Track free vs in-use EWs

 - For active side, O(1) allocation of arbitrary free EWs

 - For passive side, O(1) allocation of a specific EW identified by cn

 - For both sides, O(1) deallocation of in-use EWs

Is there any reason for more than that?  In particular, do we really
care what order we allocate active EWs?  Right now the EWSet does
extra work to allocate EWs randomly, but what does that really
accomplish?  Wouldn't it be at least as good to allocate them in a
FIFO order.
[65:

Mon Jun 15 00:05:26 2020 Which leads to a related question: Are we
worried at all about aliasing between multiple uses of the same EW?
We really can't be worried about that, can we?  Because we're saying
'it can't happen' as long as the T2ITC connection remains open,
because the far side will see everything we send them, in the order we
send it, with the only proviso being they will see all that at some
variably later time than we sent it.

I keep wanting to worry about things like aliasing CNs across uses,
and keep wanting to add generation numbers or random tags to help
detect them, but once I actually push through and implement stuff I
never actually use them.

We're empowered to _not_ add robustness at this level as long as we're
ready to reliably die-and-renew the channel when any inconsistency is
detected.  Rather than, say, failing out of top level and restarting
the whole engine -- as we are currently doing..

But we do have to have some chance of discovering we are in an
inconsistent state, and that means we do need some degree of
redundancy somewhere.

I guess one point is we already do have that just with the existing
CNs, when considered in combination with the XITC circuit signals.  At
any given moment, for a given CN, only a subset of circuit signals
actually make sense.  And we _are_ already detecting inconsistencies
of that kind -- we're just failing right out of the engine when we do.

So this is 'quacks-like-a-duck' consistency, and when we discover it's
violated, we should

 - Assume it's due to packet loss(es) somewhere in the network

 - Abort all EWs implicated in the detected failure

 - As part of aborting those EWs, any involved ITCs should be aborted
   or closed as well, being free to reopen, but only after they have
   synced up from lower level.

:65]
[64:

Sun Jun 14 23:59:01 2020 Note there's current four bits left at the
end of the RING packet.  What if we used them for an 'allocation
counter'

:64]


:63]

:62]
[66:

Mon Jun 15 00:20:40 2020 And if we're actually serious getting this
stuff to actually work, which we REALLY OUGHT TO FOGGEN FINALLY BE
READY TO BE BY NOW, we should START by writing and testing the
failure/abort/cleanup logic FIRST, before focusing on the failure-free
'default' case like we have been doing.

:66]
[67:

Mon Jun 15 00:22:21 2020 So.

Goal: Arbitrarily abortable event windows.

Properties:

 - Have (mainly) a single ditching point / abort sequence that anybody
   can call at any stage of an EW lifecycle, and it will 'Do The Right
   Thing' as far as cleanly blowing up whatever needs to be blown up
   as depends on the circumstances at hand.

 - To do that, EWs will maintain enough state that that single
   ditching point will be able to tell what it needs to do.

 - How about 'void T2EventWindow::fail(const char * file, int line)'
   as the ditching point?  But what happens to flow of control then?
   Do we actually FAIL() as well?  (Note we have to be careful about
   FAIL-ing in guts of stuff now, because we've written a few
   non-trivial dtors, grr.  That's a bomb just waiting to explode.)

[68:

Mon Jun 15 00:31:21 2020 I wonder, could we write a new platform, like
'platform-tile-cpp' or something, that would implement FAIL and
unwind_protect via actual C++ exceptions, and defuse that bomb before
it gets a chance to explode?

This is a pretty important design issue, really.  And it's only Monday
on a non-update week.

Just think about that for a few minutes.

:68]

:67]
[69:

Mon Jun 15 01:41:38 2020 Well, more non-mission work just ate almost
an hour.  Grr.  But platform-tile-cpp?[70:

Mon Jun 15 01:48:56 2020 Well, looked at it briefly, and looked at
stack overflow briefly, and quickly became convinced that
'platform-tile-throw' or 'platform-tile-exception' is a project for
another day: As things are currently set up, FailPlatformSpecific.h
exports a lot of very specific stuff that, at the very least, would
all have to be reconsidered.

It might really be possible to do, but it would be a big new start on
design and we Do Not Have the time for that now.

Instead of trying to be able to throw more readily, we should be
thinking of how to keep our stack shallower -- doing less per state
machine transition -- so that the route to bailing out after aborting
an EW is short.

:70]

:69]
[71:

Mon Jun 15 08:37:40 2020 OK, got it building last night, now working
forward from the front.

:71]
[72:

Mon Jun 15 10:27:36 2020 Worked through some stuff, now trying to
clean up the relationship between T2ITC and Circuit.  Was trying to
have Circuit::setITC(T2ITC&) and Circuit::clearITC() take
responsibility for linking and unlinking the circuit and the T2ITC,
but that runs into trouble distinguishing active from passive ITCs,
which can both be associated with a T2ITC but must not be confused
with each other.

Which circles us back around to the EWManager idea.. does it?  What
about having T2EventWindow be able to say whether it's active or
passive, and just having T2ITC treat (un)registering the circuit
differently depending on that.  Is that so bad?  The active status of
an EW will never change, right?  We could/should pass it as a ctor
arg, no?  If we're still staying away from T2EW subclasses, which I
think we are.[73:

Mon Jun 15 10:40:24 2020 Well thinking about T2EW subclasses again.  I
don't see the real argument against them, and I do see a lot of
clutter in T2EW that is only relevant to one or the other:

 - bool executeEvent() : only active side relevant

 - bool isInActiveState() : poor and misleading design, since any
   given EW should always return the same value.

 - getPassiveCircuitIfAny() : only passive side, and also stupid since
   passive EWs should always have one (and only one) Circuit, to their
   particular T2ITC.

and there's more like that..  While on the other hand, we've
apparently accepted that we're allocating all the T2EWs on the heap,
so having them be different sizes isn't a problem.  (We could even
allocate them in data member arrays, even with subclasses -- except
for ctor argument setup problems.)

Well, this period is all about clean up, so let's take a look at
T2ActiveEventWindow and T2PassiveEventWindow..

:73]

:72]
[74:

Mon Jun 15 14:07:56 2020 Well, getting closer to having
T2ActiveEventWindow/T2PassiveEventWindow actually build.  It really
does split up a lot of the complexity.  One remaining ugliness is that
I was trying to get away with one T2EventWindow-level state machine,
but that means all the state machine callbacks pass a T2EventWindow&
which has to be downcast and asserted non-null before detailed use,
which is, like I said, ugly.

:74]
[75:

Mon Jun 15 14:16:44 2020 Well, I'm going cross-eyed here so I'm going
to stop for a bit, probably through the evening.  Current status is
we're close to building successfully, but with tons of battle damage
all over the place.. and I probably want to go back and split up or
template-out the state machine so that the T2EWOps will know which
subclass of T2EW they are dispatching to.
[76:

Mon Jun 15 16:29:28 2020 Well, took a little nap and now thinking I
could probably just jigger the existing macros to slam an ##Active or
##Passive into the arg names depending on the ACT arg to the XX macro.

[77:

Mon Jun 15 17:00:58 2020 Breaking for some evening.  The
revised-but-still-merged EW state tables are getting close to
building, but

 - Custom handler declarations have to be revisited

 - Probably other stuff TBD.

:77]

:76]

:75]
[78:

Mon Jun 15 19:35:01 2020 Back for a bit.

:78]
[79:

Mon Jun 15 20:18:52 2020 OK, so now we're down to T2ITC circuit and ew
functions that we have to ditch, modify, or figure out how to
implement as is.

Specifically, right now, I want to know who needs
T2ITC::allocateActiveCircuitIfNeeded ?[80:

Mon Jun 15 20:20:14 2020 It's (no longer being) called from
T2EventWindow::checkCircuitAvailability to see if circuits are
available for an active EW that's being set up.

And that answers the question at least in part: We no longer need to
checkCitcuitAvailability because we have the capacity to use any
active EW on any ITC.  We still need to register with the T2ITC
somehow (yet to be re-figured-out), but we don't have to worry about
failing.

So we should ditch T2EventWindow::checkCircuitAvailability, and its
support routines, and finally feel like we're getting a little payoff
for this giant upheaval.
[81:

Mon Jun 15 20:32:46 2020 OK, now we're running again, and are back to
here:

    (gdb) bt
    #0  MFMLongJmpHere (buffer=0xbefff6e0, toThrow=1)
        at src/FailPlatformSpecific.cpp:48
    #1  0x004708fa in MFM::T2ActiveEventWindow::needsAnyLocks (this=0x5d28e8)
        at src/T2EventWindow.cpp:197
    #2  0x00472a30 in MFM::T2ActiveEventWindow::tryInitiateActiveEvent (
        this=0x5d28e8, center=..., radius=4) at src/T2EventWindow.cpp:667
    #3  0x00467766 in MFM::T2Tile::tryAcquireEW (
 ..

Pick up there in the overnight.[82:

Mon Jun 15 23:23:05 2020 Reimplementing T2aEW::needsAnyLocks, which
counts on checkSiteAvailabilityForActive to have set up the circuits
implied by the proposed event center and radius.[83:

Mon Jun 15 23:25:57 2020 And I guess we have to revisit checkSiteAvail
first, because needsAnyLocks seems to be relying on CircuitNums..

:83]

:82]

:81]
:80]


:79]
[84:

Mon Jun 15 23:27:16 2020 checkSiteAvailabilityForActive uses
registerWithITCIfNeeded to set up Circuits, plus a variety of visible
and cache predicates to decide if a site is available/live.

T2aEW::registerWithITCIfNeeded uses Circuit::allocate(itc) and
T2ITC::registerActiveCircuitRaw(Circuit&) to set up the relationship.
Did CircuitNum become involved via the latter?[85:

Mon Jun 15 23:31:43 2020 Well, if it _did_, it doesn't now.  What
T2ITC does now is stick a pointer to the Circuit into
T2ITC::mActiveEWCircuits[sn], and that's about it.  And we think it
would be doing that _because_ a lock is needed.[86:

Mon Jun 15 23:37:16 2020 And we note T2aEW::registerWithITCIfNeeded is
making that call AS PART OF THE Circuit allocation sequence.  So as
long as that remains established, we can call Circuit::isAllocated()
on the Circuit to know if we need/want/are going for/have a lock?[87:

Mon Jun 15 23:40:41 2020 Buuut it seemed like there _were_ two cases,
and ITC registration does _not_ necessarily imply lock needed: We said
the EWs had to register with in-scope ITCs even if the ITCs were SHUT,
because the ITCs could begin an opening sequence and they need to know
and wait if any EWs are currently depending on it being closed.

So again, if Circuit::isAllocated() does not imply 'lock needed', what
DOES imply it?[88:

Mon Jun 15 23:44:03 2020 T2ITC::isVisibleUsable is derived from the
T2ITC state table, ditto isCacheUsable.  [89:

Mon Jun 15 23:49:04 2020 OK, so it's checkSITEAvail -- NOT
checkCIRCUITAvail -- that registers EWs with ITCs, using
Circuit::allocate(T2ITC&) & T2ITC::registerActiveCircuitRaw(Circuit&)
to do so.

Once the EW is registered with a T2ITC, then I guess isCacheUsable
means we need a lock?  That's really supposed to be it?[90:

Tue Jun 16 00:30:58 2020 So the deeper effect of having the split
CircuitInfo/Circuit distinction was that CI associated an EW and an
ITC without implying that a lock was required.  Then, in addition,
having a Circuit allocated on the ITC meant that a lock was required.

Now, we have this CircuitState abstraction that, I believe, we are not
yet doing anything with.  Or more properly, it's currently got fantasy
entries that appear to largely duplicate the EW state machine states,
but on a per Circuit basis.  Perhaps we should redo
ALL_CIRCUIT_STATES_MACRO to work in terms of these re-identified
issues such as registered, need a lock, have a lock, and so forth?

I think maybe.
[91:

Tue Jun 16 00:38:31 2020 You know, the problem with these foggen state
tables is they don't representing nesting and other inter-state
relationships.  They're just a foggen enum with attitude.  And if you
need other state -- pointers for examples -- to have certain
relationships with the state and with each other, the state machine
state, by itself doesn't really help you with that either.  You have
to keep adding args to XX to expand the table.  And how is that really
better than just writing predicates as class methods on the underlying
state?
[92:

Tue Jun 16 00:44:58 2020 Circuit states:

 - UNREGISTERED  no ITC involved.
   = Circuit::isRegistered() -> mITC != 0

 - REGISTERED    to a particular ITC
   = Circuit::isRegistered()
   = Circuit::isLockNeeded() -> isReg + mITC->isCacheUsable

 - REQUESTED
   = Circuit::isLockNeeded()
   = Circuit::isLockRequested() -> isLNeeded + mYoinkVal >= 0
   = Circuit::isLockHeld()

 - ACQUIRED

 - HELD

:92]
:91]
:90]

:89]

:88]

:87]

:86]

:85]

:84]
[93:

Tue Jun 16 04:04:50 2020 OK, taking another break.  Have just been
working forward from the front and cleaning up.  The various Circuit
predicates we made feel pretty good and pretty clear.

Current issue is T2ITC::registerActiveCircuitRaw is blowing up because
mActiveEWCircuits[sn] is already set.  We think that's because it was
correctly set up earlier, and we want to revise eliminate this code
now, but we're not sure.[94:

Tue Jun 16 04:10:35 2020 Yeah, Circuit::bindCircuit was already doing
the registerACRaw.  Now we're blowing up on Circuit::isLockHeld()
being unimplemented, and we're not yet sure how we want to implement
it.
[95:

Tue Jun 16 04:50:34 2020 We used to have a 'bool mLockAcquired' in
CircuitInfo, but that seems to have disappeared in the latest
conversion.  I guess the idea was it would go into CircuitState
instead?  But we're not sure how much we like CircuitState..[96:

Tue Jun 16 12:03:24 2020 OK so how do we do this?  Add a 'lock held'
XX arg for ALL_CIRCUIT_STATES_MACRO?  Which would be true of ANSWERED
and TALKED ?  But then you'd think there should be a 'bound' XX arg as
well, that would be true of BOUND, RUNG, ANSWERED, TALKED, and who
knows about DECLINED and DROPPED.

Again it really comes down to are we actually going to use our
CircuitState or not?  In earlier state table macrofests, we tried to
figure out ways to include arbitrary state variables with different
states -- like a T2ITC* or something -- in the tables, but we never
got anything we could stand.  So there was always a split between the
state represented by the state variable itself, and all the other
state that sat in data members or wherever, that was supposed to
remain in sync with the state variable.

And so here we are again.
[97:

Tue Jun 16 12:47:24 2020 Well sigh let's try putting in XX args and
see how much we hate it.  'ITC/ITC bound and 'LKH/Lock Held for now..

:97]

:96]

:95]

:94]

:93]
[98:

Tue Jun 16 13:16:10 2020 OK, now we're back at T2EW::finalizeEW, which
is currently united at T2EW rather than down at T2aEW/T2pEW.  And we
don't know what we want it to do, because unlike my previous
admonition to myself, I did not in fact start with the abort sequence
and how to tear down and clean up stuff.

Do we want to try to take a cut at that now?

:98]
[99:

Tue Jun 16 13:32:43 2020 Well, we're back at hidden events running.
Time for the loopback cable I guess.[100:

Tue Jun 16 13:34:10 2020 Ah okay there's the next esplosion.  Now at

    554	  s8 T2ITC::getYoinkVal(CircuitNum cn, bool forActive) const {
    555	    FAIL(INCOMPLETE_CODE);

(via

    #2  0x004727e2 in MFM::T2ActiveEventWindow::trySendLockRequests (
        this=0x5d7420) at src/T2EventWindow.cpp:627
    #3  0x00472a74 in MFM::T2ActiveEventWindow::tryInitiateActiveEvent (
        this=0x5d7420, center=..., radius=4) at src/T2EventWindow.cpp:669
    #4  0x0046792e in MFM::T2Tile::tryAcquireEW (
  ..
)
[101:

Tue Jun 16 13:43:09 2020 But it's really T2aEW::trySendLockRequests
that wants rewritten.[102:

Tue Jun 16 13:45:37 2020 ..and it looks like trySendLockRequests would
be the place to pick the yoink value, no?

:102]

:101]

:100]

:99]
[103:

Tue Jun 16 14:48:49 2020 Past an advance cooking round to get the
meat into the marinade for tomorrow (for our version of Rodriguez'
Puerco Pibil :).

:103][104:

Tue Jun 16 14:49:53 2020 Now blowing up in handleRingPacket,
unsurprisingly enough.

:104]
[105:

Tue Jun 16 21:56:15 2020 Now blowing up in handleAnswerPacket of
course.  Pick up there.

:105]
[106:

Tue Jun 16 23:06:34 2020 Now on to T2aEW::handleACK.

:106]
[107:

Tue Jun 16 23:28:11 2020 Now T2aEW::trySendCacheUpdatePacket

:107]
[108:

Tue Jun 16 23:33:30 2020 Now T2ITC::hangUpPassiveEW.  We're very late
in an (uncontested) intertile event now!

:108]
[109:

Wed Jun 17 01:15:49 2020 OK, now T2ITC::handleHangUpPacket, after a
long diversion to expand the tracing facility to capture Circuit state
changes, as a subcase of EW tracing..  And then to get more rigorous
about updating our new circuit state vars so that the assertions hold.

:109]
[110:

Wed Jun 17 02:06:56 2020 OK, enough for now.  We got back to
uncontested loopback events 'working' like they were before --
plausible, especially when the bein was heading straight for the ITC,
but liable to see obstacles and change directions in places that
really shouldn't have obstacles.  And occasionally to duplicate while
in transit, until enough clone beins were around that they raced
against each other, at which point we hit INCOMPLETE_CODE in
T2EW::passiveWinsYoinkRace:

    (gdb) l
    230
    231
    232	  bool T2EventWindow::passiveWinsYoinkRace(const T2EventWindow & ew) const {
    233	    MFM_API_ASSERT_ARG(ew.isActiveEW());     // ew is our side active initiation
    234	    MFM_API_ASSERT_ARG(!this->isActiveEW()); // *this is passive ew for them
    235	    FAIL(INCOMPLETE_CODE);
    236	    return false;
    237	#if 0
    238	    Circuit & ci = mCircuits[0]; // Passive CircuitInfo always in [0]
    239	    T2ITC & itc = ci.getITC();
    (gdb) bt
    #0  MFMLongJmpHere (buffer=0xbefff6d0, toThrow=1)
        at src/FailPlatformSpecific.cpp:48
    #1  0x00471962 in MFM::T2EventWindow::passiveWinsYoinkRace (this=0x5697c8,
        ew=...) at src/T2EventWindow.cpp:235
    #2  0x00471df8 in MFM::T2EventWindow::resolveRacesFromPassive (
        this=0x5697c8, conflicts=...) at src/T2EventWindow.cpp:296
    #3  0x00472296 in MFM::T2PassiveEventWindow::checkSiteAvailabilityForPassive
        (this=0x5697c8) at src/T2EventWindow.cpp:362
    #4  0x004612ba in MFM::T2ITC::handleRingPacket (
        this=0x4d9dd0 <MFM::T2Tile::get()::THE_INSTANCE+3280>, pb=...)
        at src/T2ITC.cpp:205
    #5  0x00460c8c in MFM::T2ITC::handleCircuitPacket (
        this=0x4d9dd0 <MFM::T2Tile::get()::THE_INSTANCE+3280>, pb=...)
        at src/T2ITC.cpp:124
    #6  0x004627de in MFM::T2ITC::tryHandlePacket (
        this=0x4d9dd0 <MFM::T2Tile::get()::THE_INSTANCE+3280>, dispatch=true)
        at src/T2ITC.cpp:371
    #7  0x00460a8e in MFM::T2ITC::pollPackets (
        this=0x4d9dd0 <MFM::T2Tile::get()::THE_INSTANCE+3280>, dispatch=true)
        at src/T2ITC.cpp:104
    #8  0x0046057e in MFM::T2ITCPacketPoller::onTimeout (
        this=0x50cbf8 <MFM::T2Tile::get()::THE_INSTANCE+211704>, srcTq=...)
        at src/T2ITC.cpp:28
    #9  0x00468b0a in MFM::T2Tile::main (
        this=0x4d9100 <MFM::T2Tile::get()::THE_INSTANCE>) at src/T2Tile.cpp:599
    #10 0x0044d04a in MFM::MainDispatch (argc=7, argv=0xbefffc94)
        at src/main.cpp:78
    #11 0x0044d22c in main (argc=7, argv=0xbefffc94) at src/main.cpp:106
    (gdb)

[111:

Wed Jun 17 02:25:02 2020 When we start up again,

TODO:
[118: Thu Jun 18 01:36:31 2020
DONE :118] - Review the center mapping and ITC rectangles

[120: Well, added '-mcsv' and '-mitc' to see stuff.  For now call it
DONE :120] - Figure out a way to debug-log ground truth on what the mapping
   should be.

[119:
DONE :119] - Debug-log position and info whenever the bein decides to change
   direction

 - Write a routine to debug-log dump all the in-use active EWs and all
   the in-use passive EWs

:111]

:110]
[112:

Wed Jun 17 10:20:57 2020 OK, I've been working through

    t2@beaglebone:~/MFM$ ./bin/Weaver /tmp/t2trace17.dat
    11: MSG: WP 0
    0/ /tmp/t2trace17.dat

for the last few minutes and I'm pretty sure we
have found an issue.  I'll annotate a segment here:

    16.088 0/a16-IDLE -> AINIT
    16.088 0/a16-AINIT a@(37,31)+4

Event at (37,31) begins in a16.

    16.088 0/a16-AINIT SE CS_UNUSED -> CS_BOUND

Although ITC SE is currently SHUT, if it were to begin to open, it
would have to wait for a16, because (37,31) is relevant (visible?)
there, so an a16<->iSE circuit is bound.

    16.088 0/lDBG EW16-AC/AINIT sites available
    16.088 0/lDBG EW16-AC/AINIT OWNING (37,31)+4
    16.088 0/a16-AINIT -> ABEHAVE
    16.088 0/lDBG EW16-AC/ABEHAVE (37,31)BEIN ngb 6 live 1

Debug log from our bein: It's heading for (relative) site 6 (i.e., SW,
which is (36,32) at the moment), and that site is live.

    16.089 0/lDBG EW16-AC/ABEHAVE FREEING (37,31)+4
    16.089 0/a16-ABEHAVE -> IDLE

a16 event is done.  (There's now trace code to show the circuit being
unbound, but that wasn't in this trace, so we have to just take it on
faith.)

    16.096 0/a12-IDLE -> AINIT
    16.096 0/a12-AINIT a@(36,32)+4
    16.096 0/a12-AINIT SE CS_UNUSED -> CS_BOUND
    16.096 0/lDBG EW12-AC/AINIT sites available
    16.096 0/lDBG EW12-AC/AINIT OWNING (36,32)+4
    16.097 0/a12-AINIT -> ABEHAVE
    16.098 0/lDBG EW12-AC/ABEHAVE (36,32)BEIN ngb 6 live 1

Again the bein goes SW, now from (36,32) to (35,33).

    16.098 0/lDBG EW12-AC/ABEHAVE FREEING (36,32)+4
    16.098 0/a12-ABEHAVE -> IDLE
    16.124 0/a02-IDLE -> AINIT
    16.124 0/a02-AINIT a@(35,33)+4
    16.124 0/a02-AINIT SE CS_UNUSED -> CS_BOUND
    16.124 0/a02-AINIT SW CS_UNUSED -> CS_BOUND

Exciting!  For (35,33)+4 circuits through both ITC_SE and ITC_SW must
be bound.  (And ITC_SW is OPEN!)

    16.124 0/lDBG EW02-AC/AINIT sites available
    16.124 0/lDBG EW02-AC/AINIT OWNING (35,33)+4
    16.125 0/lDBG EW02-AC/AINIT RING abs(35,33) usrel(35,1) yoink=1

a02 rings SW, claiming the desired event center is at (35,1) relative
to the SW ITC.

    16.135 0/iSW:OPEN >SW:RING#2(35,1)+4o +5
    16.135 0/a02-AINIT SW CS_BOUND -> CS_RUNG
    16.135 0/a02-AINIT -> AWLOCKS

The ring packet ships out SW!
The SW circuit state tracks the action!
a02 shifts to waiting for lock acknowledgments!

    16.138 0/iNE:OPEN <NE:RING#2(35,1)+4o +5

Via loopback cable, the ring packet arrives NE.

    16.138 0/lDBG ITC/NE:OPEN: HRP abs(59,1) themrel(35,1) yoink=1

To ITC-NE, relative (35,1) maps to tile coord (59,1) -- which I
thought was clearly wrong, when I started this annotation, because the
tile is only 56 sites wide even if you include the cache.

But now I'm not sure that it is wrong.  A radius 4 event centered on
(59,1) would reach down to (55,1), and that is in cache.

So we're no longer sure we're going to see a bug here, but let's push
on through this event.

    16.149 0/pNE02-PINIT -> PINIT

Because the ring packet arrived on circuit 2, NE fires up passive EW02
to track the action.

    16.149 0/pNE02-PINIT p@(59,1)+4

Its center is set all the way off-tile.

    16.149 0/pNE02-PINIT NE CS_BOUND -> CS_RUNG

The dedicated passive circuit (which never goes all the way back to
CS_UNUSED) updates.

    16.149 0/pNE02-PINIT -> PRESOLVE

p02 goes to resolve races.

    16.149 0/pNE02-PRESOLVE -> PWCACHE

But there are none.  It advances to waiting for cache updates.

    16.152 0/iNE:OPEN >NE:ANSWER#2 +2

And answers the ring packet: Lock granted!

    16.152 0/pNE02-PWCACHE NE CS_RUNG -> CS_ANSWERED

The passive circuit tracks.

    16.158 0/iSW:OPEN <SW:ANSWER#2 +2

The answer arrives back SW.

    16.158 0/lDBG ITC/SW:OPEN: Enter HAP
    16.158 0/a02-AWLOCKS SW CS_RUNG -> CS_ANSWERED

a02's SW circuit tracks the progress.

    16.158 0/lDBG ITC/SW:OPEN EW02-AC/AWLOCKS HAP

ITC/SW handles the answer packet

    16.158 0/lDBG EW02-AC/AWLOCKS hACK ITC/SW:OPEN

Dishing it to a02.

    16.158 0/a02-AWLOCKS -> ABEHAVE

Which is now ready to rumble.

    16.159 0/lDBG EW02-AC/ABEHAVE (35,33)BEIN ngb 6 live 1

The bein sees dir 6 is clear ahead (and advances to (34,34), though we
just have to know that at this point).

    16.159 0/a02-ABEHAVE -> ASCACHE
    16.170 0/iSW:OPEN >SW:TALK#2 +29
    16.170 0/a02-ASCACHE -> AWACKS

a02 ships a cache update and starts to wait for acknowledgments.

    16.174 0/iNE:OPEN <NE:TALK#2 +29
    16.174 0/lDBG ITC/NE:OPEN: Enter HCUP
    16.174 0/pNE02-PWCACHE NE CS_ANSWERED -> CS_TALKED
    16.174 0/lDBG EW02-NE/PWCACHE (C_TALKED(EW02-NE/PWCACHExITC/NE:OPEN)) cPEWAHU

Cache update is processed by NE p02, and committed to the tile.

    16.177 0/iNE:OPEN >NE:HANGUP#2 +2

And it ships the hangup packet.

    16.177 0/pNE02-PWCACHE -> PINIT
    16.177 0/lDBG EW02-NE/PINIT PASSIVE DONE

And the event is done on the passive side.

    16.185 0/iSW:OPEN <SW:HANGUP#2 +2

The hangup arrives SW.

    16.185 0/lDBG ITC/SW:OPEN: Enter HUP
    16.185 0/lDBG EW02-AC/AWACKS hHU ITC/SW:OPEN
    16.185 0/lDBG EW02-AC/AWACKS FREEING (35,33)+4
    16.185 0/a02-AWACKS -> IDLE

a02 commits to the tile, and the event ends active side.

[113:

Wed Jun 17 11:02:25 2020 Well, so that's not a bug case I think, but
there's lots more t2trace17 to look at, and we KNOW there are bugs in
the end.  Back after bfast.
[114:

Wed Jun 17 11:32:52 2020 We need to print out a for-real ASCII tile
map, so we can align tile coordinates with ITC zones and such with
some kind of confidence.  Let's just whip that up before struggling
forward in t2trace17.[115:

Wed Jun 17 12:39:46 2020 OK here it is, all the way-too-wide of it:

root@beaglebone:/home/t2/MFM/src/drivers/mfmt2# ../../../bin/mfmt2 -m
11: MSG: ctor Sites 0x5976C0
12: MSG: CPU Frequency -> 600MHz
     0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55
 0 c34c34c34c34c34c34c34c34 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4c45c45c45c45c45c45c45c45 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5c05c05c05c05c05c05c05c05  0
 1 c34c34c34c34c34c34c34c34 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4c45c45c45c45c45c45c45c45 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5c05c05c05c05c05c05c05c05  1
 2 c34c34c34c34c34c34c34c34 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4c45c45c45c45c45c45c45c45 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5c05c05c05c05c05c05c05c05  2
 3 c34c34c34c34c34c34c34c34 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4 c4c45c45c45c45c45c45c45c45 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5 c5c05c05c05c05c05c05c05c05  3
 4 c34c34c34c34o34o34o34o34 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4o45o45o45o45o45o45o45o45 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5o05o05o05o05c05c05c05c05  4
 5 c34c34c34c34o34o34o34o34 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4o45o45o45o45o45o45o45o45 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5o05o05o05o05c05c05c05c05  5
 6 c34c34c34c34o34o34o34o34 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4o45o45o45o45o45o45o45o45 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5o05o05o05o05c05c05c05c05  6
 7 c34c34c34c34o34o34o34o34 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4 o4o45o45o45o45o45o45o45o45 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5 o5o05o05o05o05c05c05c05c05  7
 8  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0  8
 9  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0  9
10  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 10
11  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 11
12  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 12
13  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 13
14  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 14
15  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 15
16  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 16
17  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 17
18  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 18
19  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 19
20  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 20
21  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 21
22  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 22
23  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 23
24  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 24
25  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 25
26  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 26
27  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 27
28  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 28
29  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 29
30  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 30
31  c3 c3 c3 c3 o3 o3 o3 o3  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o o0 o0 o0 o0 c0 c0 c0 c0 31
32 c23c23c23c23o23o23o23o23 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2o12o12o12o12o12o12o12o12 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1o01o01o01o01c01c01c01c01 32
33 c23c23c23c23o23o23o23o23 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2o12o12o12o12o12o12o12o12 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1o01o01o01o01c01c01c01c01 33
34 c23c23c23c23o23o23o23o23 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2o12o12o12o12o12o12o12o12 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1o01o01o01o01c01c01c01c01 34
35 c23c23c23c23o23o23o23o23 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2o12o12o12o12o12o12o12o12 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1 o1o01o01o01o01c01c01c01c01 35
36 c23c23c23c23c23c23c23c23 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2c12c12c12c12c12c12c12c12 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1c01c01c01c01c01c01c01c01 36
37 c23c23c23c23c23c23c23c23 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2c12c12c12c12c12c12c12c12 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1c01c01c01c01c01c01c01c01 37
38 c23c23c23c23c23c23c23c23 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2c12c12c12c12c12c12c12c12 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1c01c01c01c01c01c01c01c01 38
39 c23c23c23c23c23c23c23c23 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2c12c12c12c12c12c12c12c12 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1 c1c01c01c01c01c01c01c01c01 39
     0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55
root@beaglebone:/home/t2/MFM/src/drivers/mfmt2#
Ugh maybe we should try to get it down to two-columns per?  Nah screw it.

:115]

:114]

:113]

:112]
[116:

Wed Jun 17 16:15:42 2020 OK well with my added debug tools I think I
have found one problem anyway.  This:

    #define T2_SITE_IS_VISIBLE_OR_CACHE(u32x,u32y)  \
      (((u32x)<2*CACHE_LINES)                       \
       || ((u32y)<2*CACHE_LINES)                    \
       || ((u32x)>T2TILE_WIDTH-2*CACHE_LINES)       \
       || ((u32y)>T2TILE_HEIGHT-2*CACHE_LINES))     \

should be this:

    #define T2_SITE_IS_VISIBLE_OR_CACHE(u32x,u32y)  \
      (((u32x)<2*CACHE_LINES)                       \
       || ((u32y)<2*CACHE_LINES)                    \
       || ((u32x)>=T2TILE_WIDTH-2*CACHE_LINES)      \
       || ((u32y)>=T2TILE_HEIGHT-2*CACHE_LINES))    \

and similarly for T2_SITE_IS_CACHE.

DOH.

Let's see how much difference fixing just those makes..

:116]
[117:

Thu Jun 18 01:35:18 2020 Well, have been going since about 11pm and
making a lot of progress.  Understanding the aew vs pew cache update
coord mappings properly, for example.
[121:

Thu Jun 18 01:39:19 2020 And now it's looking like the passive EW
never actually loads the sites from the tile?  But it compares all the
EW atoms (up to mLastSN) against the tile ones, and writes any
changes?  We need to see if this can possibly be true.  loadSites()
never getting called on pEWs?[122:

Thu Jun 18 01:43:50 2020 No, loadSites is never getting called on
pEWs.  Do we have some way to avoid needing to?[123:

Thu Jun 18 05:06:36 2020 OK, well, time to commit this stuff.  There's
still some weirdnesses even with a single bein -- like it can enter
from the NE going straight down, bounce off the bottom and go straight
back up, and yet not be able to reenter NE for some reason -- but
things are working MUCH MUCH better than before.

Yes, NOW we are loading sites on the passive window, and that appears
to have fixed the transporter duplication problems, at least for the
moment.

[124:

Thu Jun 18 05:11:41 2020 And we've been screwing around with the
display code to get the border showing which ITCs are open and so
forth.

Committing.

:124]

:123]

:122]

:121]
:117]
[125:

Thu Jun 18 12:23:50 2020 Well it's time to move the flag again.

FUN NEW APPARENT FACT: It looks like a single bein can get into a
yoink race with itself.

BACKGROUND: I left a single bein running across three otherwise empty
tiles when I went for second sleep.  When I got back it was gone.
Upon inspection I found evidence pointing to native engine restarts
due to failures at T2EventWindow.cpp:235.  Which is:

      bool T2EventWindow::passiveWinsYoinkRace(const T2EventWindow & ew) const {
        MFM_API_ASSERT_ARG(ew.isActiveEW());     // ew is our side active initiation
        MFM_API_ASSERT_ARG(!this->isActiveEW()); // *this is passive ew for them
235->   FAIL(INCOMPLETE_CODE);
        return false;
   ..

[126:

Thu Jun 18 12:28:03 2020 So I'm guessing what might have happened is
that:

(1) The bein did an event that crossed tiles
(2) The passive side -- necessarily the bein's 'arrival' side --
    finished the event first, as it does.  It sent the hangup and then
    released the pEW.
(3) The active side received that hangup and cleaned up that circuit,
    BUT, it could not tear down the whole event because it was waiting
    for a hangup from its SECOND ITC.
(4) The previously-passive side starts an event on the bein and
    requests a lock from the previously-and-not-quite-down active
    side.
(5) Race -> incomplete code -> fail out top-level -> engine restart

[127:

Thu Jun 18 12:35:15 2020 So if this story is true, a key part of it is
an active ew that's holding two locks.  Otherwise, the aEW would get
torn down as soon as the (only) hangup was received, and the lock
request right behind it would find nothing to race against.  (Since by
assumption there's only one bein in the entire universe.)

:127]
:126]

:125]
[128:

Fri Jun 19 05:23:56 2020 OK let's deal with the effen yoink races again.

:128]
[129:

Fri Jun 19 07:13:19 2020 Well, another thing we see is there's some
kind of infelicity that sometimes causes ITCs to take a very long time
to get to OPEN, although they do get there.  I think I just captured
two -l4 trace files of that happening; we should try to get them
together and see what's going on.  (It appears to be one side keeps
doing CACHEXG while the other keeps saying SHUT, but the details are
absolutely unclear.)[130:

Fri Jun 19 08:46:21 2020 Well the first issue seems to be that when
ITC A 'spontaneously' sends SHUT to ITC B, ITC B advances to DRAIN,
and then to CACHEXG, which sends a CACHEXG packet back to ITC A.  But
ITC A is still in state SHUT (not DRAIN), and it encounters this code:

 ..
  void T2ITCStateOps_CACHEXG::receive(T2ITC & itc, T2PacketBuffer & pb, TimeQueue& tq) {
    if (itc.getITCSN() < ITCSN_DRAIN) itc.reset();
 ..

which causes ITC A to reset, so eventually ITC A sends another SHUT,
while ITC B is waiting for inbound CACHEXG.

Like this:

    77.242         1/iSW:SHUT >iSW:SHUT?784756B3  +6

1/iSW sends SHUT w/sync 7847

    77.245         1/iSE:SHUT >iSE:SHUT?795A6ED8  +6
    77.247         1/iNE:SHUT >iNE:SHUT?3BFEC8B4  +6

(So do SE and NE but we're not following them now.)

    77.251                 2/iNE:SHUT <iNE:SHUT?784756B3  +6

7847 arrives at 2/iNE

    77.251                 2/iNE:SHUT -> DRAIN

So 2/iNE advances to DRAIN

    77.253                 2/iNW:SHUT <iNW:SHUT?795A6ED8  +6
    77.253                 2/iNW:SHUT -> DRAIN
    77.254                 2/iNE:DRAIN -> CACHEXG
    77.260                 2/iNE:CACHEXG >iNE:CACHEXG +254

And then starts CACHEXG, sending the first packet to 1/iSW

    77.260                 2/iNW:DRAIN -> CACHEXG
    77.261         1/iSW:SHUT <iSW:CACHEXG +254

Which 1/iSW receives.  But it's unhappy with it,

    77.262         1/iSW:SHUT -> SHUT

And it resets

    77.266         1/iSW:SHUT >iSW:SHUT?49C834EE  +6

Then sends another SHUT.

[131:

Fri Jun 19 08:58:40 2020 So what's the fix?  Do we think 1/iSW
should've gone to DRAIN as soon as it sent the SHUT?  Otherwise how
can it handle the CACHEXG, when it might have EWs in progress?

But if we do say 1/iSW goes to DRAIN 'prospectively', before hearing
from 2/iNE, that's going to cause it to pause events even if there'll
be no response coming.

Hey, how come 2/iNE going to DRAIN didn't send a packet about that?
Wouldn't that be the right / a better way to deal with this?

Receive SHUT when in SHUT, go to DRAIN and send DRAIN.
Receive SHUT when in DRAIN, stay in DRAIN send DRAIN.
Receive SHUT otherwise, reset.
Receive DRAIN when in SHUT, go to DRAIN and send DRAIN.
Receive DRAIN when in DRAIN, ignore.
Timeout in SHUT, if compatible send SHUT and wait MEDIUM
Timeout in DRAIN, if EWs in use, reset (go to SHUT and send SHUT),
  else go to CACHEXG and send CACHEXG
[132:

Fri Jun 19 14:58:11 2020 That seems to've helped out with the observed
'getting to open' failures.

:132]
:131]
:130]

:129]
[133:

Fri Jun 19 14:58:54 2020 So let's sum up our 'single-bein
self-interference' problem.  It's a kind of helpful and concrete way,
if sort of weird and back-door, to get back into the race resolution
issues.

:133]
[134:

Sat Jun 20 00:56:02 2020 OK, I'm going to annotate a full trace that
captures a single-bein self-interference event.  The set-up here is
like this:

         ........ribbon.cable..
        .                      .
        .  +-----------+       .
        .  |  Tile 0/  |       .
        .  |           |       .
        .  |SW       SE|       .
        .  +||-------||+       .
        .   .       +||-------||+
         ...        |NW       NE|
                    |           |
                    |  Tile 1/  |
                    +-----------+

So the two tiles are 'cross connected' at the bottom: 0/iSE<->1/iNW,
and 0/iSW<->1/iNE.

It goes like this:

    173.703 0/a12-IDLE -> AINIT
    173.703 0/a12-AINIT a@(28,35)+4

0/a12 contemplates an event at (28,35).  Row 35 is the extreme
southern row of 'owned sites' on tile#0, and column 28 is the east
side fo the column 27-28 border which is the horizontal center of the
tile.

    173.703 0/a12-AINIT SE CS_UNUSED -> CS_BOUND

0/a12 determines the SE ITC is involved, and binds a circuit to it.

    173.703 0/a12-AINIT SW CS_UNUSED -> CS_BOUND

0/a12 determines the SW ITC is also involves and binds a second
circuit for that.

    173.704 0/lDBG a12/AINIT sites available
    173.704 0/lDBG a12/AINIT OWNING (28,35)+4

a12 takes ownership of the region out to radius 4 on tile 0/

    173.704 0/lDBG a12/AINIT RING SE abs(28,35) usrel(4,3) yoink=1
    173.706 0/iSE:OPEN >SE:RING#12(4,3)+4o +5
    173.706 0/a12-AINIT SE CS_BOUND -> CS_RUNG

a12 sends a 'RING' lock request out the SE ITC, destined for 1/iNW.

    173.706 0/lDBG a12/AINIT RING SW abs(28,35) usrel(28,3) yoink=0
    173.715 0/iSW:OPEN >SW:RING#12(28,3)+4e +5
    173.715 0/a12-AINIT SW CS_BOUND -> CS_RUNG

And sends one out the SW ITC as well.  (Although it's not significant
for this example, note how the coordinates sent in the two cases
differ -- (28,3) vs (4,3)!  RING packets use coordinates relative to
the specific ITC, and the SW ITC origin is precisely 24 sites west of
the SE ITC origin.)

    173.715 0/a12-AINIT -> AWLOCKS

0/a12 switches to waiting for lock replies.

    173.781         1/iNW:OPEN <NW:RING#12(4,3)+4o +5
    173.781         1/lDBG ITC/NW:OPEN: HRP abs(4,3) themrel(4,3) yoink=1
    173.781         1/pNW12-PINIT -> PINIT
    173.781         1/pNW12-PINIT p@(4,3)+4

The NW ITC on tile 1 receives its RING first, and inits 1/pNW12, its
passive event window corresponding to 0/a12.

    173.781         1/pNW12-PINIT NW CS_BOUND -> CS_RUNG

The passive circuit records that a ring was received.

    173.781         1/pNW12-PINIT -> PRESOLVE

The passive EW checks to see about resolving any races.

    173.781         1/pNW12-PRESOLVE -> PWCACHE
    173.783         1/iNW:OPEN >NW:ANSWER#12 +2

But there are none, so 1/pNW12 moves on waiting for cached updates and
ships the lock-granted 'ANSWER' packet back out 1/iNW.

    173.783         1/pNW12-PWCACHE NW CS_RUNG -> CS_ANSWERED

And the passive circuit records that an answer was sent.

    173.792         1/iNE:OPEN <NE:RING#12(28,3)+4e +5

Nine milliseconds later, 1/iNE receives its RING request.

    173.792         1/lDBG ITC/NE:OPEN: HRP abs(52,3) themrel(28,3) yoink=0
    173.792         1/pNE12-PINIT -> PINIT
    173.792         1/pNE12-PINIT p@(52,3)+4
    173.792         1/pNE12-PINIT NE CS_BOUND -> CS_RUNG
    173.792         1/pNE12-PINIT -> PRESOLVE
    173.792         1/pNE12-PRESOLVE -> PWCACHE
    173.794         1/iNE:OPEN >NE:ANSWER#12 +2
    173.794         1/pNE12-PWCACHE NE CS_RUNG -> CS_ANSWERED

And it performs the analogous steps, granting the lock request.

    173.856 0/iSE:OPEN <SE:ANSWER#12 +2
    173.856 0/lDBG ITC/SE:OPEN: Enter HAP
    173.856 0/a12-AWLOCKS SE CS_RUNG -> CS_ANSWERED
    173.856 0/lDBG ITC/SE:OPEN a12/AWLOCKS HAP
    173.856 0/lDBG a12/AWLOCKS hACK ITC/SE:OPEN

The 1/iNW ANSWER arrives at 0/iSE and 0/a12 processes it.

    173.858 0/iSW:OPEN <SW:ANSWER#12 +2
    173.858 0/lDBG ITC/SW:OPEN: Enter HAP
    173.858 0/a12-AWLOCKS SW CS_RUNG -> CS_ANSWERED
    173.858 0/lDBG ITC/SW:OPEN a12/AWLOCKS HAP
    173.858 0/lDBG a12/AWLOCKS hACK ITC/SW:OPEN

The 1/iSE ANSWER is handled as well.

    173.858 0/a12-AWLOCKS -> ABEHAVE

0/a12 has all the locks it needs, and moves to behave

    173.858 0/lDBG a12/ABEHAVE (28,35)BEIN ngb 3 live 1

The bein in (28,35) is heading in the '3' direction, which is straight
down south.  That's going to take it to (28,36), which the bein
examines and sees that it's alive.

And CRUCIALLY for our story, NOTE THIS: (28,36) is actually in the
CACHE of tile 0/.  It is not a 'owned sites' of tile 0/!

Recall that this whole event this began in the SOUTHERNMOST ROW of
tile 0/.  When our intrepid bein swaps one site south from there, it
will ultimately end up in the NORTHERNMOST ROW of tile 1/.

And therefore -- FORESHADOWING -- subsequent events for that bein will
be conducted by tile 1/, not tile 0/.

    173.858 0/a12-ABEHAVE -> ASCACHE

Anyway, the bein's transition takes place in 0/a12, which moves on to
the cache updates stage.

    173.859 0/lDBG SHIP#0 sn3 (28,36) tt 0xFFFF wt 0x0001
    173.859 0/lDBG SHIP#1 sn0 (28,35) tt 0x0001 wt 0xFFFF

Two sites are targeted in the cache update: (28,36) stops being empty
(type 0xFFFF) to becomes a 'bein' (type 0x0001), and (28,35) does the
reverse.

    173.861 0/iSE:OPEN >SE:TALK#12 +29

And that 'TALK' -- cache update -- gets shipped out 0/iSE.

    173.861 0/lDBG SHIP#0 sn3 (28,36) tt 0xFFFF wt 0x0001
    173.861 0/lDBG SHIP#1 sn0 (28,35) tt 0x0001 wt 0xFFFF
    173.863 0/iSW:OPEN >SW:TALK#12 +29

An analogous TALK goes out 0/iSW.

    173.863 0/a12-ASCACHE -> AWACKS

And 0/a12 settles down to await acknowledgments.

    173.989         1/iNW:OPEN <NW:TALK#12 +29
    173.989         1/lDBG ITC/NW:OPEN: Enter HCUP
    173.989         1/pNW12-PWCACHE NW CS_ANSWERED -> CS_TALKED

The 0/iSE cache update arrives at 1/iNW and is dished to 1/pNW12, and
its circuit state updates to note the TALK arrival.

    173.989         1/lDBG p12NW/PWCACHE CUPSN#3 mLastSN 40

1/pNW12 starts processing the cache update.

    173.989         1/lDBG RECV#0 sn3 (4,4) tt 0xFFFF wt 0x0001

1/pNW12's site (4,4) becomes a bein (type 1) instead of empty.

NOTE THAT (4,4) is an OWNED SITE!  Tile 1/ can run events there!

    173.989         1/lDBG p12NW/PWCACHE CUPSN#0 mLastSN 40
    173.989         1/lDBG RECV#1 sn0 (4,3) tt 0x0001 wt 0xFFFF

And 1/pNW12's site (4,3) (which is in tile 1/'s cache) becomes empty.

    173.989         1/lDBG p12NW/PWCACHE CUPSN#255 mLastSN 40

CUPSN#255 means 'no more cache updates'.

    173.989         1/lDBG p12NW/PWCACHE (C_TALKED(p12NW/PWCACHExITC/NW:OPEN)) cPEWAHU

So 1/pNW12 commits!  Its changes get written to tile 1/ site memory!

    173.991         1/iNW:OPEN >NW:HANGUP#12 +2

It sends a HANGUP packet out on 1/iNW, marking the end of the event
from its point of view.

    173.991         1/pNW12-PWCACHE -> PINIT
    173.991         1/lDBG p12NW/PINIT PASSIVE DONE

And 1/pNW12 resets its circuit, and -- as far as 1/pNW12 is concerned
-- the event is done.

    174.000         1/iNE:OPEN <NE:TALK#12 +29

Similarly, the 0/iSW cache update arrives at 1/iNE.

    174.000         1/lDBG ITC/NE:OPEN: Enter HCUP
    174.000         1/pNE12-PWCACHE NE CS_ANSWERED -> CS_TALKED
    174.000         1/lDBG p12NE/PWCACHE CUPSN#3 mLastSN 40
    174.000         1/lDBG RECV#0 sn3 (52,4) tt 0x0001 wt 0x0001
    174.000         1/lDBG p12NE/PWCACHE CUPSN#0 mLastSN 40
    174.000         1/lDBG RECV#1 sn0 (52,3) tt 0x0001 wt 0xFFFF

Affecting two sites (52,4) and (52,3), that are in the tile/1's cache
off in the northeast.

    174.000         1/lDBG p12NE/PWCACHE CUPSN#255 mLastSN 40
    174.000         1/lDBG p12NE/PWCACHE (C_TALKED(p12NE/PWCACHExITC/NE:OPEN)) cPEWAHU
    174.002         1/iNE:OPEN >NE:HANGUP#12 +2

And 1/pNE12 ships its HANGUP packet too.

    174.002         1/pNE12-PWCACHE -> PINIT
    174.002         1/lDBG p12NE/PINIT PASSIVE DONE

And likewise, the event is now done as far as 1/pNE12 is concerned.

So let's pause for a minute and review where we are.  Over on tile 0/,
0/a12 started an event, got locks on 1/iNE and 1/iNW, did the
transition, and send out two cache updates.

At the moment, 0/a12 is in state AWACKS, waiting for acknowledgments
of the cache udpates.

But here on tile 1/, the cache updates have been processed by 1/pNW12
and 1/pNE12, and the HANGUP packets have been sent, and all is quiet.

    174.006         1/a17-IDLE -> AINIT
    174.006         1/a17-AINIT a@(4,4)+4

SO THEREFORE, FOUR MILLISECONDS LATER, THERE'S NO REASON *NOT* TO
START AN EVENT ON TILE 1.  And 1/a17 sets off to do just that.

    174.006         1/a17-AINIT WT CS_UNUSED -> CS_BOUND
    174.006         1/a17-AINIT NW CS_UNUSED -> CS_BOUND

From Tile 1's point of view, site (4,4) requires the involvement of
1/iWT and 1/iNW, so those two circuits are bound.  Now in this case,
1/iWT is SHUT, so no lock request is needed there.

    174.006         1/lDBG a17/AINIT sites available
    174.006         1/lDBG a17/AINIT OWNING (4,4)+4
    174.006         1/lDBG a17/AINIT RING NW abs(4,4) usrel(4,0) yoink=1
    174.008         1/iNW:OPEN >NW:RING#17(4,0)+4o +5

But 0/iNW is OPEN, and so 1/a17 it sends a RING lock request that way.

    174.008         1/a17-AINIT NW CS_BOUND -> CS_RUNG
    174.008         1/a17-AINIT -> AWLOCKS

And records that fact, and goes to await lock acknowledgments.

    174.068 0/iSE:OPEN <SE:HANGUP#12 +2

Back on tile 0/, the HANGUP packet shipped by 1/p12NW arrives at
0/iSE.

    174.068 0/lDBG ITC/SE:OPEN: Enter HUP
    174.068 0/a12-AWACKS SE CS_ANSWERED -> CS_UNUSED
    174.068 0/lDBG a12/AWACKS hHU ITC/SE:OPEN

And 0/a12 handles it, and tears down the SE circuit, which is no
longer needed.

BUT 0/a12 CAN'T FINISH THE EVENT COMPLETELY YET, BECAUSE IT IS STILL
WAITING FOR THE HANGUP FROM 0/iSW!

And that HANGUP packet is (almost surely) available, just sitting in
the 0/iSW buffers waiting to be picked up.

    174.075 0/iSE:OPEN <SE:RING#17(4,0)+4o +5

But for now, tile 0/ continues checking for packets from 0/iSE!

    174.075 0/lDBG ITC/SE:OPEN: HRP abs(28,36) themrel(4,0) yoink=1

And indeed there's a packet to be found there!  It's the RING request
from 1/a17!  ONO!

    174.075 0/pSE17-PINIT -> PINIT
    174.075 0/pSE17-PINIT p@(28,36)+4
    174.075 0/pSE17-PINIT SE CS_BOUND -> CS_RUNG

And 0/pSE17 gets initialized to handle the RING.

    174.075 0/pSE17-PINIT -> PRESOLVE

And it goes to resolve any possible races.

AND THE CODE BLOWS UP RIGHT THERE, BECAUSE IT DETECTS A RACE WITH THE
STILL-EXISTING 0/a12 !!!!  A SINGLE BEIN RACES AGAINST ITSELF!

The 0/ mfmt2 was running inside gdb, and it blocked as soon as they
hit the error.

    186.988         1/iNE:OPEN >iNE:OPEN?5F58690E  +6
    188.972         1/iNW:OPEN >iNW:OPEN?1C380EEB  +6

The 1/ mfmt2 survived a little longer, sending out a couple OPEN
notifications, before it too hit a gdb breakpoint and blocked.

    16971.834         1/t  Failed to top: src/T2EventWindow.cpp:836: INCOMPLETE_CODE [1]

The failures didn't get recorded until way later, when I showed up
again and continue gdb -- thus the time jump from 188 -> 16971.

1/ died here, once it timed-out waiting for a lock ack that never
arrived:

T2EventWindow.cpp:835:      LOG.Error("%s on %s: TO AWLOCKS with pending locks", getStateName(), ew.getName());
T2EventWindow.cpp:836:      FAIL(INCOMPLETE_CODE);

    16974.017         1/t  Total events completed = 3697250
    17033.102 0/t  Failed to top: src/T2EventWindow.cpp:235: INCOMPLETE_CODE [1]

while 0/ died here

T2EventWindow.cpp:832:  bool T2EventWindow::passiveWinsYoinkRace(const T2EventWindow & ew) const {
T2EventWindow.cpp:833:    MFM_API_ASSERT_ARG(ew.isActiveEW());     // ew is our side active initiation
T2EventWindow.cpp:834:    MFM_API_ASSERT_ARG(!this->isActiveEW()); // *this is passive ew for them
T2EventWindow.cpp:835:    FAIL(INCOMPLETE_CODE);
T2EventWindow.cpp:836:    return false;

    17035.236 0/t  Total events completed = 2048941
    [Inferior 1 (process 6427) exited normally]
    (gdb)

:134]
[135:

Sat Jun 20 04:10:17 2020 And YIKES that annotation took THREE HOURS?
Granted I screwed around SOME while doing it, but geez.. I hope it's
worth it.

:135]
[136:

Sat Jun 20 04:53:27 2020 So, discussion question:

HOW TO FIX SINGLE-BEIN SELF INTERFERENCE?

And, restatement: SHOULD WE FIX SINGLE-BEIN SELF INTERFERENCE?

Here's how it looks to me:

(1) If we had added yet one more leg to the event, the passive sides
    could send their HANGUPs but wait for the active side to also hang
    up, before releasing their sites.

(2) That would slow things down, but would 'guarantee' that the active
    EW -- which is the one potentially holding multiple locks --
    finishes before the passive EW, which is releasing only a single
    lock.

(3) What I don't like about that is it seems like it gives a
    rich-get-richer repeated advantage to the active side: At the
    moment that that aEW releases, its tile will be the only one that
    could regrab those sites (or overlapping ones) for another event.
    I worry about 'stochastic starvation' on the passive sides causing
    highly irregular event patterns with high-variance statistics.

(4) And finally, if we FOGGEN GET THE RACE RESOLUTION CODE WRITTEN, we
    could 'just' go ahead and let the (previously) passive side try to
    grab the lock, and have the (still) active side NAK it, if the
    passive new request happens to get in ahead of the last HANGUP the
    old active is still waiting for.

:136]
[137:

Sat Jun 20 05:19:46 2020 Time for morning walk.

:137]
[138:

Sat Jun 20 05:53:01 2020 OK, so

PASSIVE SIDE RACE RULES GO GO GO

 - On receive RING, scan requested region and assemble conflict set

 - Perhaps sort the conflict set according to some notion of age
   (literal wall clock oldest?  Farthest advanced through its event
   sequence?  The latter, breaking ties with the former?)

 - But in any case, eventually, do cases.  And what are the cases?

The case we just annotated was

EXISTING 0/a12-AWACKS vs INCOMING 0/pSE17-PRESOLVE

 -> suggested resolution: NAK the passive and tear it down, done.

[139:

Sat Jun 20 06:27:21 2020 I guess the next question is: Is there really
any OTHER possible outcome, given an inbound passive vs an existing
active?

Well, sure there is: If the existing active is in state AWLOCKS,
that's when we have the yoink race.[140: Sat Jun 20 06:43:08 2020 So
okay what are the cases there?

 - If existing AWLOCKS wins the race, NAK the inbound passive.

 - If existing AWLOCKS loses the race, then DROP any existing locks it
   may have, then tear down the aEW, then allow the inbound passive
   processing to continue.  (Even though it might later fail on some
   other conflict -- meaning both racing aEWs end up blown up.  So be
   it.)

:140]

And then the other category is inbound passive against existing
passive.  In that case it seems like we have to NAK.

:139]

:138]
[141:

Sat Jun 20 06:47:59 2020 And is that it?  To summarize:

=====
PAIRWISE PASSIVE-SIDE CONFLICT RESOLUTION RULES

 VS EXISTING ACTIVE:
 Case 1a: Existing active state is > AWLOCKS.
 Resolution: NAK inbound passive and tear it down.

 Case 2a: Existing active state is == AWLOCKS and WINS Yoink race
 Resolution: NAK inbound passive and tear it down.

 Case 3a: Existing active state is == AWLOCKS and LOSES Yoink race
 Resolution: DROP any aEW circuits at CS_ANSWERED, then tear down aEW

 VS EXISTING PASSIVE:
 Case 1p: Existing passive in any state.
 Resolution: NAK inbound passive and tear it down
=====

and then this would be the entire

=====
INCOMING PASSIVE SIDE RING HANDLING PROCESS

1. Assemble EW conflict set

2. Sort conflict set

3. For each member of the conflict set in turn, perform the PAIRWISE
   PASSIVE-SIDE CONFLICT RESOLUTION to decide who dies.  If the
   inbound passive dies, stop the loop, send NAK, and kill the passive

4. If the inbound passive survives all conflicts, continue from there
   as if no conflicts occured (since they must now all be gone.)
=====

[142:

Sat Jun 20 07:36:15 2020 And I guess the 'last' question is so yes how
do we sort the conflicts?

 - If we have any freedom in the matter, would we want to organize
   things to kill the inbound as quick as possible?  Like sort pEW
   conflicts ahead of active ones?

But does that even make sense?  Suppose we kill the inbound pEW
because of some other established pEW.  ...I still get confused.

Try again.

We're saying that the receiver of an inbound (passive) lock request
has the absolute right to ACK/NAK it, basically for any reason, and
the RING sending (active) side has to both (1) Wait for that ACK/NAK,
and (2) Abide by it.

At the same time, we're saying the active side has the absolute right
to DROP an established circuit to a passive side that ANSWERed its
original RING.  And once again, it can do that for basically any
reason, and the ANSWER sending (passive) side has to accept it and
tear down its event.

SO IN THAT CONTEXT, we could, if we wanted, simply always NAK
conflicting inbound passives, and that would be completely 'legal'.
But since both sides would be be doing that, in a genuine race, we'd
always end up blowing up both events.

So we employ the yoink protocol in an attempt to blow up fewer events.
The results of yoinking must be that at most one conflicting aEW
survives.  And we ensure that by ACKing an inbound passive only after
we've blown up any lost-race existing AWLOCKS.

And it's okay if zero aEWs survive in complex cases, because that's
what would have happened without the yoink anyway (supposedly; we
allege).

[143:

Sat Jun 20 08:58:15 2020 Nap time.  Then we have to polish the
extended abstract for ALIFE2020.  So we won't get back to this until
Sunday, grr.

:143]
:142]

:141]
[144:

Mon Jun 22 02:20:15 2020 Well, finishing the "SPOTs and Spatial
Threads" mini-paper of course took longer that 'planned'.  But it's
shipped now (and it's a lot better than it was at initial submission,
so there's that).

:144]
[145:

Mon Jun 22 02:21:14 2020 But now we're barely over 24 hours till we
need to be shooting the update: How much race resolution do you think
we can get going?

[146:

Mon Jun 22 02:22:12 2020 Who knows; let's find out; follow :141: above
- GO GO GO
[147:

Mon Jun 22 03:11:56 2020 OK we have a reinstated passiveWinsYoinkRace
that I guess we want to commit, because it's not obviously stupid and
that's the easiest way to get the code to the next-door tiles doh.

[148:

Mon Jun 22 03:55:58 2020 OK here's an issue coming up that we kind of
wondered if it would.  This code:

    // our ew must also have itc in its info, but we have to search for it
    const Circuit *aci = ew.getActiveCircuitForITCIfAny(itc);
    MFM_API_ASSERT_NONNULL(aci);

is blowing up because 'itc' is pointing at iNE, but ew's circuits
never mention that, because:

    (gdb) p ew.mActiveCircuits[0].mITC
    $15 = (MFM::T2ITC *) 0x0
    (gdb) p ew.mActiveCircuits[1].mITC
    $16 = (MFM::T2ITC *) 0x4dd0a0 <MFM::T2Tile::get()::THE_INSTANCE+3976>
    (gdb) p ew.mActiveCircuits[1].mITC->mName
    $17 = 0x4966a8 "NW"
    (gdb)

ew only mentions iNW.  Why?  Well for one thing, active-side ew and
passive-side *this have different event centers:

    (gdb) p ew.mCenter
    $18 = {m_x = 35, m_y = 4}
    (gdb) p this->mCenter
    $19 = {m_x = 36, m_y = 3}
    (gdb)


For (35,4), well y==4 is the top row of owned sites, and with x==35,
radius 4 just barely reaches (31,4), which is in the iNW visible
rectangle.  So it makes sense that ew has bound a circuit through
iNW.

What doesn't make sense to me at the moment is: Why isn't iNE in ew's
circuits as well??  (35,4) is totally in the visible rectangle of iNE!

And iNE is definitely open for business:

    (gdb) p itc.mName
    $22 = 0x4966ac "NE"
    (gdb) p itc.mStateNumber
    $23 = MFM::ITCSN_OPEN
    (gdb)

So what's the deal???
[149:

Mon Jun 22 04:13:26 2020 So hey look at this, from the (still-open)
trace file for this run:

    49.315 0/a17-IDLE -> AINIT
    49.315 0/a17-AINIT a@(35,4)+4
    49.316 0/a17-AINIT NE CS_UNUSED -> CS_BOUND
    49.316 0/a17-AINIT NW CS_UNUSED -> CS_BOUND
    49.316 0/lDBG a17/AINIT sites available
    49.316 0/lDBG a17/AINIT OWNING (35,4)+4
    t2@beaglebone:~/MFM/src/drivers/mfmt2$

(There's probably more events that haven't been flushed to disk yet,
but anyway.)  So that sure makes it look like both iNW and iNE were
bound for this event.

[150:

Mon Jun 22 04:29:33 2020 So hey, I think this might be yet another
thinko on my part.  In particular, recall our current physical setup:

         ........ribbon.cable..
        .                      .
        .  +-----------+       .
        .  |           |       .
        .  |   'BLUE'  |       .
        .  |SW       SE|       .
        .  +||-------||+       .
        .   .       +||-------||+
         ...        |NW       NE|
                    |   'RED'   |
                    |           |
                    +-----------+


Note I'm going to be showing traces from UNALIGNED files, here -- so
they have different timebases and they both think they're '0/'.  The
above trace, with the active EW, we'll say is from the RED tile, and
the trace below, with the passive EWs, we'll say is from the BLUE
tile.

    91.200 0/iSW:OPEN <SW:RING#17(11,0)+4e +5

BLUE's iSW recvs RED's active ring#17 via NE (and the ribbon cable).

    91.200 0/lDBG ITC/SW:OPEN: HRP abs(11,36) themrel(11,0) yoink=0

(11,0) relative to the NE visible rect is indeed (35,4) in RED coords.

    91.200 0/pSW17-PINIT -> PINIT
    91.200 0/pSW17-PINIT p@(11,36)+4
    91.200 0/pSW17-PINIT SW CS_BOUND -> CS_RUNG
    91.200 0/pSW17-PINIT -> PRESOLVE
    91.200 0/pSW17-PRESOLVE -> PWCACHE

pSW17 sees no conflict.

    91.202 0/iSW:OPEN >SW:ANSWER#17 +2
    91.202 0/pSW17-PWCACHE SW CS_RUNG -> CS_ANSWERED

And so it grants the lock, answering back on SW.

    91.203 0/iSE:OPEN <SE:RING#17(35,0)+4o +5
    91.203 0/lDBG ITC/SE:OPEN: HRP abs(59,36) themrel(35,0) yoink=1

Now here comes a RING#17 on SE.  It's at (35,0) relative to the NW
visible rectangle -- it isn't even _in_ the NE viz rectangle, but the
radius of four just stretches from (35,0) down to (31,0), which is in
the NW viz rect.

    91.203 0/pSE17-PINIT -> PINIT
    91.203 0/pSE17-PINIT p@(59,36)+4

In BLUE terms, this center is way off in the SE at (59,36)

    91.203 0/pSE17-PINIT SE CS_BOUND -> CS_RUNG
    91.203 0/pSE17-PINIT -> PRESOLVE

Which also appears available.

    91.204 0/pSE17-PRESOLVE -> PWCACHE
    91.205 0/iSE:OPEN >SE:ANSWER#17 +2
    91.205 0/pSE17-PWCACHE SE CS_RUNG -> CS_ANSWERED

So BLUE grants that lock as well.

At this point, from BLUE's point of view, RED's a17 is hogging a total
of 82 BLUE sites at two different locations!

    91.320 0/iSW:OPEN <SW:TALK#17 +29

Here comes an a17 cache update in on SW.

    91.320 0/lDBG ITC/SW:OPEN: Enter HCUP
    91.320 0/pSW17-PWCACHE SW CS_ANSWERED -> CS_TALKED
    91.320 0/lDBG p17SW/PWCACHE CUPSN#7 mLastSN 40
    91.320 0/lDBG RECV#0 sn7 (12,35) tt 0xFFFF wt 0x0001
    91.320 0/lDBG p17SW/PWCACHE CUPSN#0 mLastSN 40
    91.320 0/lDBG RECV#1 sn0 (11,36) tt 0x0001 wt 0xFFFF

pSW17 processes it.

    91.320 0/lDBG p17SW/PWCACHE CUPSN#255 mLastSN 40
    91.320 0/lDBG p17SW/PWCACHE (C_TALKED(p17SW/PWCACHExITC/SW:OPEN)) cPEWAHU
    91.322 0/iSW:OPEN >SW:HANGUP#17 +2
    91.322 0/pSW17-PWCACHE -> PINIT
    91.322 0/lDBG p17SW/PINIT PASSIVE DONE

and p17SW commits, hangs up, and is done.

    91.329 0/iSE:OPEN <SE:TALK#17 +29

Here comes the (analogous) cache update on SE.

    91.329 0/lDBG ITC/SE:OPEN: Enter HCUP
    91.329 0/pSE17-PWCACHE SE CS_ANSWERED -> CS_TALKED

And pSE17 is on the case.

    91.329 0/lDBG p17SE/PWCACHE CUPSN#7 mLastSN 40
    91.329 0/lWRN p17SE/PWCACHE sn7/(60,35) not accessible by ITC/SE:OPEN; ignored
    91.329 0/lDBG p17SE/PWCACHE CUPSN#0 mLastSN 40
    91.329 0/lWRN p17SE/PWCACHE sn0/(59,36) not accessible by ITC/SE:OPEN; ignored

It actually rejects both updates, because the resolved site numbers
aren't actually accessible from the SE.  And, really, RED a17
shouldn't have sent them to us, because it knows they're invalid on
this circuit -- but for the moment I'm leaving that active-side bug in
there to test the passive side rejection.

    91.329 0/lDBG p17SE/PWCACHE CUPSN#255 mLastSN 40
    91.329 0/lDBG p17SE/PWCACHE (C_TALKED(p17SE/PWCACHExITC/SE:OPEN)) cPEWAHU
    91.331 0/iSE:OPEN >SE:HANGUP#17 +2
    91.331 0/pSE17-PWCACHE -> PINIT

And that hangs up too.

    t2@beaglebone:~/MFM/src/drivers/mfmt2$

And that's all we've got so far.

[151:

Mon Jun 22 04:56:28 2020 Hmm, so well the thinko I thought I might
have didn't actually pan out.  I was worried the cross-couple
NE/SW+NW/SE would lead to a single event trying to take two locks on
the same remote sites -- but as we saw, that's not what happens: The
remote sites are far apart, and both get taken.

Well, so do we need to let these guys fail and die, so we can get our
trace buffers flushed and see the ends of the stories?

We still don't have an explanation for how a17 ended up with no NE
circuit.  Oh -- would that be just because a17 already processed the
BLUE iSW HANGUP, and so a17 tore down that circuit?  That seems
plausible.

[152:

Mon Jun 22 05:04:39 2020 So that leads us back to a (different)
thinko: Why should we expect -- or even care -- about whether a
passive/active race is involving the same itc?

Well, we thought it had to be the same itc because we thought the only
way this issue comes up is if two aEW's, both in AWLOCKS, collide with
each other.  And we wanted to resolve that using the yoink values from
the associated RING packets.  And the RING packets are on a per-ITC
basis.  So if we can't match up the ITC, we can't find the matching
yoink val, and we can run the yoink protocol.

But a17 is not in AWLOCKS:

    (gdb) p ew.mStateNum
    $24 = MFM::EWSN_AWACKS
    (gdb)

It already got its locks, had its event, and shipped cache updates.
That means it can have retired circuits, and here we are.

So really, T2PassiveEventWindow::passiveWinsYoinkRace needs to respect
that case.  Instead of blowing up if its ITC can't be found, it really
needs to be checking if aew is in AWLOCKS _first_.  If not, then
there's really no yoink race to be had, and, I guess, the passive
start has to just lose to the existing active.

Now, where is passiveWinsYoinkRace actually called?  Do we maybe want
to get involved a little earlier?[153:

Mon Jun 22 05:13:38 2020 Yeah, maybe caller should check for AWLOCKS
and not even go to passiveWinsYoinkRace otherwise.

:153]

:152]

:151]

:150]


:149]

:148]
:147]
:146]

:145]
[154:

Mon Jun 22 05:56:43 2020 So, it's what we inferred -- but for the
record, here's the rest of the RED trace, picking up from :149: above:

 ..
    49.316 0/lDBG a17/AINIT OWNING (35,4)+4
    49.316 0/lDBG a17/AINIT RING NE abs(35,4) usrel(11,0) yoink=0
    49.318 0/iNE:OPEN >NE:RING#17(11,0)+4e +5
    49.318 0/a17-AINIT NE CS_BOUND -> CS_RUNG
    49.319 0/lDBG a17/AINIT RING NW abs(35,4) usrel(35,0) yoink=1
    49.325 0/iNW:OPEN >NW:RING#17(35,0)+4o +5
    49.325 0/a17-AINIT NW CS_BOUND -> CS_RUNG
    49.325 0/a17-AINIT -> AWLOCKS

a17 RINGs NE and NW

    49.326 0/iNE:OPEN <NE:ANSWER#17 +2
    49.326 0/lDBG ITC/NE:OPEN: Enter HAP
    49.326 0/a17-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    49.326 0/lDBG ITC/NE:OPEN a17/AWLOCKS HAP
    49.326 0/lDBG a17/AWLOCKS hACK ITC/NE:OPEN
    49.328 0/iNW:OPEN <NW:ANSWER#17 +2
    49.328 0/lDBG ITC/NW:OPEN: Enter HAP
    49.328 0/a17-AWLOCKS NW CS_RUNG -> CS_ANSWERED
    49.328 0/lDBG ITC/NW:OPEN a17/AWLOCKS HAP
    49.328 0/lDBG a17/AWLOCKS hACK ITC/NW:OPEN
    49.329 0/a17-AWLOCKS -> ABEHAVE

gets both locks and goes to behave

    49.329 0/lDBG a17/ABEHAVE (35,4)BEIN ngb 7 live 1
    49.329 0/a17-ABEHAVE -> ASCACHE
    49.329 0/lDBG SHIP#0 sn7 (36,3) tt 0xFFFF wt 0x0001
    49.329 0/lDBG SHIP#1 sn0 (35,4) tt 0x0001 wt 0xFFFF
    49.338 0/iNE:OPEN >NE:TALK#17 +29
    49.338 0/lDBG SHIP#0 sn7 (36,3) tt 0xFFFF wt 0x0001
    49.339 0/lDBG SHIP#1 sn0 (35,4) tt 0x0001 wt 0xFFFF
    49.341 0/iNW:OPEN >NW:TALK#17 +29

ships two cache updates

    49.341 0/a17-ASCACHE -> AWACKS
    49.460 0/iNE:OPEN <NE:HANGUP#17 +2
    49.461 0/lDBG ITC/NE:OPEN: Enter HUP
    49.461 0/a17-AWACKS NE CS_ANSWERED -> CS_UNUSED
    49.461 0/lDBG a17/AWACKS hHU ITC/NE:OPEN

gets the first HANGUP and tears down the NE circuit

    49.462 0/iNE:OPEN <NE:RING#10(12,3)+4o +5
    49.462 0/lDBG ITC/NE:OPEN: HRP abs(36,3) themrel(12,3) yoink=1

gets the ensuing RING from NE

    49.462 0/pNE10-PINIT -> PINIT
    49.462 0/pNE10-PINIT p@(36,3)+4
    49.462 0/pNE10-PINIT NE CS_BOUND -> CS_RUNG
    49.462 0/pNE10-PINIT -> PRESOLVE

gets to passiveWinsYoinkRace

    7340.636 0/t  Failed to top: src/T2EventWindow.cpp:243: NULL_POINTER [3]

And blows up.

    7342.789 0/t  Total events completed = 589553
    t2@beaglebone:~/MFM/src/drivers/mfmt2$

:154]
[155:

Mon Jun 22 06:32:26 2020 So, wow!  We had three of these beins going
at once across three tiles, for a fair amount of time before anything
blew up.  And it blew up just because trySendNAK is currently
de-implemented.  Can we work on that a little bit?  [156:

Mon Jun 22 07:03:27 2020 Well, re-implementing it doesn't seem too
hard, but do we have any clue how to handle it when it arrives?[157:

Mon Jun 22 07:04:37 2020 T2ITC::handleDropPacket is also
de-implemented.  Let's go there.

:157]

:156]

:155]
[158:

Mon Jun 22 07:39:03 2020 So now in T2ActiveEventWIndow::handleBusy.
The idea is we'll iterate over the circuits and decide what to do with
each one?  I guess we'll unbind each one, but first we check if it's
state CS_ANSWERED, and if it is, we'll send a DROP first?

I guess we put the matching circuit into CS_DECLINED.  For the other
circuit, if there is one:

 CS <= CS_BOUND, do nothing
 CS <= CS_ANSWERED, send DROP and go to CS_DROPPED

[159:

Mon Jun 22 13:50:19 2020 Well, apparently needed some sleep.

So, thinking a key to this may be having aEW go into some
as-yet-unnamed state where it just soaks up packets aimed at it, and
waits for a timeout, at which point it frees itself.

It's like, once again, the phone company, which (at least previously)
used to let phone numbers lay fallow for a while after customers gave
them up, to help minimize calls to new customers from people looking
for the old customer.

So if a blown-up aEW goes into state AFALLOW (or whatever) for a
while, then we can worry less about prior ANSWERs or BUSYs arriving
late and getting misinterpreted by a fresh-start use of this aEW now.

That would help justify us sending a DROP on the active side even if a
circuit is just RUNG rather than answered.  If aEW is going AFALLOW
after sending the DROP anyway, any subsequent ANSWER or BUSY arriving
from passive side(s) while 'fall on deaf ears' anyway.

So the idea is:

 - To abort an active EW, due to a BUSY, and possibly other
   conditions, we'll see:

 - First, send a DROP on all bound circuits, except for cases where we
   can be pretty sure it's unnecessary -- like when we're aborting
   BECAUSE of a BUSY on a particular bound circuit.

 - Then, unhog the sites, mark the aEW as not having sites (however we
   do that).

 - Then go to state AFALLOW, with a timeout of perhaps 100ms or so.
   This ties up the aEW and prevents it from being reallocated.

 - During AFALLOW, any ANSWER, BUSY, or HANGUP packets to it are
   silently ignored.

 - Upon timeout AFALLOW, the aEW is just returned to the free pool.
   Since it didn't have any sites anyway, nothing else need be done.
[160:

Mon Jun 22 14:24:05 2020 Instead of AFALLOW, would it be too too
stupid to call it AWHILE ??[161:

Mon Jun 22 14:25:47 2020 Actually, why can't we use the existing ADROP
for this?  The ADROP description is "finish NAKed event", which seems
pretty close.  Are we actually going into ADROP anywhere, so far?[162:

Mon Jun 22 14:31:04 2020 T2ActiveEventWindow::dropActiveEW puts us
into ADROP, after (deterministically) unhogging sites.  Timeout and
receive ADROP are both INCOMPLETE_CODE.

So that code seems to be implying that being in state ADROP *means*
we're an active window that has given up its sites...

[163:

Mon Jun 22 14:34:56 2020 Note we also have T2EventWindow::abortEW(),
which calls finalizeEW() and then puts it back on the tile's EW free
list.  And finalizeEW() just resets EW data members internally, as far
as I can tell.  In particular, it doesn't unhog sites.  If we were
REALLY REALLY sure than an in-use aEW would ALWAYS HAVE SITES except
when it was in ADROP, we could have finalizeEW unhog on non-ADROP
states?

Who is currently calling unhog?[164: Mon Jun 22 14:45:45 2020

 - T2ActiveEventWindow::commitAndReleaseActive calls unhog, before
   calling mTile.releaseActiveEW which, among other things, calls
   finalizeEW.

 - T2ActiveEventWindow::dropActiveEW calls unhog, before setting the
   state to ADROP.

 - T2PassiveEventWindow::commitPassiveEWAndHangUp calls unhog, before
   calling initializeEW and going to state PINIT.

So that's like (1) unhog on active success, (2) unhog on active
failure, and (3) unhog on passive success.

And obviously the missing case is unhog on passive failure, which
would happen, at least, when a DROP packet arrives.  A difference is
we don't think we need or want a passive fallow period, so there's no
need for the pEW to block after giving up its sites.

But I guess it would be sensible to have a dropPassiveEW() to call.

:164]

  :163]

:162]

:161]

:160]

:159]
:158]
[165:

Mon Jun 22 16:00:00 2020 Well, tearing out ALL the T2EW::receive
handlers, because we're really not using them and they are just
confusing me.  So now the 'CUSRC' XX arg is always 0 for
ALL_EW_STATES_MACRO.  Rebuilding to see where we are.

:165]
[166:

Mon Jun 22 16:37:00 2020 OK commiting some flails towards sending and
handling BUSY and DROP.

:166]
[167:

Mon Jun 22 20:08:21 2020 Making progress but really running out of
time here.  We have our first full-on genuine yoink race here, leading
to revealing another bug (which we think we just fixed).

Thinly annotated --

    73.568 0/a27-IDLE -> AINIT
    73.568 0/a27-AINIT a@(51,5)+4
    73.568 0/a27-AINIT ET CS_UNUSED -> CS_BOUND
    73.568 0/a27-AINIT NE CS_UNUSED -> CS_BOUND
    73.569 0/lDBG a27/AINIT sites available
    73.569 0/lDBG a27/AINIT OWNING (51,5)+4

0/a27 starts up in the NE corner, binding both ET and NE.

    73.569 0/lDBG a27/AINIT RING NE abs(51,5) usrel(27,1) yoink=0
    73.571 0/iNE:OPEN >NE:RING#27(27,1)+4e +5
    73.571 0/a27-AINIT NE CS_BOUND -> CS_RUNG
    73.571 0/a27-AINIT -> AWLOCKS

0/a27 rings NE and starts to wait.

    73.657         1/lDBG a02/ABEHAVE (23,24)BEIN ngb 7 live 1
    73.657         1/lDBG a02/ABEHAVE FREEING (23,24)+4
    73.657         1/a02-ABEHAVE -> IDLE
    73.657         1/a20-IDLE -> AINIT
    73.657         1/a20-AINIT a@(27,35)+4

A moment later, 1/a02 starts up an event way down in the south of 1/

    73.657         1/a20-AINIT SE CS_UNUSED -> CS_BOUND
    73.657         1/a20-AINIT SW CS_UNUSED -> CS_BOUND

Involving SE and SW

    73.658         1/lDBG a20/AINIT sites available
    73.658         1/lDBG a20/AINIT OWNING (27,35)+4
    73.658         1/lDBG a20/AINIT RING SW abs(27,35) usrel(27,3) yoink=0
    73.666         1/iSW:OPEN >SW:RING#20(27,3)+4e +5
    73.666         1/a20-AINIT SW CS_BOUND -> CS_RUNG
    73.666         1/a20-AINIT -> AWLOCKS

1/a02 rings SW and starts to wait.

    73.669 0/iNE:OPEN <NE:RING#20(27,3)+4e +5

0/iNE picks up the ring from 1/a20!

    73.669 0/lDBG ITC/NE:OPEN: HRP abs(51,3) themrel(27,3) yoink=0
    73.669 0/pNE20-PINIT -> PINIT
    73.669 0/pNE20-PINIT p@(51,3)+4
    73.669 0/pNE20-PINIT NE CS_BOUND -> CS_RUNG
    73.669 0/pNE20-PINIT -> PRESOLVE

It inits 0/pNE20 and goes to resolve races

    73.669 0/lDBG u a27/AWLOCKS (51,5); t p20NE/PRESOLVE (51,3): YOINK ITC/NE:OPEN(Fred) us0 them0 -> we win

A Race is Detected!

It's our 0/a27 vs their 1/a20 (represented by 0/pNE20)!

The Yoink Protocol is Activated!  Our 0/a27 wins!

    73.669 0/lDBG p20NE/PRESOLVE BUSYed by a27/AWLOCKS
    73.671         1/iSE:SHUT >iSE:SHUT?6686D6B3  +6
    73.671 0/iNE:OPEN >NE:BUSY#20 +2

So a BUSY (lock rejected) packet is sent back toward 1/a20

    73.671 0/pNE20-PRESOLVE -> IDLE
    73.671 0/lDBG Passive cn 20 released

And 0/pNE20 is freed.

    73.673 0/iNW:SHUT <iNW:SHUT?6686D6B3  +6
    73.673 0/iNW:SHUT -> DRAIN
    73.675 0/iNW:DRAIN >iNW:DRAIN +2
    73.680         1/iSE:SHUT <iSE:DRAIN +2
    73.680         1/iSE:SHUT -> DRAIN
    73.682         1/iSE:DRAIN >iSE:DRAIN +2
    73.685         1/iSW:OPEN <SW:RING#27(27,1)+4e +5
    73.685         1/lDBG ITC/SW:OPEN: HRP abs(27,37) themrel(27,1) yoink=0
    73.685         1/pSW27-PINIT -> PINIT

Meanwhile, 1/iSW picks up the ring from 0/a27, initting 1/pSW27 to
handle it locally.

    73.685         1/pSW27-PINIT p@(27,37)+4
    73.685         1/pSW27-PINIT SW CS_BOUND -> CS_RUNG
    73.685         1/pSW27-PINIT -> PRESOLVE
    73.685         1/lDBG u a20/AWLOCKS (27,35); t p27SW/PRESOLVE (27,37): YOINK ITC/SW:OPEN(Ginger) us0 them0 -> they win

And it detects the race too!

Now it's our 1/a20 vs their 0/a27 (our 1/pSW27)!

And the Yoink Protocol says that they win!

    73.685         1/a20-AWLOCKS -> ADROP

So we start to drop our own 1/a20

    73.688         1/iSW:OPEN >SW:ANSWER#27 +2
    73.688         1/pSW27-PRESOLVE SW CS_RUNG -> CS_ANSWERED

And we ANSWER to grant the lock to 0/a27

    73.690         1/iSW:OPEN <SW:BUSY#20 +2

Then the BUSY from 0/iNE arrives at 1/iSW for 1/a20

    73.690         1/lDBG ITC/SW:OPEN: Enter hBP
    73.690         1/lDBG a20/ADROP hBUSY ITC/SW:OPEN
    73.690         1/lDBG a20/ADROP Not AWLOCKS, ignoring BUSY

But 1/a20 is already yoinked to ADROP, so the BUSY is not news.

    73.770 0/iNW:DRAIN -> CACHEXG
    73.777 0/iNE:OPEN <NE:ANSWER#27 +2

And then the ANSWER arrives at 0/iNE for 0/a27

    73.777 0/lDBG ITC/NE:OPEN: Enter HAP
    73.777 0/a27-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    73.778 0/lDBG ITC/NE:OPEN a27/AWLOCKS HAP
    73.778 0/lDBG a27/AWLOCKS hANSWER ITC/NE:OPEN
    73.779 0/iNW:CACHEXG <iNW:DRAIN +2
    73.779 0/iNW:CACHEXG -> SHUT
    73.781 0/a27-AWLOCKS -> ABEHAVE
    73.781 0/lDBG a27/ABEHAVE (51,5)BEIN ngb 2 live 1

And 0/a27 moves on to behave.

    73.781 0/a27-ABEHAVE -> ASCACHE
    73.781 0/lDBG SHIP#0 sn2 (51,4) tt 0xFFFF wt 0x0001
    73.781 0/lDBG SHIP#1 sn0 (51,5) tt 0x0001 wt 0xFFFF
    73.788 0/iNE:OPEN >NE:TALK#27 +29
    73.788 0/a27-ASCACHE -> AWACKS

Ships the update, and settles down to wait for acks

    73.790 0/iNW:SHUT >iNW:SHUT?274D8A08  +6
    73.869         1/iSE:DRAIN -> SHUT
    73.878         1/iSW:OPEN <SW:TALK#27 +29
    73.878         1/lDBG ITC/SW:OPEN: Enter HCUP

And 1/pSW27 goes to handle it.  But that died because we forgot to
change 1/pSW27's state to EWSN_PCACHE when we shipped the answer.

    #0  MFMLongJmpHere (buffer=0xbefff6b0, toThrow=4) at src/FailPlatformSpecific.cpp:48
    48          longjmp(buffer,toThrow);
    (gdb) up
    #1  0x00463a28 in MFM::T2ITC::handleCacheUpdatesPacket (this=0x4dcde8 <MFM::T2Tile::get()::THE_INSTANCE+3280>,
        pb=...) at src/T2ITC.cpp:279
    279         MFM_API_ASSERT_STATE(passiveEW.getEWSN() == EWSN_PWCACHE);
    (gdb) p passiveEW.getEWSN()
    $12 = MFM::EWSN_PRESOLVE
    (gdb)

[168:

Mon Jun 22 20:53:33 2020 But we've now made a fix for that.
Committing and going again.

:168]

:167]
[169:

Tue Jun 23 03:15:23 2020 (Took a break to update the web site for our
501(c)(3) status.)  So now we're dying here:

    (gdb) up
    #1  0x004746c0 in MFM::T2PassiveEventWindow::handleDrop (this=0x5b06f8, itc=...) at src/T2EventWindow.cpp:292
    292	      FAIL(ILLEGAL_STATE);
    (gdb) l
    287	  }
    288
    289	  void T2PassiveEventWindow::handleDrop(T2ITC & itc) {
    290	    TLOG(DBG,"%s: handleDrop", getName());
    291	    if (getEWSN() <= EWSN_PINIT) { // What is best predicate here??
    292	      FAIL(ILLEGAL_STATE);
    293	    }

with the trace ending up like

    379.328 0/iNE:OPEN <NE:DROP#1 +2
    379.328 0/lDBG ITC/NE:OPEN: Enter hDP
    379.328 0/lDBG pNE01-PINIT: handleDrop
    t2@beaglebone:~/MFM/src/drivers/mfmt2$

and looking at the neighboring tile's trace:

    106.857 0/iSW:OPEN <SW:BUSY#1 +2

BUSY from SW

    106.857 0/lDBG ITC/SW:OPEN: Enter hBP
    106.857 0/lDBG a01-AWLOCKS hBUSY ITC/SW:OPEN
    106.859 0/iSW:OPEN >SW:DROP#1 +2

DROP back to SW??

    106.859 0/a01-AWLOCKS SE CS_ANSWERED -> CS_DROPPED
    106.859 0/a01-AWLOCKS -> ADROP

I suspect what happened is this second guy sent a DROP back in
response to the source of a BUSY, and it shouldn't do that, because
the passive guy reinits after it sends the BUSY..[170:

Tue Jun 23 03:51:38 2020 And yes that was my stupidity of course as
well:

    --- a/src/drivers/mfmt2/src/T2EventWindow.cpp
    +++ b/src/drivers/mfmt2/src/T2EventWindow.cpp
    @@ -146,7 +146,7 @@ namespace MFM {
             if (&thisITC != &itc) {
               TLOG(DBG,"%s sending drop thisITC %p vs itc %p",
                    getName(), &thisITC, &itc);
    -          trySendDropVia(itc);
    +          trySendDropVia(thisITC);
             }
             ci.setCS(CS_DROPPED);
           }

I VERY CAREFULLY CHECKED that itc I was considering (thisITC) was
different than the one the BUSY came in on.. and then I sent the DROP
to the one the BUSY came in on..  Smoove Dave smoove.

:170]

:169]
[171:

Wed Jun 24 04:06:14 2020 OK, so T2sday update #279 is out.

Aaand where were we, here?

[172:

Wed Jun 24 04:07:48 2020 Well, we blew up in T2ITC::handleRingPacket,
because the targeted passiveEW was in state PWCACHE instead of PINIT.

And we had not yet figured out how that happened.[173:

Wed Jun 24 11:22:14 2020 Let's try to capture another instance, just
on two tiles to keep things simpler..[174:

Wed Jun 24 11:29:09 2020 Didn't take long once started..

:174]

:173]

:172]

:171]
[175:

Wed Jun 24 22:10:50 2020 Well so after the evening break.

Here, I merged this files for this failure, which is another case
where an inbound ring packet goes a pEW -- in this case, 0/pNW30 --
that's in state EWSN_PWCACHE instead of EWSN_PINIT.  Question is: Why
is 0/pNW30 in that state?

So, this is using the same connectivity as the last few cases:

         ........ribbon.cable..
        .                      .
        .  +-----------+       .
        .  |     1/    |       .
        .  |   'BLUE'  |       .
        .  |SW       SE|       .
        .  +||-------||+       .
        .   .       +||-------||+
         ...        |NW       NE|
                    |   'RED'   |
                    |    0/     |
                    +-----------+


    t2@beaglebone:~/MFM/src/drivers/mfmt2$ ../../../bin/Weaver ~/FILEDIR/202006242212-RED-t2trace221.dat ~/FILEDIR/202006242212-BLUE-t2trace221.dat
    11: MSG: WP 0
    12: MSG: WM 0
    0/ /home/t2/FILEDIR/202006242212-RED-t2trace221.dat: Wed Jun 24 11:28:08 2020
    1/ /home/t2/FILEDIR/202006242212-BLUE-t2trace221.dat: Wed Jun 24 11:28:13 2020
    0/ -> 1/ n=44, s=-214.904093, ss=1049.631116, avg=-4.884184, var=23.855253
    1/ -> 0/ n=44, s=214.904093, ss=1049.631116, avg=4.884184, var=23.855253
    Anchor file is 0/
    TWEAKING n1 0.000000
    0/ 0ms
    1/ 4s 884ms
    0.000 0/t  Trace Format Version 5
 ..
    30.484         1/a31-IDLE -> AINIT

Well, I'm not sure if this is really where the whole megillah
'begins' (I've extended backwards from the scene of the failure a
couple of times now, trying to annotate this trace).  But let's find
out.

So 1/a31 starts up at (27,34), deep in SE+SW territory.  Note also
that ANOTHER player in our story -- 1/a30 -- is ALSO going to start up
at THE EXACT SAME SITE, (27,34), SOON!

    30.484         1/a31-AINIT a@(27,34)+4
    30.484         1/a31-AINIT SE CS_UNUSED -> CS_BOUND
    30.484         1/a31-AINIT SW CS_UNUSED -> CS_BOUND
    30.484         1/lDBG a31-AINIT sites available
    30.484         1/lDBG a31-AINIT OWNING (27,34)+4
    30.484         1/lDBG a31-AINIT RING SE abs(27,34) usrel(3,2) yoink=1

1/a31 gets ready to send a RING on SE.

    30.490 0/a18-IDLE -> AINIT
    30.491 0/a18-AINIT a@(31,12)+4
    30.491 0/lDBG a18-AINIT sites available
    30.491 0/lDBG a18-AINIT OWNING (31,12)+4
    30.491 0/a18-AINIT -> ABEHAVE
    30.492 0/a19-IDLE -> AINIT

0/a18 starts up, has a hidden event, and finishes, just like that.

    30.492 0/a19-AINIT a@(4,4)+4
    30.492 0/a19-AINIT WT CS_UNUSED -> CS_BOUND
    30.492 0/a19-AINIT NW CS_UNUSED -> CS_BOUND

0/a19 starts up in the absolute extreme far NE+NW.  Not sure if this
will be significant in the story or not.

    30.492         1/iSE:OPEN >SE:RING#31(3,2)+4o +5

The 1/a31 RING to SE actually ships.

    30.492         1/a31-AINIT SE CS_BOUND -> CS_RUNG
    30.492         1/lDBG a31-AINIT RING SW abs(27,34) usrel(27,2) yoink=0
    30.493 0/lDBG a19-AINIT sites available
    30.493 0/lDBG a19-AINIT OWNING (4,4)+4
    30.493 0/lDBG a19-AINIT RING NW abs(4,4) usrel(4,0) yoink=0

0/a19

    30.499         1/iSW:OPEN >SW:RING#31(27,2)+4e +5
    30.499         1/a31-AINIT SW CS_BOUND -> CS_RUNG
    30.499         1/a31-AINIT -> AWLOCKS
    30.501         1/iSE:OPEN <SE:RING#19(4,0)+4e +5
    30.501         1/lDBG ITC/SE:OPEN: HRP abs(28,36) themrel(4,0) yoink=0
    30.501         1/pSE19-PINIT -> PINIT
    30.501         1/pSE19-PINIT p@(28,36)+4
    30.501         1/pSE19-PINIT SE CS_BOUND -> CS_RUNG
    30.501         1/pSE19-PINIT -> PRESOLVE
    30.501         1/lDBG u a31-AWLOCKS (27,34); t pSE19-PRESOLVE (28,36): YOINK ITC/SE:OPEN(Fred) us1 them0 -> they win
    30.502         1/a31-AWLOCKS -> ADROP
    30.502         1/pSE19-PRESOLVE -> PWCACHE
    30.503 0/iNW:OPEN >NW:RING#19(4,0)+4e +5
    30.503 0/a19-AINIT NW CS_BOUND -> CS_RUNG
    30.503 0/a19-AINIT -> AWLOCKS
    30.504 0/lDBG a18-ABEHAVE (31,12)BEIN ngb 1 live 1
    30.504 0/lDBG a18-ABEHAVE FREEING (31,12)+4
    30.504 0/a18-ABEHAVE -> IDLE
    30.506 0/iNE:OPEN <NE:RING#31(27,2)+4e +5
    30.506 0/lDBG ITC/NE:OPEN: HRP abs(51,2) themrel(27,2) yoink=0
    30.507 0/pNE31-PINIT -> PINIT
    30.507 0/pNE31-PINIT p@(51,2)+4
    30.507 0/pNE31-PINIT NE CS_BOUND -> CS_RUNG
    30.507 0/pNE31-PINIT -> PRESOLVE
    30.507 0/pNE31-PRESOLVE -> PWCACHE
    30.508         1/iSE:OPEN >SE:ANSWER#19 +2
    30.508         1/pSE19-PWCACHE SE CS_RUNG -> CS_ANSWERED
    30.511         1/iSW:OPEN <SW:ANSWER#31 +2
    30.511         1/lDBG ITC/SW:OPEN: Enter HAP
    30.511         1/a31-ADROP SW CS_RUNG -> CS_ANSWERED
    30.511         1/lDBG ITC/SW:OPEN a31-ADROP HAP
    30.511         1/lWRN ITC/SW:OPEN HAP bad aew state a31-ADROP for cn 31
    30.512         1/a31-ADROP SE CS_RUNG -> CS_UNUSED
    30.512         1/a31-ADROP SW CS_ANSWERED -> CS_UNUSED
    30.512         1/a31-ADROP -> IDLE
    30.513         1/a31-IDLE -> AINIT
    30.513         1/a31-AINIT a@(51,25)+4
    30.513         1/a31-AINIT ET CS_UNUSED -> CS_BOUND
    30.515 0/iNE:OPEN >NE:ANSWER#31 +2
    30.515 0/pNE31-PWCACHE NE CS_RUNG -> CS_ANSWERED
    30.517         1/lDBG a31-AINIT sites available
    30.517         1/lDBG a31-AINIT OWNING (51,25)+4
    30.517         1/a31-AINIT -> ABEHAVE
    30.517 0/iNW:OPEN <NW:RING#31(3,2)+4o +5
    30.517 0/lDBG ITC/NW:OPEN: HRP abs(3,2) themrel(3,2) yoink=1
    30.517 0/pNW31-PINIT -> PINIT
    30.517 0/pNW31-PINIT p@(3,2)+4
    30.517 0/pNW31-PINIT NW CS_BOUND -> CS_RUNG
    30.517 0/pNW31-PINIT -> PRESOLVE
    30.518 0/lDBG u a19-AWLOCKS (4,4); t pNW31-PRESOLVE (3,2): YOINK ITC/NW:OPEN(Ginger) us0 them1 -> we win
    30.518 0/lDBG RRFP-2 pNW31-PRESOLVE BUSYed by a19-AWLOCKS
    30.520         1/iSE:OPEN <SE:BUSY#31 +2
    30.520         1/lDBG ITC/SE:OPEN: Enter hBP
    30.520 0/iNW:OPEN >NW:BUSY#31 +2
    30.520         1/lDBG a31-ABEHAVE hBUSY ITC/SE:OPEN
    30.520 0/pNW31-PRESOLVE -> PINIT
    30.520         1/lDBG a31-ABEHAVE Not AWLOCKS, ignoring BUSY
    30.520 0/lDBG Passive cn 31 released
    30.521         1/lDBG a31-ABEHAVE (51,25)BEIN ngb 4 live 0
    30.521         1/lDBG a31-ABEHAVE (51,25)BEIN oth 8 (othlive 0)
    30.521         1/lDBG a31-ABEHAVE FREEING (51,25)+4
    30.521         1/a31-ABEHAVE ET CS_BOUND -> CS_UNUSED
    30.521         1/a31-ABEHAVE -> IDLE
    30.522         1/a30-IDLE -> AINIT
    30.522         1/a30-AINIT a@(13,34)+4
    30.522         1/a30-AINIT SW CS_UNUSED -> CS_BOUND
    30.522         1/lDBG a30-AINIT sites available
    30.522         1/lDBG a30-AINIT OWNING (13,34)+4
    30.522         1/lDBG a30-AINIT RING SW abs(13,34) usrel(13,2) yoink=0
    30.525         1/iSW:OPEN >SW:RING#30(13,2)+4e +5
    30.525         1/a30-AINIT SW CS_BOUND -> CS_RUNG
    30.525         1/a30-AINIT -> AWLOCKS
    30.525 0/iNW:OPEN <NW:ANSWER#19 +2
    30.525 0/lDBG ITC/NW:OPEN: Enter HAP
    30.525 0/a19-AWLOCKS NW CS_RUNG -> CS_ANSWERED
    30.525 0/lDBG ITC/NW:OPEN a19-AWLOCKS HAP
    30.525 0/lDBG a19-AWLOCKS hANSWER ITC/NW:OPEN
    30.532 0/a19-AWLOCKS -> ABEHAVE
    30.534 0/iNE:OPEN <NE:RING#30(13,2)+4e +5
    30.534 0/lDBG ITC/NE:OPEN: HRP abs(37,2) themrel(13,2) yoink=0
    30.534 0/pNE30-PINIT -> PINIT
    30.534 0/pNE30-PINIT p@(37,2)+4
    30.534 0/pNE30-PINIT NE CS_BOUND -> CS_RUNG
    30.534 0/pNE30-PINIT -> PRESOLVE
    30.535 0/pNE30-PRESOLVE -> PWCACHE
    30.538 0/iNE:OPEN >NE:ANSWER#30 +2
    30.538 0/pNE30-PWCACHE NE CS_RUNG -> CS_ANSWERED
    30.538 0/lDBG a19-ABEHAVE (4,4)BEIN ngb 2 live 1
    30.538 0/a19-ABEHAVE -> ASCACHE
    30.687         1/iSW:OPEN <SW:ANSWER#30 +2
    30.687         1/lDBG ITC/SW:OPEN: Enter HAP
    30.687         1/a30-AWLOCKS SW CS_RUNG -> CS_ANSWERED
    30.687         1/lDBG ITC/SW:OPEN a30-AWLOCKS HAP
    30.687         1/lDBG a30-AWLOCKS hANSWER ITC/SW:OPEN
    30.687         1/a11-IDLE -> AINIT
    30.687         1/a11-AINIT a@(28,25)+4
    30.688         1/lDBG a11-AINIT sites available
    30.688         1/lDBG a11-AINIT OWNING (28,25)+4
    30.688         1/a11-AINIT -> ABEHAVE
    30.688         1/a30-AWLOCKS -> ABEHAVE
    30.688         1/lDBG a30-ABEHAVE (13,34)BEIN ngb 7 live 1
    30.688         1/a30-ABEHAVE -> ASCACHE
    30.691 0/lDBG SHIP#0 sn2 (4,3) tt 0xFFFF wt 0x0001
    30.691 0/lDBG SHIP#1 sn0 (4,4) tt 0x0001 wt 0xFFFF
    30.692         1/lDBG a11-ABEHAVE (28,25)BEIN ngb 2 live 1
    30.692         1/lDBG a11-ABEHAVE FREEING (28,25)+4
    30.692         1/a11-ABEHAVE -> IDLE
    30.692         1/lDBG SHIP#0 sn7 (14,33) tt 0xFFFF wt 0x0001
    30.692         1/lDBG SHIP#1 sn0 (13,34) tt 0x0001 wt 0xFFFF
    30.699         1/iSW:OPEN >SW:TALK#30 +29
    30.699         1/a30-ASCACHE -> AWACKS
    30.701 0/iNW:OPEN >NW:TALK#19 +29
    30.701 0/a19-ASCACHE -> AWACKS
    30.702         1/iSE:OPEN <SE:TALK#19 +29
    30.702         1/lDBG ITC/SE:OPEN: Enter HCUP
    30.702         1/pSE19-PWCACHE SE CS_ANSWERED -> CS_TALKED
    30.702         1/lDBG pSE19-PWCACHE CUPSN#2 mLastSN 40
    30.702         1/lDBG RECV#0 sn2 (28,35) tt 0xFFFF wt 0x0001
    30.702         1/lDBG pSE19-PWCACHE CUPSN#0 mLastSN 40
    30.702         1/lDBG RECV#1 sn0 (28,36) tt 0x0001 wt 0xFFFF
    30.702         1/lDBG pSE19-PWCACHE CUPSN#255 mLastSN 40
    30.702         1/lDBG pSE19-PWCACHE (C_TALKED(pSE19-PWCACHExITC/SE:OPEN)) cPEWAHU
    30.709         1/iSE:OPEN >SE:HANGUP#19 +2
    30.709         1/pSE19-PWCACHE -> PINIT
    30.709         1/lDBG pSE19-PINIT PASSIVE DONE
    30.715 0/iNE:OPEN <NE:TALK#30 +29
    30.715 0/lDBG ITC/NE:OPEN: Enter HCUP
    30.715 0/pNE30-PWCACHE NE CS_ANSWERED -> CS_TALKED
    30.715 0/lDBG pNE30-PWCACHE CUPSN#7 mLastSN 40
    30.715 0/lDBG RECV#0 sn7 (38,1) tt 0xFFFF wt 0x0001
    30.715 0/lDBG pNE30-PWCACHE CUPSN#0 mLastSN 40
    30.715 0/lDBG RECV#1 sn0 (37,2) tt 0x0001 wt 0xFFFF
    30.715 0/lDBG pNE30-PWCACHE CUPSN#255 mLastSN 40
    30.715 0/lDBG pNE30-PWCACHE (C_TALKED(pNE30-PWCACHExITC/NE:OPEN)) cPEWAHU
    30.721 0/iNE:OPEN >NE:HANGUP#30 +2
    30.722 0/pNE30-PWCACHE -> PINIT
    30.722 0/lDBG pNE30-PINIT PASSIVE DONE
    30.724 0/iNW:OPEN <NW:HANGUP#19 +2
    30.724 0/lDBG ITC/NW:OPEN: Enter HUP
    30.724 0/a19-AWACKS NW CS_ANSWERED -> CS_UNUSED
    30.724 0/lDBG a19-AWACKS hHU ITC/NW:OPEN
    30.724 0/a19-AWACKS WT CS_BOUND -> CS_UNUSED
    30.724 0/lDBG a19-AWACKS FREEING (4,4)+4
    30.724 0/a19-AWACKS -> IDLE
    30.886         1/a08-IDLE -> AINIT
    30.886         1/a08-AINIT a@(28,24)+4
    30.886         1/lDBG a08-AINIT sites available
    30.886         1/lDBG a08-AINIT OWNING (28,24)+4
    30.887         1/a08-AINIT -> ABEHAVE
    30.894         1/iSW:OPEN <SW:HANGUP#30 +2
    30.895         1/lDBG ITC/SW:OPEN: Enter HUP
    30.895         1/a30-AWACKS SW CS_ANSWERED -> CS_UNUSED
    30.895         1/lDBG a30-AWACKS hHU ITC/SW:OPEN
    30.895         1/lDBG a30-AWACKS FREEING (13,34)+4
    30.895         1/a30-AWACKS -> IDLE
    30.899 0/a10-IDLE -> AINIT
    30.899 0/a10-AINIT a@(30,12)+4
    30.899 0/lDBG a10-AINIT sites available
    30.899 0/lDBG a10-AINIT OWNING (30,12)+4
    30.900 0/a10-AINIT -> ABEHAVE
    30.910 0/lDBG a10-ABEHAVE (30,12)BEIN ngb 1 live 1
    30.910 0/lDBG a10-ABEHAVE FREEING (30,12)+4
    30.910 0/a10-ABEHAVE -> IDLE

    30.921 0/a15-IDLE -> AINIT
    30.921 0/a15-AINIT a@(4,5)+4

0/a15 starts up off in the NW+WT hinterlands.  WT is SHUT, but NW is
OPEN.

    30.921 0/a15-AINIT WT CS_UNUSED -> CS_BOUND
    30.921 0/a15-AINIT NW CS_UNUSED -> CS_BOUND
    30.922 0/lDBG a15-AINIT sites available
    30.922 0/lDBG a15-AINIT OWNING (4,5)+4
    30.922 0/lDBG a15-AINIT RING NW abs(4,5) usrel(4,1) yoink=1
    30.931 0/iNW:OPEN >NW:RING#15(4,1)+4o +5

0/a15 sends a RING on NW

    30.931 0/a15-AINIT NW CS_BOUND -> CS_RUNG
    30.931 0/a15-AINIT -> AWLOCKS

and awaits developments.

    30.940 0/a29-IDLE -> AINIT
    30.940 0/a29-AINIT a@(33,9)+4

0/a29 also starts up, in the central NE/NW region.  Needs two locks.

    30.940 0/a29-AINIT NE CS_UNUSED -> CS_BOUND
    30.940 0/a29-AINIT NW CS_UNUSED -> CS_BOUND
    30.940 0/lDBG a29-AINIT sites available
    30.940 0/lDBG a29-AINIT OWNING (33,9)+4
    30.940 0/lDBG a29-AINIT RING NE abs(33,9) usrel(9,5) yoink=0
    30.943 0/iNE:OPEN >NE:RING#29(9,5)+4e +5

0/a29 rings on NE

    30.943 0/a29-AINIT NE CS_BOUND -> CS_RUNG
    30.943 0/lDBG a29-AINIT RING NW abs(33,9) usrel(33,5) yoink=0
    30.951 0/iNW:OPEN >NW:RING#29(33,5)+4e +5

0/a29 rings on NW

    30.951 0/a29-AINIT NW CS_BOUND -> CS_RUNG
    30.951 0/a29-AINIT -> AWLOCKS

0/a29 sets down to wait

    30.951 0/a07-IDLE -> AINIT
    30.951 0/a07-AINIT a@(29,12)+4
    30.952 0/a07-AINIT -> IDLE

A few event attempts..

    30.984 0/a08-IDLE -> AINIT
    30.984 0/a08-AINIT a@(34,5)+4
    30.984 0/a08-AINIT NE CS_UNUSED -> CS_BOUND
    30.984 0/a08-AINIT NE CS_BOUND -> CS_UNUSED
    30.984 0/a08-AINIT -> IDLE

..fail to acquire..

    31.004 0/a00-IDLE -> AINIT
    31.004 0/a00-AINIT a@(29,12)+4
    31.004 0/a00-AINIT -> IDLE

..the sites they need..

    31.060 0/a11-IDLE -> AINIT
    31.060 0/a11-AINIT a@(29,12)+4
    31.061 0/a11-AINIT -> IDLE

..and end quickly.

    31.093         1/lDBG a08-ABEHAVE (28,24)BEIN ngb 2 live 1
    31.093         1/lDBG a08-ABEHAVE FREEING (28,24)+4
    31.094         1/a08-ABEHAVE -> IDLE

Over in 1/a08, a hidden event (that started way back at 30.886, in
part of the trace I clipped), finally gets a chance to finish up.

    31.094         1/a30-IDLE -> AINIT
    31.094         1/a30-AINIT a@(27,34)+4

1/a30 starts up deep in SW+SE territory

    31.094         1/a30-AINIT SE CS_UNUSED -> CS_BOUND
    31.094         1/a30-AINIT SW CS_UNUSED -> CS_BOUND
    31.095         1/lDBG a30-AINIT sites available
    31.095         1/lDBG a30-AINIT OWNING (27,34)+4
    31.095         1/lDBG a30-AINIT RING SE abs(27,34) usrel(3,2) yoink=1
    31.103         1/iSE:OPEN >SE:RING#30(3,2)+4o +5

1/a30 sends a RING on SE

    31.103         1/a30-AINIT SE CS_BOUND -> CS_RUNG
    31.103         1/lDBG a30-AINIT RING SW abs(27,34) usrel(27,2) yoink=0
    31.109         1/iSW:OPEN >SW:RING#30(27,2)+4e +5

and also on SW

    31.109         1/a30-AINIT SW CS_BOUND -> CS_RUNG
    31.109         1/a30-AINIT -> AWLOCKS

and then settles down to wait for developments.

    31.112         1/iSE:OPEN <SE:RING#15(4,1)+4o +5

Now, that ring from 0/a15, sent way back at 30.931, arrives at 1/iSE.

    31.112         1/lDBG ITC/SE:OPEN: HRP abs(28,37) themrel(4,1) yoink=1
    31.112         1/pSE15-PINIT -> PINIT
    31.112         1/pSE15-PINIT p@(28,37)+4

1/pSE15 sets up to handle it.

    31.112         1/pSE15-PINIT SE CS_BOUND -> CS_RUNG
    31.112         1/pSE15-PINIT -> PRESOLVE
    31.112         1/lDBG u a30-AWLOCKS (27,34); t pSE15-PRESOLVE (28,37): YOINK ITC/SE:OPEN(Fred) us1 them1 -> we win
    31.112         1/lDBG RRFP-2 pSE15-PRESOLVE BUSYed by a30-AWLOCKS

Ono a collision!  1/pSE15 at (28,37)+4 overlaps 1/a30 at (27,34)+4 !
And our active 1/a30 wins the yoink!  1/pSE15 is going to need to send
back a BUSY to 0/a15!  (But that hasn't happened yet.)

    31.115 0/iNE:OPEN <NE:RING#30(27,2)+4e +5
    31.115 0/lDBG ITC/NE:OPEN: HRP abs(51,2) themrel(27,2) yoink=0

Meanwhile, back on 0/iNE, the ring from 1/a30 has arrived

    31.115 0/pNE30-PINIT -> PINIT
    31.115 0/pNE30-PINIT p@(51,2)+4
    31.115 0/pNE30-PINIT NE CS_BOUND -> CS_RUNG

0/pNE30 sets up for it.

    31.115 0/pNE30-PINIT -> PRESOLVE
    31.116 0/lDBG RRFP-1 pNE30-PRESOLVE BUSYed by pNE31-PWCACHE



    31.116         1/iSE:OPEN >SE:BUSY#15 +2
    31.116         1/pSE15-PRESOLVE -> PINIT
    31.116         1/lDBG Passive cn 15 released
    31.122         1/iSE:OPEN <SE:RING#29(33,5)+4e +5
    31.122         1/lDBG ITC/SE:OPEN: HRP abs(57,41) themrel(33,5) yoink=0
    31.122         1/pSE29-PINIT -> PINIT
    31.122         1/pSE29-PINIT p@(57,41)+4
    31.122         1/pSE29-PINIT SE CS_BOUND -> CS_RUNG
    31.122         1/pSE29-PINIT -> PRESOLVE
    31.122         1/pSE29-PRESOLVE -> PWCACHE
    31.124         1/iSE:OPEN >SE:ANSWER#29 +2
    31.124         1/pSE29-PWCACHE SE CS_RUNG -> CS_ANSWERED
    31.125 0/iNE:OPEN >NE:BUSY#30 +2
    31.125 0/pNE30-PRESOLVE -> PINIT
    31.125 0/lDBG Passive cn 30 released
    31.127 0/iNW:OPEN <NW:RING#30(3,2)+4o +5
    31.127 0/lDBG ITC/NW:OPEN: HRP abs(3,2) themrel(3,2) yoink=1
    31.127 0/pNW30-PINIT -> PINIT
    31.127 0/pNW30-PINIT p@(3,2)+4
    31.127 0/pNW30-PINIT NW CS_BOUND -> CS_RUNG
    31.127 0/pNW30-PINIT -> PRESOLVE
    31.128 0/lDBG u a15-AWLOCKS (4,5); t pNW30-PRESOLVE (3,2): YOINK ITC/NW:OPEN(Ginger) us1 them1 -> they win
    31.128 0/a15-AWLOCKS -> ADROP
    31.128 0/pNW30-PRESOLVE -> PWCACHE
    31.129         1/iSW:OPEN <SW:RING#29(9,5)+4e +5
    31.129         1/lDBG ITC/SW:OPEN: HRP abs(9,41) themrel(9,5) yoink=0
    31.129         1/pSW29-PINIT -> PINIT
    31.129         1/pSW29-PINIT p@(9,41)+4
    31.129         1/pSW29-PINIT SW CS_BOUND -> CS_RUNG
    31.129         1/pSW29-PINIT -> PRESOLVE
    31.129         1/pSW29-PRESOLVE -> PWCACHE
    31.131 0/iNW:OPEN >NW:ANSWER#30 +2
    31.131 0/pNW30-PWCACHE NW CS_RUNG -> CS_ANSWERED
    31.132         1/iSW:OPEN >SW:ANSWER#29 +2
    31.132         1/pSW29-PWCACHE SW CS_RUNG -> CS_ANSWERED
    31.135         1/iSW:OPEN <SW:BUSY#30 +2
    31.135         1/lDBG ITC/SW:OPEN: Enter hBP
    31.135         1/lDBG a30-AWLOCKS hBUSY ITC/SW:OPEN
    31.135         1/a30-AWLOCKS -> ADROP
    31.138 0/iNW:OPEN <NW:BUSY#15 +2
    31.138 0/lDBG ITC/NW:OPEN: Enter hBP
    31.138 0/lDBG a15-ADROP hBUSY ITC/NW:OPEN
    31.138 0/lDBG a15-ADROP Not AWLOCKS, ignoring BUSY
    31.140 0/iNW:OPEN <NW:ANSWER#29 +2
    31.140 0/lDBG ITC/NW:OPEN: Enter HAP
    31.140 0/a29-AWLOCKS NW CS_RUNG -> CS_ANSWERED
    31.140 0/lDBG ITC/NW:OPEN a29-AWLOCKS HAP
    31.141 0/lDBG a29-AWLOCKS hANSWER ITC/NW:OPEN
    31.151 0/iNE:OPEN <NE:ANSWER#29 +2
    31.151 0/lDBG ITC/NE:OPEN: Enter HAP
    31.151 0/a29-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    31.151 0/lDBG ITC/NE:OPEN a29-AWLOCKS HAP
    31.151 0/lDBG a29-AWLOCKS hANSWER ITC/NE:OPEN
    31.151 0/a29-AWLOCKS -> ABEHAVE
    31.153 0/lDBG a29-ABEHAVE (33,9)BEIN ngb 1 live 1
    31.153 0/a29-ABEHAVE -> ASCACHE
    31.153 0/lDBG SHIP#0 sn1 (32,9) tt 0xFFFF wt 0x0001
    31.153 0/lDBG SHIP#1 sn0 (33,9) tt 0x0001 wt 0xFFFF
    31.156 0/iNE:OPEN >NE:TALK#29 +29
    31.156 0/lDBG SHIP#0 sn1 (32,9) tt 0xFFFF wt 0x0001
    31.156 0/lDBG SHIP#1 sn0 (33,9) tt 0x0001 wt 0xFFFF
    31.159 0/iNW:OPEN >NW:TALK#29 +29
    31.159 0/a29-ASCACHE -> AWACKS
    31.159 0/a10-IDLE -> AINIT
    31.159 0/a10-AINIT a@(29,12)+4
    31.160 0/a10-AINIT -> IDLE
    31.169 0/a05-IDLE -> AINIT
    31.169 0/a05-AINIT a@(34,5)+4
    31.169 0/a05-AINIT NE CS_UNUSED -> CS_BOUND
    31.169 0/a05-AINIT NE CS_BOUND -> CS_UNUSED
    31.169 0/a05-AINIT -> IDLE
    31.175 0/a10-IDLE -> AINIT
    31.176 0/a10-AINIT a@(34,5)+4
    31.176 0/a10-AINIT NE CS_UNUSED -> CS_BOUND
    31.176 0/a10-AINIT NE CS_BOUND -> CS_UNUSED
    31.176 0/a10-AINIT -> IDLE
    31.209 0/a21-IDLE -> AINIT
    31.209 0/a21-AINIT a@(34,5)+4
    31.209 0/a21-AINIT NE CS_UNUSED -> CS_BOUND
    31.209 0/a21-AINIT NE CS_BOUND -> CS_UNUSED
    31.210 0/a21-AINIT -> IDLE
    31.233 0/a11-IDLE -> AINIT
    31.233 0/a11-AINIT a@(29,12)+4
    31.233 0/a11-AINIT -> IDLE
    31.311         1/iSE:OPEN <SE:ANSWER#30 +2
    31.311         1/lDBG ITC/SE:OPEN: Enter HAP
    31.311         1/a30-ADROP SE CS_RUNG -> CS_ANSWERED
    31.311         1/lDBG ITC/SE:OPEN a30-ADROP HAP
    31.311         1/lWRN ITC/SE:OPEN HAP bad aew state a30-ADROP for cn 30
    31.314         1/a30-ADROP SE CS_ANSWERED -> CS_UNUSED
    31.314         1/a30-ADROP SW CS_RUNG -> CS_UNUSED
    31.314         1/a30-ADROP -> IDLE
    31.320 0/lDBG a15-ADROP fallow period ended, freeing
    31.320 0/a15-ADROP WT CS_BOUND -> CS_UNUSED
    31.320 0/a15-ADROP NW CS_RUNG -> CS_UNUSED
    31.320 0/a15-ADROP -> IDLE
    31.322         1/iSE:OPEN <SE:TALK#29 +29
    31.322         1/lDBG ITC/SE:OPEN: Enter HCUP
    31.322         1/pSE29-PWCACHE SE CS_ANSWERED -> CS_TALKED
    31.322         1/lDBG pSE29-PWCACHE CUPSN#1 mLastSN 40
    31.322         1/lWRN pSE29-PWCACHE sn1/(56,41) not accessible by ITC/SE:OPEN; ignored
    31.322         1/lDBG pSE29-PWCACHE CUPSN#0 mLastSN 40
    31.322         1/lWRN pSE29-PWCACHE sn0/(57,41) not accessible by ITC/SE:OPEN; ignored
    31.322         1/lDBG pSE29-PWCACHE CUPSN#255 mLastSN 40
    31.322         1/lDBG pSE29-PWCACHE (C_TALKED(pSE29-PWCACHExITC/SE:OPEN)) cPEWAHU
    31.325         1/iSE:OPEN >SE:HANGUP#29 +2
    31.325         1/pSE29-PWCACHE -> PINIT
    31.325         1/lDBG pSE29-PINIT PASSIVE DONE
    31.327         1/iSW:OPEN <SW:TALK#29 +29
    31.327         1/lDBG ITC/SW:OPEN: Enter HCUP
    31.327         1/pSW29-PWCACHE SW CS_ANSWERED -> CS_TALKED
    31.327         1/lDBG pSW29-PWCACHE CUPSN#1 mLastSN 40
    31.327         1/lWRN pSW29-PWCACHE sn1/(8,41) not accessible by ITC/SW:OPEN; ignored
    31.327         1/lDBG pSW29-PWCACHE CUPSN#0 mLastSN 40
    31.327         1/lWRN pSW29-PWCACHE sn0/(9,41) not accessible by ITC/SW:OPEN; ignored
    31.327         1/lDBG pSW29-PWCACHE CUPSN#255 mLastSN 40
    31.327         1/lDBG pSW29-PWCACHE (C_TALKED(pSW29-PWCACHExITC/SW:OPEN)) cPEWAHU
    31.331 0/iNW:OPEN <NW:HANGUP#29 +2
    31.331 0/lDBG ITC/NW:OPEN: Enter HUP
    31.331 0/a29-AWACKS NW CS_ANSWERED -> CS_UNUSED
    31.331 0/lDBG a29-AWACKS hHU ITC/NW:OPEN
    31.333         1/iSW:OPEN >SW:HANGUP#29 +2
    31.333         1/pSW29-PWCACHE -> PINIT
    31.333         1/lDBG pSW29-PINIT PASSIVE DONE
    31.339 0/iNE:OPEN <NE:HANGUP#29 +2
    31.339 0/lDBG ITC/NE:OPEN: Enter HUP
    31.339 0/a29-AWACKS NE CS_ANSWERED -> CS_UNUSED
    31.339 0/lDBG a29-AWACKS hHU ITC/NE:OPEN
    31.339 0/lDBG a29-AWACKS FREEING (33,9)+4
    31.340 0/a29-AWACKS -> IDLE
    31.353 0/a21-IDLE -> AINIT
    31.353 0/a21-AINIT a@(29,12)+4
    31.353 0/lDBG a21-AINIT sites available
    31.353 0/lDBG a21-AINIT OWNING (29,12)+4
    31.353 0/a21-AINIT -> ABEHAVE
    31.353 0/lDBG a21-ABEHAVE (29,12)BEIN ngb 1 live 1
    31.354 0/lDBG a21-ABEHAVE FREEING (29,12)+4
    31.354 0/a21-ABEHAVE -> IDLE
    31.373 0/a25-IDLE -> AINIT
    31.373 0/a25-AINIT a@(28,12)+4
    31.373 0/lDBG a25-AINIT sites available
    31.373 0/lDBG a25-AINIT OWNING (28,12)+4
    31.373 0/a25-AINIT -> ABEHAVE
    31.375 0/lDBG a25-ABEHAVE (28,12)BEIN ngb 1 live 1
    31.375 0/lDBG a25-ABEHAVE FREEING (28,12)+4
    31.375 0/a25-ABEHAVE -> IDLE
    31.384 0/a05-IDLE -> AINIT
    31.384 0/a05-AINIT a@(34,5)+4
    31.384 0/a05-AINIT NE CS_UNUSED -> CS_BOUND
    31.384 0/a05-AINIT NW CS_UNUSED -> CS_BOUND
    31.384 0/lDBG a05-AINIT sites available
    31.384 0/lDBG a05-AINIT OWNING (34,5)+4
    31.385 0/lDBG a05-AINIT RING NE abs(34,5) usrel(10,1) yoink=1
    31.387 0/iNE:OPEN >NE:RING#5(10,1)+4o +5
    31.387 0/a05-AINIT NE CS_BOUND -> CS_RUNG
    31.387 0/lDBG a05-AINIT RING NW abs(34,5) usrel(34,1) yoink=0
    31.390 0/iNW:OPEN >NW:RING#5(34,1)+4e +5
    31.390 0/a05-AINIT NW CS_BOUND -> CS_RUNG
    31.390 0/a05-AINIT -> AWLOCKS
    31.400 0/a23-IDLE -> AINIT
    31.400 0/a23-AINIT a@(27,12)+4
    31.401 0/lDBG a23-AINIT sites available
    31.401 0/lDBG a23-AINIT OWNING (27,12)+4
    31.401 0/a23-AINIT -> ABEHAVE
    31.401 0/lDBG a23-ABEHAVE (27,12)BEIN ngb 1 live 1
    31.401 0/lDBG a23-ABEHAVE FREEING (27,12)+4
    31.401 0/a23-ABEHAVE -> IDLE
    31.510         1/a16-IDLE -> AINIT
    31.511         1/a16-AINIT a@(27,34)+4
    31.511         1/a16-AINIT SE CS_UNUSED -> CS_BOUND
    31.511         1/a16-AINIT SW CS_UNUSED -> CS_BOUND
    31.511         1/lDBG a16-AINIT sites available
    31.511         1/lDBG a16-AINIT OWNING (27,34)+4
    31.511         1/lDBG a16-AINIT RING SE abs(27,34) usrel(3,2) yoink=1
    31.519         1/iSE:OPEN >SE:RING#16(3,2)+4o +5
    31.519         1/a16-AINIT SE CS_BOUND -> CS_RUNG
    31.519         1/lDBG a16-AINIT RING SW abs(27,34) usrel(27,2) yoink=1
    31.529         1/iSW:OPEN >SW:RING#16(27,2)+4o +5
    31.529         1/a16-AINIT SW CS_BOUND -> CS_RUNG
    31.529         1/a16-AINIT -> AWLOCKS
    31.532         1/iSE:OPEN <SE:RING#5(34,1)+4e +5
    31.532         1/lDBG ITC/SE:OPEN: HRP abs(58,37) themrel(34,1) yoink=0
    31.532         1/pSE05-PINIT -> PINIT
    31.532         1/pSE05-PINIT p@(58,37)+4
    31.532         1/pSE05-PINIT SE CS_BOUND -> CS_RUNG
    31.532         1/pSE05-PINIT -> PRESOLVE
    31.532         1/pSE05-PRESOLVE -> PWCACHE
    31.535         1/iSE:OPEN >SE:ANSWER#5 +2
    31.535         1/pSE05-PWCACHE SE CS_RUNG -> CS_ANSWERED
    31.535 0/iNE:OPEN <NE:RING#16(27,2)+4o +5
    31.535 0/lDBG ITC/NE:OPEN: HRP abs(51,2) themrel(27,2) yoink=1
    31.535 0/pNE16-PINIT -> PINIT
    31.535 0/pNE16-PINIT p@(51,2)+4
    31.535 0/pNE16-PINIT NE CS_BOUND -> CS_RUNG
    31.535 0/pNE16-PINIT -> PRESOLVE
    31.536 0/lDBG RRFP-1 pNE16-PRESOLVE BUSYed by pNE31-PWCACHE
    31.537         1/iSW:OPEN <SW:RING#5(10,1)+4o +5
    31.537         1/lDBG ITC/SW:OPEN: HRP abs(10,37) themrel(10,1) yoink=1
    31.537         1/pSW05-PINIT -> PINIT
    31.537         1/pSW05-PINIT p@(10,37)+4
    31.537         1/pSW05-PINIT SW CS_BOUND -> CS_RUNG
    31.537         1/pSW05-PINIT -> PRESOLVE
    31.537         1/pSW05-PRESOLVE -> PWCACHE
    31.542         1/iSW:OPEN >SW:ANSWER#5 +2
    31.542         1/pSW05-PWCACHE SW CS_RUNG -> CS_ANSWERED
    31.544         1/iSW:OPEN <SW:BUSY#16 +2
    31.545         1/lDBG ITC/SW:OPEN: Enter hBP
    31.545         1/lDBG a16-AWLOCKS hBUSY ITC/SW:OPEN
    31.545         1/a16-AWLOCKS -> ADROP
    31.545 0/iNE:OPEN >NE:BUSY#16 +2
    31.545 0/pNE16-PRESOLVE -> PINIT
    31.545 0/lDBG Passive cn 16 released
    31.547 0/iNE:OPEN <NE:ANSWER#5 +2
    31.547 0/lDBG ITC/NE:OPEN: Enter HAP
    31.547 0/a05-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    31.547 0/lDBG ITC/NE:OPEN a05-AWLOCKS HAP
    31.547 0/lDBG a05-AWLOCKS hANSWER ITC/NE:OPEN
    31.549 0/iNW:OPEN <NW:RING#16(3,2)+4o +5
    31.549 0/lDBG ITC/NW:OPEN: HRP abs(3,2) themrel(3,2) yoink=1
    31.550 0/pNW16-PINIT -> PINIT
    31.550 0/pNW16-PINIT p@(3,2)+4
    31.550 0/pNW16-PINIT NW CS_BOUND -> CS_RUNG
    31.550 0/pNW16-PINIT -> PRESOLVE
    31.550 0/lDBG RRFP-1 pNW16-PRESOLVE BUSYed by pNW30-PWCACHE
    31.557 0/iNW:OPEN >NW:BUSY#16 +2
    31.557 0/pNW16-PRESOLVE -> PINIT
    31.557 0/lDBG Passive cn 16 released
    31.559 0/iNW:OPEN <NW:ANSWER#5 +2
    31.559 0/lDBG ITC/NW:OPEN: Enter HAP
    31.559 0/a05-AWLOCKS NW CS_RUNG -> CS_ANSWERED
    31.559 0/lDBG ITC/NW:OPEN a05-AWLOCKS HAP
    31.560 0/lDBG a05-AWLOCKS hANSWER ITC/NW:OPEN
    31.562 0/a05-AWLOCKS -> ABEHAVE
    31.562 0/lDBG a05-ABEHAVE (34,5)BEIN ngb 7 live 1
    31.562 0/a05-ABEHAVE -> ASCACHE
    31.562 0/lDBG SHIP#0 sn7 (35,4) tt 0xFFFF wt 0x0001
    31.562 0/lDBG SHIP#1 sn0 (34,5) tt 0x0001 wt 0xFFFF
    31.568 0/iNE:OPEN >NE:TALK#5 +29
    31.568 0/lDBG SHIP#0 sn7 (35,4) tt 0xFFFF wt 0x0001
    31.568 0/lDBG SHIP#1 sn0 (34,5) tt 0x0001 wt 0xFFFF
    31.574 0/iNW:OPEN >NW:TALK#5 +29
    31.574 0/a05-ASCACHE -> AWACKS
    31.731         1/iSE:OPEN <SE:BUSY#16 +2
    31.731         1/lDBG ITC/SE:OPEN: Enter hBP
    31.731         1/lDBG a16-ADROP hBUSY ITC/SE:OPEN
    31.731         1/lDBG a16-ADROP Not AWLOCKS, ignoring BUSY
    31.735 0/a09-IDLE -> AINIT
    31.735 0/a09-AINIT a@(32,9)+4
    31.735 0/a09-AINIT -> IDLE
    31.737         1/iSE:OPEN <SE:TALK#5 +29
    31.737         1/lDBG ITC/SE:OPEN: Enter HCUP
    31.737         1/pSE05-PWCACHE SE CS_ANSWERED -> CS_TALKED
    31.737         1/lDBG pSE05-PWCACHE CUPSN#7 mLastSN 40
    31.737         1/lWRN pSE05-PWCACHE sn7/(59,36) not accessible by ITC/SE:OPEN; ignored
    31.737         1/lDBG pSE05-PWCACHE CUPSN#0 mLastSN 40
    31.737         1/lWRN pSE05-PWCACHE sn0/(58,37) not accessible by ITC/SE:OPEN; ignored
    31.738         1/lDBG pSE05-PWCACHE CUPSN#255 mLastSN 40
    31.738         1/lDBG pSE05-PWCACHE (C_TALKED(pSE05-PWCACHExITC/SE:OPEN)) cPEWAHU
    31.740         1/iSE:OPEN >SE:HANGUP#5 +2
    31.741         1/pSE05-PWCACHE -> PINIT
    31.741         1/lDBG pSE05-PINIT PASSIVE DONE
    31.749         1/iSW:OPEN <SW:TALK#5 +29
    31.749         1/lDBG ITC/SW:OPEN: Enter HCUP
    31.749         1/pSW05-PWCACHE SW CS_ANSWERED -> CS_TALKED
    31.749         1/lDBG pSW05-PWCACHE CUPSN#7 mLastSN 40
    31.749         1/lDBG RECV#0 sn7 (11,36) tt 0xFFFF wt 0x0001
    31.749         1/lDBG pSW05-PWCACHE CUPSN#0 mLastSN 40
    31.749         1/lDBG RECV#1 sn0 (10,37) tt 0x0001 wt 0xFFFF
    31.749         1/lDBG pSW05-PWCACHE CUPSN#255 mLastSN 40
    31.749         1/lDBG pSW05-PWCACHE (C_TALKED(pSW05-PWCACHExITC/SW:OPEN)) cPEWAHU
    31.751         1/iSW:OPEN >SW:HANGUP#5 +2
    31.752         1/pSW05-PWCACHE -> PINIT
    31.752         1/lDBG pSW05-PINIT PASSIVE DONE
    31.752         1/lDBG a16-ADROP fallow period ended, freeing
    31.752         1/a16-ADROP SE CS_RUNG -> CS_UNUSED
    31.752         1/a16-ADROP SW CS_RUNG -> CS_UNUSED
    31.752         1/a16-ADROP -> IDLE
    31.759 0/iNW:OPEN <NW:HANGUP#5 +2
    31.759 0/lDBG ITC/NW:OPEN: Enter HUP
    31.759 0/a05-AWACKS NW CS_ANSWERED -> CS_UNUSED
    31.759 0/lDBG a05-AWACKS hHU ITC/NW:OPEN
    31.766 0/iNE:OPEN <NE:HANGUP#5 +2
    31.766 0/lDBG ITC/NE:OPEN: Enter HUP
    31.766 0/a05-AWACKS NE CS_ANSWERED -> CS_UNUSED
    31.766 0/lDBG a05-AWACKS hHU ITC/NE:OPEN
    31.766 0/lDBG a05-AWACKS FREEING (34,5)+4
    31.767 0/a05-AWACKS -> IDLE
    31.768 0/a14-IDLE -> AINIT
    31.768 0/a14-AINIT a@(32,9)+4
    31.768 0/a14-AINIT NE CS_UNUSED -> CS_BOUND
    31.768 0/a14-AINIT NW CS_UNUSED -> CS_BOUND
    31.769 0/lDBG a14-AINIT sites available
    31.769 0/lDBG a14-AINIT OWNING (32,9)+4
    31.769 0/lDBG a14-AINIT RING NE abs(32,9) usrel(8,5) yoink=1
    31.774 0/iNE:OPEN >NE:RING#14(8,5)+4o +5
    31.774 0/a14-AINIT NE CS_BOUND -> CS_RUNG
    31.774 0/lDBG a14-AINIT RING NW abs(32,9) usrel(32,5) yoink=1
    31.782 0/iNW:OPEN >NW:RING#14(32,5)+4o +5
    31.782 0/a14-AINIT NW CS_BOUND -> CS_RUNG
    31.782 0/a14-AINIT -> AWLOCKS
    31.791 0/a11-IDLE -> AINIT
    31.791 0/a11-AINIT a@(26,12)+4
    31.791 0/lDBG a11-AINIT sites available
    31.791 0/lDBG a11-AINIT OWNING (26,12)+4
    31.791 0/a11-AINIT -> ABEHAVE
    31.793 0/lDBG a11-ABEHAVE (26,12)BEIN ngb 1 live 1
    31.793 0/lDBG a11-ABEHAVE FREEING (26,12)+4
    31.793 0/a11-ABEHAVE -> IDLE
    31.807 0/a07-IDLE -> AINIT
    31.807 0/a07-AINIT a@(35,4)+4
    31.807 0/a07-AINIT NE CS_UNUSED -> CS_BOUND
    31.807 0/a07-AINIT NE CS_BOUND -> CS_UNUSED
    31.807 0/a07-AINIT -> IDLE
    31.900 0/a01-IDLE -> AINIT
    31.901 0/a01-AINIT a@(35,4)+4
    31.901 0/a01-AINIT NE CS_UNUSED -> CS_BOUND
    31.901 0/a01-AINIT NE CS_BOUND -> CS_UNUSED
    31.901 0/a01-AINIT -> IDLE
    31.903 0/a08-IDLE -> AINIT
    31.903 0/a08-AINIT a@(35,4)+4
    31.903 0/a08-AINIT NE CS_UNUSED -> CS_BOUND
    31.903 0/a08-AINIT NE CS_BOUND -> CS_UNUSED
    31.903 0/a08-AINIT -> IDLE
    31.927         1/a30-IDLE -> AINIT
    31.927         1/a30-AINIT a@(28,35)+4
    31.927         1/a30-AINIT SE CS_UNUSED -> CS_BOUND
    31.927         1/a30-AINIT SW CS_UNUSED -> CS_BOUND
    31.927         1/lDBG a30-AINIT sites available
    31.927         1/lDBG a30-AINIT OWNING (28,35)+4
    31.927         1/lDBG a30-AINIT RING SE abs(28,35) usrel(4,3) yoink=0
    31.935         1/iSE:OPEN >SE:RING#30(4,3)+4e +5
    31.935         1/a30-AINIT SE CS_BOUND -> CS_RUNG
    31.935         1/lDBG a30-AINIT RING SW abs(28,35) usrel(28,3) yoink=0
    31.945         1/iSW:OPEN >SW:RING#30(28,3)+4e +5
    31.945         1/a30-AINIT SW CS_BOUND -> CS_RUNG
    31.945         1/a30-AINIT -> AWLOCKS
    31.947         1/iSE:OPEN <SE:RING#14(32,5)+4o +5
    31.947         1/lDBG ITC/SE:OPEN: HRP abs(56,41) themrel(32,5) yoink=1
    31.947         1/pSE14-PINIT -> PINIT
    31.947         1/pSE14-PINIT p@(56,41)+4
    31.947         1/pSE14-PINIT SE CS_BOUND -> CS_RUNG
    31.947         1/pSE14-PINIT -> PRESOLVE
    31.947         1/pSE14-PRESOLVE -> PWCACHE
    31.950         1/iSE:OPEN >SE:ANSWER#14 +2
    31.950         1/pSE14-PWCACHE SE CS_RUNG -> CS_ANSWERED
    31.952         1/iSW:OPEN <SW:RING#14(8,5)+4o +5
    31.952         1/lDBG ITC/SW:OPEN: HRP abs(8,41) themrel(8,5) yoink=1
    31.952         1/pSW14-PINIT -> PINIT
    31.952         1/pSW14-PINIT p@(8,41)+4
    31.952         1/pSW14-PINIT SW CS_BOUND -> CS_RUNG
    31.952         1/pSW14-PINIT -> PRESOLVE
    31.952         1/pSW14-PRESOLVE -> PWCACHE
    31.954 0/iNE:OPEN <NE:RING#30(28,3)+4e +5
    31.955 0/lDBG ITC/NE:OPEN: HRP abs(52,3) themrel(28,3) yoink=0
    31.955 0/pNE30-PINIT -> PINIT
    31.955 0/pNE30-PINIT p@(52,3)+4
    31.955 0/pNE30-PINIT NE CS_BOUND -> CS_RUNG
    31.955 0/pNE30-PINIT -> PRESOLVE
    31.955 0/lDBG RRFP-1 pNE30-PRESOLVE BUSYed by pNE31-PWCACHE
    31.958         1/iSW:OPEN >SW:ANSWER#14 +2
    31.958         1/pSW14-PWCACHE SW CS_RUNG -> CS_ANSWERED
    31.960         1/iSW:OPEN <SW:BUSY#30 +2
    31.960         1/lDBG ITC/SW:OPEN: Enter hBP
    31.960         1/lDBG a30-AWLOCKS hBUSY ITC/SW:OPEN
    31.960         1/a30-AWLOCKS -> ADROP
    31.961 0/iNE:OPEN >NE:BUSY#30 +2
    31.961 0/pNE30-PRESOLVE -> PINIT
    31.961 0/lDBG Passive cn 30 released
    31.963 0/iNE:OPEN <NE:ANSWER#14 +2
    31.963 0/lDBG ITC/NE:OPEN: Enter HAP
    31.963 0/a14-AWLOCKS NE CS_RUNG -> CS_ANSWERED
    31.963 0/lDBG ITC/NE:OPEN a14-AWLOCKS HAP
    31.963 0/lDBG a14-AWLOCKS hANSWER ITC/NE:OPEN
    31.973 0/iNW:OPEN <NW:RING#30(4,3)+4e +5
    31.973 0/lDBG ITC/NW:OPEN: HRP abs(4,3) themrel(4,3) yoink=0
    32.143         1/iNE:SHUT >iNE:SHUT?2EEE4739  +6
    32.143         1/lDBG a30-ADROP fallow period ended, freeing
    32.144         1/a30-ADROP SE CS_RUNG -> CS_UNUSED
    32.144         1/a30-ADROP SW CS_RUNG -> CS_UNUSED
    32.144         1/a30-ADROP -> IDLE
    32.343         1/a08-IDLE -> AINIT
    32.343         1/a08-AINIT a@(28,23)+4
    32.343         1/lDBG a08-AINIT sites available
    32.343         1/lDBG a08-AINIT OWNING (28,23)+4
    32.343         1/a08-AINIT -> ABEHAVE
    32.375         1/lDBG a08-ABEHAVE (28,23)BEIN ngb 2 live 1
    32.375         1/lDBG a08-ABEHAVE FREEING (28,23)+4
    32.375         1/a08-ABEHAVE -> IDLE
    32.387         1/a21-IDLE -> AINIT
    32.387         1/a21-AINIT a@(28,22)+4
    32.388         1/lDBG a21-AINIT sites available
    32.388         1/lDBG a21-AINIT OWNING (28,22)+4
    32.388         1/a21-AINIT -> ABEHAVE
    32.395         1/iSE:OPEN >iSE:OPEN?759BAB81  +6
    32.395         1/a25-IDLE -> AINIT
    32.395         1/a25-AINIT a@(14,33)+4
    32.395         1/a25-AINIT SW CS_UNUSED -> CS_BOUND
    32.395         1/lDBG a25-AINIT sites available
    32.395         1/lDBG a25-AINIT OWNING (14,33)+4
    32.396         1/lDBG a25-AINIT RING SW abs(14,33) usrel(14,1) yoink=1
    32.401         1/iSW:OPEN >SW:RING#25(14,1)+4o +5
    32.401         1/a25-AINIT SW CS_BOUND -> CS_RUNG
    32.401         1/a25-AINIT -> AWLOCKS
 ..

:175]
[176:

Thu Jun 25 00:27:45 2020 You know, working through this -- and I'm
still not done -- I realize that what I'd REALLY like is to have
Weaver NOT JUST interleave the traces BUT ALSO track the current
status of each referenced EW.  I guess it would probably have to be a
curses program or something, so you could step forward and backward
through the merged traces, and on the other side of the screen you'd
have a dump of all the active windows that Weaver knows about as of
that trace record.

Because it seems an awful lot of what I'm doing here, as I struggle to
annotate the traces, is figure out what EWs are alive and what state
they're all in.  And Weaver could absolutely track that.

HMMMMMMM.

:176]
[177:

Thu Jun 25 06:11:22 2020 So I guess maybe the idea would be that when
we load the trace files, we could implicitly or explicitly number all
the trace record in their merged order...  and maybe build a vector
from those numbers to filenum+filepos for where to find that record?

I'm trying to think of a way to allow a curses based file viewer to
scroll back and forward, showing a segment of the merged record plus
a event window status map (and maybe circuit and/or itc status as
well), that's always in sync with the cursor position in the trace
window.

Let's try building that merged map.[178:

Thu Jun 25 09:06:20 2020 OK so we now have FileTrace, which wraps a
regular trace plus a WLFNumAndFilePos, which is a pair holding a file
number and ftell()-ish file position.

Now let's build a merged vector of WLFNumAndFilePos for every trace in
every file.. [179:

Thu Jun 25 09:27:05 2020 OK, I think we have that.  Now I think we
need a data structure to represent all our various ews, recording for
each:

 - Tile number

 - Active or passive mdir6

 - slotnum

as their fixed data, plus

 - statenum

 - center

 - radius

as their modifiable data.

I'm thinking we just immediately centralize all these inside the
Alignment, in a map or something, rather than trying to burst them out
to the WLF's or something.  How are we going to want to iterate them,
though?  Let's pretend just by filenum, then actives, then passives by
..  Actually maybe we want to align filenum on column and slotnum on
the row, then like active vs passive on left-right in column or
something?  It would be helpful to see passive EWs spatially connected
to their active counterparts somehow.

           +-----------------------------------------------------------+
           |   0/            1/            2/        ^0/tracerec       |
           | a00-AWLOCKS                             |0/tracerec       |
           |               pNE00-PWCACHE             |  1/tracerec     |
           |                                         |  1/tracerec     |
           |                                         |0/tracerec       |
           |                                         |    2/tracerec   |
           |               a10-AWACKS                |    2/tracerec   |
           | pSW10-PWCACHE                           >  1/tracerec     |
           |                                         |0/tracerec       |
           |                                         |0/tracerec       |
           |                                         |  1/tracerec     |
           |                                         |  1/tracerec     |
           |                                         |0/tracerec       |
           |                                         |    2/tracerec   |
           |                                         v    2/tracerec   |
           +-----------------------------------------------------------+

or something like that.  Maybe collapse out rows where nobody has EWs
going.

[180:

Thu Jun 25 10:03:26 2020 So what's the data structure?

slotnum -> wlfnum -> <p0..p5,a>

and the point is it's going to be completed built out at all times,
and we'll scan it to decide what needs to be displayed

:180]

:179]

:178]

:177]
[181:

Thu Jun 25 11:06:39 2020 OK, well we have a cut at 'EWSlotMap', and
Alignment is allocating and deallocating one based on the number of
files, but we're not doing anything else with it.

I think the next stop is to start getting a curses framework set up
for Weaver, to be activated if we see the '-c' arg on the command line
or something, so we'll have a place to start displaying the info that
we'll get the EWSlotMap to contain.  We're heading for a bidirectional
iterator over the mTraceLoc..[182:

Thu Jun 25 14:46:15 2020 Had to break for a meeting and then a nap,
and now another meeting coming up, and then it's time to move the
flag!  So continuing probably in the overnight.

:182]

:181]
[183:

Thu Jun 25 17:21:32 2020 WIP commit.

:183]
[184:

Thu Jun 25 23:48:40 2020 OK back.  curses framework; I can't be
starting from scratch on this, right?  I checked that tile-level
simulator I did, though, and that's perl..  So assuming I'm staying
with C++ for Weaver, WHICH I AM..[185:

Fri Jun 26 01:35:53 2020 OK so we have curses starting and stopping
under the -i command line flag.  I think we need some windows design
before we get too much farther.

 - Rolling trace display

 - The map

 - File info?  Tweak info?  etc?

[186:

Fri Jun 26 01:55:49 2020 Well now I'm wondering about trying this
'panel' library that
http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/panels.html#PANELBROWSING
shows examples of, which I tried on the tile and they seem to work.

Let's try it.  So, panels:

 - Rolling trace display

 - The EWMap - which still needs to be designed

 - Misc info, controls, whatever.

:186]


:185]

:184]
[187:

Fri Jun 26 04:50:03 2020 Well, that took... three hours? gah... but
now we have a 'panels'-library-based framework for EWMap, Trace, and
Info windows getting drawn on a terminal window.  Nothing in the
windows mind you, but there's labeled boxes:

EWMapTrace
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
Info
                                                                              
                                                                              


Right now the Info window is stepping on the others because I've been
imagining it's going to pop-down or something..
[188:

Fri Jun 26 04:55:09 2020 So, let's have some

TODO

 - Window resize: Have panels proportion themselves to the screen size
   and resize on WINCH

[194: Sat Jun 27 01:36:40 2020
EON :194] - TAB to cycle through the windows; top window interprets misc
   keystrokes

[189: Fri Jun 26 05:44:57 2020 First try for Trace
DONE :189] - Subclass IWPanelData for per-panel data?  Like Trace top record and
   active record?

[190: Fri Jun 26 07:19:11 2020
DONE - Display trace records in the trace window

[193: Sat Jun 27 01:36:27 2020
DONE :193] - Respond to arrow, page, and home/end keys to scroll the Trace
   window

 - Nail the active row to the middle of the trace window?  Need to
   handle negative rows then..  One of mTopRecord/mActiveRow becomes
   redundant. 

:190]
:188]
:187]
[191:

Sat Jun 27 01:31:01 2020 OK, so I think we're updating the EWModel's
in the forward direction.  Let's flesh on the backward direction and
then start thinking about some kind of first cut EWMap display.[192:

Sat Jun 27 01:35:56 2020 OK well that wasn't too bad.  ..Have some
To-Do To DONE Too.

:192]

:191]
[195:

Sat Jun 27 01:46:44 2020 OK, so, how are we going to display the
'relevant' EWs?

I was thinking slotnum going down rows, skipping unused slotnums.
Which we should probably just try, to get going, but I can see lots of
problems with it..

And across the columns, what?

Or, how about this: Just strip out in reading order with slotnum
slowest then filenum then index?  Have a fixed chunk of space for each
one, so they won't jump around horizontally on state changes, although
the whole thing with re-layout when a short-lived hidden event pops in
or out.  Hmm and option not to display hidden events could be quite
useful for stabilizing that display, but sometimes you're going to
want them.. 

[196:

Sat Jun 27 02:04:15 2020 OK, so how many columns per EWModel?  Worst
state name is 'PRESOLVE' at 8 + like '1/pNE00-' for another 8, so 16
worst case?  Perhaps try going with 16?[197:

Sat Jun 27 04:34:56 2020 Well it's starting to work, and like I was
worried about it's a real pain to have given EWModel's jumping all
over the place as others come and go.  What if instead we prioritize
stable locations -- keep a map of where live EWM's are displayed,
and let them keep having that spot as long as they're relevant. [198:

Sat Jun 27 04:42:26 2020 Ooh and down the road we could let the user
rearrange them by having a selection mechanism plus swap using the
arrow keys..

So, perhaps std::map<EWModel*,UPoint> ?  And we actually update that
map first, and then go back and draw stuff?  Would want to iterate two
ways for that, so make std::map<UPoint, EWModel*> also?[199:

Sat Jun 27 04:56:25 2020 And we'll assume we can layout for the given
width and as many rows as we need?  And I guess we'll scan for empties
when we need one?[200:

Sat Jun 27 05:01:03 2020 Actually how about we do maps to u32 instead
of UPoint, meaning just 'display order', rather than exact position?
That means things might move if the EWMap panel is resized (in the
future) but [201:

Sat Jun 27 05:42:31 2020 Urrgh, wrote a bunch of code in displayPanel,
but that's actually the wrong place for most of it, because we need to
assign and remove display orders on a per trace basis, not a display
basis..  Just the actual display code stays in drawPanel, I
think.[202:

Sat Jun 27 05:44:50 2020 But ugh, we weren't notifying the display
panel on a per-trace basis -- that happens over in the trace panel.
So the two of them would want to share the display ordering code?  Who
should own it??[203:

Sat Jun 27 05:49:53 2020 The EWSlotMap should own it.

:203]

:202]

:201]

:200]

:199]

:198]


:197]

:196]

:195]
[204:

Sat Jun 27 06:32:19 2020 OK well it's doing what I asked of it but
what I asked isn't super great, so sort of

TODO:

 - Having 0/ and 1/ mixed up across rows and cols is confusing, fix

 - Probably want to go column per tile and sort rows by active then
   passive and slotnum inside each of them.

 - Probably want to go with a full-width shallow trace buffer instead
   of the narrow tall one, and give more width to EWMap

 - Definitely want to have the trace map center the active row rather
   than putting it in the top

 - Not clear that we need to indent the different tiles in the trace
   map since the 0/ 1/ is always right there are the front

 - Want keyboard on EWMap to select a particular EWM

 - Would help to have an info window separate from the log window that
   would should details of the selected EWM.

And that's plenty for starters.

But it's getting time for second sleep perhaps, and we're pretty
extended here, so let's have a WIP commit.
[205:

Sat Jun 27 06:38:07 2020 Oh one more thing though: Our new tool is
already pretty clearly showing us passive EWs that are failing to get
cleaned up after active side drops.  Something like this:

EWMapTrace13245
1/a29-AWLOCKS   1/pNE31-PWCACHE       >31.135 0/a30-AWLOCKS -> ADROP         
0/pSE29-PWCACHE 1/pNW30-PWCACHE       31.138    1/iNW:OPEN <NW:BUSY#15 +2   
0/pSW29-PWCACHE 1/a15-ADROP           31.138    1/lDBG ITC/NW:OPEN: Enter hB
0/a30-AWLOCKS                         31.138    1/lDBG a15-ADROP hBUSY ITC/N
                                      31.138    1/lDBG a15-ADROP Not AWLOCKS
                                      31.140    1/iNW:OPEN <NW:ANSWER#29 +2 
                                      31.140    1/lDBG ITC/NW:OPEN: Enter HA
                                      31.140    1/a29-AWLOCKS NW CS_RUNG -> 
                                      31.140    1/lDBG ITC/NW:OPEN a29-AWLOC
                                      31.141    1/lDBG a29-AWLOCKS hANSWER I
                                      31.151    1/iNE:OPEN <NE:ANSWER#29 +2 
                                      31.151    1/lDBG ITC/NE:OPEN: Enter HA
                                      31.151    1/a29-AWLOCKS NE CS_RUNG -> 
                                      31.151    1/lDBG ITC/NE:OPEN a29-AWLOC
                                      31.151    1/lDBG a29-AWLOCKS hANSWER I
Log31.151    1/a29-AWLOCKS -> ABEHAVE    
                                       31.153    1/lDBG a29-ABEHAVE (33,9)BEI
                                       31.153    1/a29-ABEHAVE -> ASCACHE    
                                       31.153    1/lDBG SHIP#0 sn1 (32,9) tt 
                                       31.153    1/lDBG SHIP#1 sn0 (33,9) tt 
                                       31.156    1/iNE:OPEN >NE:TALK#29 +29  
                                       31.156    1/lDBG SHIP#0 sn1 (32,9) tt 


at traceloc 13245, giving way to stuff like this:

EWMapTrace13337
                1/pNE31-PWCACHE       >31.353    1/a21-IDLE -> AINIT         
                1/pNW30-PWCACHE       31.353    1/a21-AINIT a@(29,12)+4     
                                      31.353    1/lDBG a21-AINIT sites avail
                                      31.353    1/lDBG a21-AINIT OWNING (29,
                                      31.353    1/a21-AINIT -> ABEHAVE      
                                      31.353    1/lDBG a21-ABEHAVE (29,12)BE
                                      31.354    1/lDBG a21-ABEHAVE FREEING (
                                      31.354    1/a21-ABEHAVE -> IDLE       
                                      31.373    1/a25-IDLE -> AINIT         
                                      31.373    1/a25-AINIT a@(28,12)+4     
                                      31.373    1/lDBG a25-AINIT sites avail
                                      31.373    1/lDBG a25-AINIT OWNING (28,
                                      31.373    1/a25-AINIT -> ABEHAVE      
                                      31.375    1/lDBG a25-ABEHAVE (28,12)BE
                                      31.375    1/lDBG a25-ABEHAVE FREEING (
Log31.375    1/a25-ABEHAVE -> IDLE       
                                       31.384    1/a05-IDLE -> AINIT         
                                       31.384    1/a05-AINIT a@(34,5)+4      
                                       31.384    1/a05-AINIT NE CS_UNUSED -> 
                                       31.384    1/a05-AINIT NW CS_UNUSED -> 
                                       31.384    1/lDBG a05-AINIT sites avail
                                       31.384    1/lDBG a05-AINIT OWNING (34,


by 13337.

:205]
:204]
